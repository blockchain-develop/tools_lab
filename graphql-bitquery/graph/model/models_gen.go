// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Smart contract method or event
type Signature interface {
	IsSignature()
}

// Search result subject
type Subject interface {
	IsSubject()
}

// Account
type Account struct {
	// Account ID
	ID string `json:"id"`
	// Account number, the equivalent of a human-friendly public key
	Num int `json:"num"`
	// Realm number
	RealmID int `json:"realmId"`
	// Shard number
	ShardID int `json:"shardId"`
}

// Solana Action
type Action struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// Blockchain address
type Address struct {
	// Address
	Address *string `json:"address"`
	// Annotations ( tags ), if exists
	Annotation *string `json:"annotation"`
}

func (Address) IsSubject() {}

// Address selector
type AddressSelector struct {
	// Equal to Address
	Is *string `json:"is"`
	// Not Equal to Address
	Not *string `json:"not"`
	// In the list of Addresses
	In []string `json:"in"`
	// Not in the list of Addresses
	NotIn []string `json:"notIn"`
}

// Address selector
type AddressSelectorIn struct {
	// Equal to Address
	Is *string `json:"is"`
	// In the list of Addresses
	In []string `json:"in"`
}

// Blockchain account with address and type
type AddressWithAccount struct {
	// Account ID
	Account string `json:"account"`
	// Address
	Address *string `json:"address"`
	// Annotations ( tags ), if exists
	Annotation *string `json:"annotation"`
	// Account type
	Type string `json:"type"`
}

// Algorand Blockchain
type Algorand struct {
	// Basic information about address ( or smart contract )
	Address []*AlgorandAddressInfo `json:"address"`
	// Arguments of Smart Contract Calls and Events
	Arguments []*AlgorandArguments `json:"arguments"`
	// Blockchain Blocks
	Blocks []*AlgorandBlocks `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*AlgorandCoinpath `json:"coinpath"`
	// Smart Contract Calls
	SmartContractCalls []*AlgorandSmartContractCalls `json:"smartContractCalls"`
	// Blockchain Transactions
	Transactions []*AlgorandTransactions `json:"transactions"`
	// Currency Transfers
	Transfers []*AlgorandTransfers `json:"transfers"`
}

// Address detailed information for Algorand network
type AlgorandAddressInfo struct {
	// Address
	Address *Address `json:"address"`
	// Current address balance
	Balance *float64 `json:"balance"`
	// Current pending rewards
	PendingRewards *float64 `json:"pendingRewards"`
	// Current rewards
	Rewards *float64 `json:"rewards"`
	// Current round
	Round *string `json:"round"`
	// Smart Contract if exists on the address
	SmartContract *AlgorandSmartContract `json:"smartContract"`
	// Current status
	Status *string `json:"status"`
}

type AlgorandArgumentFilter struct {
	Date                 *DateSelector            `json:"date"`
	Time                 *DateTimeSelector        `json:"time"`
	Height               *BlockSelector           `json:"height"`
	TxHash               *HashSelector            `json:"txHash"`
	TxIndex              *TxIndexSelector         `json:"txIndex"`
	TxType               *TxTypeSelector          `json:"txType"`
	TxFrom               []*AddressSelector       `json:"txFrom"`
	Caller               []*AddressSelector       `json:"caller"`
	Reference            []*AddressSelector       `json:"reference"`
	Value                []*ArgumentValueSelector `json:"value"`
	Argument             []*ArgumentSelector      `json:"argument"`
	SmartContractAddress []*AddressSelector       `json:"smartContractAddress"`
	Argindex             *ArgumentIndexSelector   `json:"argindex"`
}

// Arguments of Smart Contract Calls
type AlgorandArguments struct {
	Any *string `json:"any"`
	// Sequential index of value in array ( multi-dimensional)
	Argindex int `json:"argindex"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date          *Date   `json:"date"`
	FirstRound    *int    `json:"firstRound"`
	GenesisHash64 *string `json:"genesisHash64"`
	GenesisID     *string `json:"genesisId"`
	LastRound     *int    `json:"lastRound"`
	Maximum       *string `json:"maximum"`
	Minimum       *string `json:"minimum"`
	Note          *string `json:"note"`
	Poolerror     *string `json:"poolerror"`
	// Smart contract being called
	SmartContract *AlgorandSmartContract `json:"smartContract"`
	// Transaction where call happened
	Transaction *TransactionHashIndex `json:"transaction"`
	// Transaction sender
	TxSender *Address `json:"txSender"`
	// Transaction type in which the transfer happened
	TxType *AlgorandTxType `json:"txType"`
	// The Value of argument
	Value *string `json:"value"`
}

type AlgorandBlockFilter struct {
	Date            *DateSelector      `json:"date"`
	Time            *DateTimeSelector  `json:"time"`
	Height          *BlockSelector     `json:"height"`
	BlockHash       *HashSelector      `json:"blockHash"`
	Proposer        []*AddressSelector `json:"proposer"`
	BlockReward     []*AmountSelector  `json:"blockReward"`
	NextProtocol    *StringIDSelector  `json:"nextProtocol"`
	CurrentProtocol *StringIDSelector  `json:"currentProtocol"`
}

// Blocks in Algorand blockchain
type AlgorandBlocks struct {
	Any             *string `json:"any"`
	Count           *int    `json:"count"`
	CountBigInt     *string `json:"countBigInt"`
	CurrentProtocol *string `json:"currentProtocol"`
	// Calendar date
	Date *Date  `json:"date"`
	Frac string `json:"frac"`
	// Block hash
	Hash string `json:"hash"`
	// Block number (height) in blockchain
	Height                 int     `json:"height"`
	Maximum                *string `json:"maximum"`
	Minimum                *string `json:"minimum"`
	NextProtocol           *string `json:"nextProtocol"`
	NextProtocolApprovals  *string `json:"nextProtocolApprovals"`
	NextProtocolSwitchOn   *string `json:"nextProtocolSwitchOn"`
	NextProtocolVoteBefore *string `json:"nextProtocolVoteBefore"`
	// Previous block hash
	PreviousBlockHash string `json:"previousBlockHash"`
	// Block proposer
	Proposer *Address `json:"proposer"`
	Rate     *float64 `json:"rate"`
	Reward   *float64 `json:"reward"`
	Seed     *string  `json:"seed"`
	// Block timestamp
	Timestamp      *DateTime `json:"timestamp"`
	TxnRoot        string    `json:"txnRoot"`
	UpgradeApprove *int      `json:"upgradeApprove"`
	UpgradePropose *string   `json:"upgradePropose"`
}

// Coinpath
type AlgorandCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
	// Transaction of transfer happened
	Transaction *TransactionHashValue `json:"transaction"`
}

// Currency selector in Algorand blockchain.
//   Currency is selected by asset ID. To select ALGO use ID=0
type AlgorandCurrencySelector struct {
	// Currency is
	Is *int `json:"is"`
	// Currency not
	Not *int `json:"not"`
	// Currency in the list
	In []int `json:"in"`
	// Currency not in the list
	NotIn []int `json:"notIn"`
}

// Algorand smart contract
type AlgorandSmartContract struct {
	// Smart Contract Address
	Address *Address `json:"address"`
	// Smart Contract byte code
	Bytecode *string `json:"bytecode"`
	// Smart Contract Deassembled source code
	Source *string `json:"source"`
}

type AlgorandSmartContractCallFilter struct {
	Date                 *DateSelector      `json:"date"`
	Time                 *DateTimeSelector  `json:"time"`
	Height               *BlockSelector     `json:"height"`
	TxHash               *HashSelector      `json:"txHash"`
	TxIndex              *TxIndexSelector   `json:"txIndex"`
	TxSender             []*AddressSelector `json:"txSender"`
	SmartContractAddress []*AddressSelector `json:"smartContractAddress"`
	TxType               *TxTypeSelector    `json:"txType"`
}

// Smart Contract Calls
type AlgorandSmartContractCalls struct {
	Any *string `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Fee used in transaction call
	Fee           *float64 `json:"fee"`
	FirstRound    *int     `json:"firstRound"`
	GenesisHash64 *string  `json:"genesisHash64"`
	GenesisID     *string  `json:"genesisId"`
	LastRound     *int     `json:"lastRound"`
	Maximum       *string  `json:"maximum"`
	Minimum       *string  `json:"minimum"`
	Note          *string  `json:"note"`
	Poolerror     *string  `json:"poolerror"`
	// Smart contract being called
	SmartContract *AlgorandSmartContract `json:"smartContract"`
	// Transaction where call happened
	Transaction *TransactionHashIndex `json:"transaction"`
	// Transaction sender
	TxSender *Address `json:"txSender"`
	// Transaction type in which the transfer happened
	TxType *AlgorandTxType `json:"txType"`
}

type AlgorandTransactionFilter struct {
	Date       *DateSelector               `json:"date"`
	Time       *DateTimeSelector           `json:"time"`
	Height     *BlockSelector              `json:"height"`
	TxHash     *HashSelector               `json:"txHash"`
	TxSender   []*AddressSelector          `json:"txSender"`
	TxIndex    *TxIndexSelector            `json:"txIndex"`
	TxCurrency []*AlgorandCurrencySelector `json:"txCurrency"`
	TxType     *TxTypeSelector             `json:"txType"`
	TxSubtype  *TxSubtypeSelector          `json:"txSubtype"`
}

// Algorand transaction with attributes
type AlgorandTransactionWithAttributes struct {
	// Block of the Output Transaction for this input
	Block *int `json:"block"`
	// Transaction fee
	Fee        *float64 `json:"fee"`
	FirstRound *int     `json:"firstRound"`
	// Transaction rewards ( from )
	Fromrewards *float64 `json:"fromrewards"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0-based
	Index     string  `json:"index"`
	LastRound *int    `json:"lastRound"`
	Lease     *string `json:"lease"`
	Note      *string `json:"note"`
	Poolerror *string `json:"poolerror"`
	// Transfer transaction sender
	Sender *Address `json:"sender"`
	// Transaction sub type
	Subtype *AlgorandTxSubType `json:"subtype"`
	// Transaction type in which the transfer happened
	Type *AlgorandTxType `json:"type"`
}

// Transactions in Algorand blockchain
type AlgorandTransactions struct {
	Any *string `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Asset related to transaction
	Currency *Currency `json:"currency"`
	// Calendar date
	Date        *Date    `json:"date"`
	Fee         *float64 `json:"fee"`
	FirstRound  *int     `json:"firstRound"`
	GenesisHash *string  `json:"genesisHash"`
	GenesisID   *string  `json:"genesisId"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0 based
	Index     *int    `json:"index"`
	LastRound *int    `json:"lastRound"`
	Maximum   *string `json:"maximum"`
	Minimum   *string `json:"minimum"`
	Note      *string `json:"note"`
	Poolerror *string `json:"poolerror"`
	// Transaction sender
	Sender *Address `json:"sender"`
	// Transaction sub type
	Subtype *AlgorandTxSubType `json:"subtype"`
	// Transaction type
	Type *AlgorandTxType `json:"type"`
}

type AlgorandTransferFilter struct {
	Date         *DateSelector                 `json:"date"`
	Time         *DateTimeSelector             `json:"time"`
	Height       *BlockSelector                `json:"height"`
	TxHash       *HashSelector                 `json:"txHash"`
	TxSender     []*AddressSelector            `json:"txSender"`
	TxIndex      *TxIndexSelector              `json:"txIndex"`
	Sender       []*AddressSelector            `json:"sender"`
	Receiver     []*AddressSelector            `json:"receiver"`
	Currency     []*AlgorandCurrencySelector   `json:"currency"`
	Amount       []*AmountSelector             `json:"amount"`
	TxType       *TxTypeSelector               `json:"txType"`
	TransferType *AlgorandTransferTypeSelector `json:"transferType"`
}

// Select transfers by type
type AlgorandTransferTypeSelector struct {
	// Transfer Type is
	Is *AlgorandTransferType `json:"is"`
	// Transfer Type not
	Not *AlgorandTransferType `json:"not"`
	// Transfer Type in the list
	In []AlgorandTransferType `json:"in"`
	// Transfer Type not in the list
	NotIn []AlgorandTransferType `json:"notIn"`
}

// Currency transfers from/to addresses in crypto currencies
type AlgorandTransfers struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date       *Date   `json:"date"`
	FirstRound *int    `json:"firstRound"`
	LastRound  *int    `json:"lastRound"`
	Maximum    *string `json:"maximum"`
	Memo       *string `json:"memo"`
	Minimum    *string `json:"minimum"`
	// Transfer receiver
	Receiver *Address `json:"receiver"`
	// Transfer sender
	Sender *Address `json:"sender"`
	// Transaction where transfer happened
	Transaction *AlgorandTransactionWithAttributes `json:"transaction"`
	// Transfer Type
	TransferType *AlgorandTransferType `json:"transferType"`
}

// Select by amount
type AmountSelector struct {
	// Amount is
	Is *float64 `json:"is"`
	// Amount not
	Not *float64 `json:"not"`
	// Amount in the list
	In []float64 `json:"in"`
	// Amount not in the list
	NotIn []float64 `json:"notIn"`
	// Amount greater than
	Gt *float64 `json:"gt"`
	// Amount less than
	Lt *float64 `json:"lt"`
	// Amount less or equal than
	Lteq *float64 `json:"lteq"`
	// Amount greater or equal than
	Gteq *float64 `json:"gteq"`
	// Amount in range
	Between []float64 `json:"between"`
}

// Selector of index of argument in call
type ArgumentIndexSelector struct {
	// Tx index is
	Is *int `json:"is"`
	// Tx index not
	Not *int `json:"not"`
	// Tx index in the list
	In []int `json:"in"`
	// Tx index not in the list
	NotIn []int `json:"notIn"`
}

// Argument of Smart contract method or event
type ArgumentName struct {
	// Name
	Name string `json:"name"`
	// Type
	Type string `json:"type"`
}

// Argument name and value of smart contract call or event
type ArgumentNameValue struct {
	// Argument name
	Argument string `json:"argument"`
	// Argument data type
	ArgumentType string `json:"argumentType"`
	// Sequential index of value in array ( multi-dimensional)
	Index string `json:"index"`
	// Value as String
	Value string `json:"value"`
}

// Selector of argument for smart contract method or event
type ArgumentSelector struct {
	// Argument is
	Is *string `json:"is"`
	// Argument not
	Not *string `json:"not"`
	// Argument in the list
	In []string `json:"in"`
	// Argument not in the list
	NotIn []string `json:"notIn"`
}

// Selector of argument type for smart contract method or event
type ArgumentTypeSelector struct {
	// Argument type is
	Is *string `json:"is"`
	// Argument type not
	Not *string `json:"not"`
	// Argument type in the list
	In []string `json:"in"`
	// Argument type not in the list
	NotIn []string `json:"notIn"`
}

// Argument value of smart contract call or event
type ArgumentValue struct {
	// Value as Address
	Address *EthereumAddressInfo `json:"address"`
	// Value as String
	Value string `json:"value"`
}

// Selector of value of argument for smart contract method or event
type ArgumentValueSelector struct {
	// Value is
	Is *string `json:"is"`
	// Value not
	Not *string `json:"not"`
	// Value in the list
	In []string `json:"in"`
	// Value not in the list
	NotIn []string `json:"notIn"`
}

// Select by ID with BigInt datatype
type BigIntIDSelector struct {
	// ID is
	Is *string `json:"is"`
	// ID not
	Not *string `json:"not"`
	// ID in the list
	In []string `json:"in"`
	// ID not in the list
	NotIn []string `json:"notIn"`
	// ID greater than
	Gt *string `json:"gt"`
	// ID less than
	Lt *string `json:"lt"`
	// ID less or equal than
	Lteq *string `json:"lteq"`
	// ID greater or equal than
	Gteq *string `json:"gteq"`
	// ID in range
	Between []string `json:"between"`
}

// Binance DEX
type Binance struct {
	// Binance DEX Network Blocks
	Blocks []*BinanceBlock `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*BinanceCoinpath `json:"coinpath"`
	// Binance DEX Network Exchange Orders
	Orders []*BinanceOrders `json:"orders"`
	// Binance DEX Network Trades between currencies
	Trades []*BinanceTrades `json:"trades"`
	// Binance DEX Network Transactions
	Transactions []*BinanceTransactions `json:"transactions"`
	// Binance DEX Network Currency Transfers
	Transfers []*BinanceTransfers `json:"transfers"`
}

// Binance Address should start with bnb and contain 42 chars.
type BinanceAddressSelector struct {
	// Equal to Address
	Is *string `json:"is"`
	// Not Equal to Address
	Not *string `json:"not"`
	// In the list of Addresses
	In *string `json:"in"`
	// Not in the list of Addresses
	NotIn *string `json:"notIn"`
}

// Block
type BinanceBlock struct {
	Any *string `json:"any"`
	// Block ID
	BlockID     *string `json:"blockId"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Block number (height) in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Validator consensus pubkey
	ValidatorConsensusPubkey *string `json:"validatorConsensusPubkey"`
	// Validator fee address
	ValidatorFeeAddr *Address `json:"validatorFeeAddr"`
	// Validator moniker
	ValidatorMoniker *string `json:"validatorMoniker"`
	// Validator operator HR address
	ValidatorOperaHrAddress *Address `json:"validatorOperaHrAddress"`
	// Validator operator address
	ValidatorOperatorAddress *Address `json:"validatorOperatorAddress"`
}

type BinanceBlockFilter struct {
	Date                     *DateSelector           `json:"date"`
	Time                     *DateTimeSelector       `json:"time"`
	Height                   *BlockSelector          `json:"height"`
	BlockID                  *StringIDSelector       `json:"blockId"`
	ValidatorMoniker         *StringIDSelector       `json:"validatorMoniker"`
	ValidatorFeeAddr         *BinanceAddressSelector `json:"validatorFeeAddr"`
	ValidatorOperatorAddress *BinanceAddressSelector `json:"validatorOperatorAddress"`
	ValidatorOperahraddress  *BinanceAddressSelector `json:"validatorOperahraddress"`
}

// Coinpath
type BinanceCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
	// Transaction of transfer happened
	Transaction *TransactionHashValue `json:"transaction"`
}

// Binance token selector by tokenId.
//     Native binance token has BNB symbol.
//     Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
type BinanceCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

type BinanceOrderFilter struct {
	Date             *DateSelector               `json:"date"`
	Time             *DateTimeSelector           `json:"time"`
	Height           *BlockSelector              `json:"height"`
	TxHash           *HashSelector               `json:"txHash"`
	OrderOwner       []*BinanceAddressSelector   `json:"orderOwner"`
	OrderID          []*OrderIDSelector          `json:"orderId"`
	BaseCurrency     []*BinanceCurrencySelector  `json:"baseCurrency"`
	QuoteCurrency    []*BinanceCurrencySelector  `json:"quoteCurrency"`
	QuoteAmount      []*AmountSelector           `json:"quoteAmount"`
	BaseAmount       []*AmountSelector           `json:"baseAmount"`
	Price            []*AmountSelector           `json:"price"`
	OrderStatus      []*OrderStatusSelector      `json:"orderStatus"`
	OrderType        []*OrderTypeSelector        `json:"orderType"`
	OrderSide        []*OrderSideSelector        `json:"orderSide"`
	OrderTimeInForce []*OrderTimeInForceSelector `json:"orderTimeInForce"`
}

// Binance DEX Order
type BinanceOrders struct {
	Any          *string   `json:"any"`
	BaseAmount   *float64  `json:"baseAmount"`
	BaseCurrency *Currency `json:"baseCurrency"`
	// Block where order transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Order ID
	OrderID *string `json:"orderId"`
	// Order owner address
	OrderOwner *Address `json:"orderOwner"`
	// Order Side
	OrderSide *BinanceOrderSide `json:"orderSide"`
	// Order Status
	OrderStatus *BinanceOrderStatus `json:"orderStatus"`
	// Order Time In Force
	OrderTimeInForce *BinanceOrderTimeInForce `json:"orderTimeInForce"`
	// Order Type
	OrderType     *BinanceOrderType `json:"orderType"`
	Price         *float64          `json:"price"`
	QuoteAmount   *float64          `json:"quoteAmount"`
	QuoteCurrency *Currency         `json:"quoteCurrency"`
	// Transaction where order created
	Transaction *TransactionHash `json:"transaction"`
}

type BinanceTradeFilter struct {
	Date          *DateSelector              `json:"date"`
	Time          *DateTimeSelector          `json:"time"`
	Height        *BlockSelector             `json:"height"`
	TxHash        *HashSelector              `json:"txHash"`
	Buyer         []*BinanceAddressSelector  `json:"buyer"`
	Seller        []*BinanceAddressSelector  `json:"seller"`
	SellOrderID   []*OrderIDSelector         `json:"sellOrderId"`
	BuyOrderID    []*OrderIDSelector         `json:"buyOrderId"`
	TradeID       []*TradeIDSelector         `json:"tradeId"`
	BaseCurrency  []*BinanceCurrencySelector `json:"baseCurrency"`
	QuoteCurrency []*BinanceCurrencySelector `json:"quoteCurrency"`
	QuoteAmount   []*AmountSelector          `json:"quoteAmount"`
	BaseAmount    []*AmountSelector          `json:"baseAmount"`
	Price         []*AmountSelector          `json:"price"`
}

// Binance DEX Trades
type BinanceTrades struct {
	Any          *string   `json:"any"`
	BaseAmount   *float64  `json:"baseAmount"`
	BaseCurrency *Currency `json:"baseCurrency"`
	// Block where trade transaction is included
	Block *Block `json:"block"`
	// Buy Order ID
	BuyOrderID *string `json:"buyOrderId"`
	// Trade buyer address
	Buyer       *Address `json:"buyer"`
	Count       *int     `json:"count"`
	CountBigInt *string  `json:"countBigInt"`
	// Calendar date
	Date          *Date     `json:"date"`
	Maximum       *string   `json:"maximum"`
	Minimum       *string   `json:"minimum"`
	Price         *float64  `json:"price"`
	QuoteAmount   *float64  `json:"quoteAmount"`
	QuoteCurrency *Currency `json:"quoteCurrency"`
	// Sell Order ID
	SellOrderID *string `json:"sellOrderId"`
	// Trade seller address
	Seller *Address `json:"seller"`
	// Trade ID
	TradeID *string `json:"tradeId"`
	// Transaction where trade happened
	Transaction *TransactionHashIndex `json:"transaction"`
}

type BinanceTransactionFilter struct {
	Date              *DateSelector                   `json:"date"`
	Time              *DateTimeSelector               `json:"time"`
	Height            *BlockSelector                  `json:"height"`
	TxHash            *HashSelector                   `json:"txHash"`
	TransactionType   *BinanceTransactionTypeSelector `json:"transactionType"`
	ProposalID        *StringIDSelector               `json:"proposalId"`
	Currency          []*BinanceCurrencySelector      `json:"currency"`
	TransactionCode   *IntIDSelector                  `json:"transactionCode"`
	TransactionSource *IntIDSelector                  `json:"transactionSource"`
	Deposit           []*AmountSelector               `json:"deposit"`
}

// Select by transaction type
type BinanceTransactionTypeSelector struct {
	// Transaction Type is
	Is *BinanceTransactionType `json:"is"`
	// Transaction Type not
	Not *BinanceTransactionType `json:"not"`
	// Transaction Type in the list
	In []BinanceTransactionType `json:"in"`
	// Transaction Type not in the list
	NotIn []BinanceTransactionType `json:"notIn"`
}

// Transaction
type BinanceTransactions struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency issued in transaction
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Deposit amount in transaction
	Deposit *float64 `json:"deposit"`
	// Transaction Description
	Description *string `json:"description"`
	// Hash hex representation
	Hash string `json:"hash"`
	// TX index in block, 0 based
	Index *int `json:"index"`
	// Transaction Log
	Log     *string `json:"log"`
	Maximum *string `json:"maximum"`
	// Transaction Memo
	Memo    *string `json:"memo"`
	Minimum *string `json:"minimum"`
	// Proposal ID
	ProposalID *int `json:"proposalId"`
	// Transaction Type
	TransactionCode *int `json:"transactionCode"`
	// Transaction Source
	TransactionSource *TransactionSource `json:"transactionSource"`
	// Transaction Type
	TransactionType *BinanceTransactionType `json:"transactionType"`
}

type BinanceTransferFilter struct {
	Date         *DateSelector                  `json:"date"`
	Time         *DateTimeSelector              `json:"time"`
	Height       *BlockSelector                 `json:"height"`
	TxHash       *HashSelector                  `json:"txHash"`
	Sender       []*BinanceAddressSelector      `json:"sender"`
	Receiver     []*BinanceAddressSelector      `json:"receiver"`
	Currency     []*BinanceCurrencySelector     `json:"currency"`
	TransferType []*BinanceTransferTypeSelector `json:"transferType"`
	OrderID      []*OrderIDSelector             `json:"orderId"`
	TradeID      []*TradeIDSelector             `json:"tradeId"`
	Amount       []*AmountSelector              `json:"amount"`
	OutputIndex  []*OutputIndexSelector         `json:"outputIndex"`
}

// Select transfer type(s)
type BinanceTransferTypeSelector struct {
	// Transfer type is
	Is *BinanceTransferType `json:"is"`
	// Transfer type not
	Not *BinanceTransferType `json:"not"`
	// Transfer type in the list
	In []BinanceTransferType `json:"in"`
	// Transfer type not in the list
	NotIn []BinanceTransferType `json:"notIn"`
}

// Currency transfers from/to addresses in crypto currencies
type BinanceTransfers struct {
	// Transfer amount
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block *Block `json:"block"`
	// Transfer count
	Count *int `json:"count"`
	// Transfer count
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Order Id of trade where transfer happened
	OrderID *string `json:"orderId"`
	// Index of the output for the transfer, 0-based
	OutputIndex *int `json:"outputIndex"`
	// Transfer receiver
	Receiver *Address `json:"receiver"`
	// Transfer sender
	Sender *Address `json:"sender"`
	// Id of trade where transfer happened
	TradeID *string `json:"tradeId"`
	// Transaction where transfer happened
	Transaction *TransactionHashIndex `json:"transaction"`
	// Transfer type
	TransferType *BinanceTransferType `json:"transferType"`
}

// Bitcoin and other UTXO type blockchains
type Bitcoin struct {
	// Blockchain Blocks
	Blocks []*BitcoinBlock `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*BitcoinCoinpath `json:"coinpath"`
	// Blockchain Transaction Inputs
	Inputs []*BitcoinTransactionInput `json:"inputs"`
	// Blockchain Transaction OmniTransactions
	OmniTransactions []*BitcoinOmniTransactiosn `json:"omniTransactions"`
	// Blockchain Transaction OmniTransfers
	OmniTransfers []*BitcoinOmniTransfers `json:"omniTransfers"`
	// Blockchain Transaction Outputs
	Outputs []*BitcoinTransactionOutput `json:"outputs"`
	// Blockchain Transactions
	Transactions []*BitcoinTransaction `json:"transactions"`
}

// Block
type BitcoinBlock struct {
	Any *string `json:"any"`
	// Block Hash
	BlockHash *string `json:"blockHash"`
	// Block size
	BlockSize *int `json:"blockSize"`
	// Block stripped size
	BlockStrippedSize *int `json:"blockStrippedSize"`
	// Block version
	BlockVersion *int `json:"blockVersion"`
	// Block weight
	BlockWeight *int `json:"blockWeight"`
	// Block chainwork
	Chainwork   *string `json:"chainwork"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Difficulty
	Difficulty *float64 `json:"difficulty"`
	// Block number (height) in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	// Block median timestamp
	MedianTime *DateTime `json:"medianTime"`
	Minimum    *string   `json:"minimum"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Transaction count in block
	TransactionCount *int `json:"transactionCount"`
}

type BitcoinBlockFilter struct {
	Date              *DateSelector     `json:"date"`
	Time              *DateTimeSelector `json:"time"`
	Height            *BlockSelector    `json:"height"`
	BlockHash         *StringIDSelector `json:"blockHash"`
	BlockSize         *IntegerSelector  `json:"blockSize"`
	BlockWeight       *IntegerSelector  `json:"blockWeight"`
	BlockVersion      *IntegerSelector  `json:"blockVersion"`
	TransactionCount  *IntegerSelector  `json:"transactionCount"`
	BlockStrippedSize *IntegerSelector  `json:"blockStrippedSize"`
	Difficulty        *FloatSelector    `json:"difficulty"`
}

// Coinpath
type BitcoinCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
	// Transaction of transfer happened
	Transaction *BitcoinTransactionHashIndexValues `json:"transaction"`
	// Attributes of transaction included in Coinpath result
	Transactions []*CoinpathEntry `json:"transactions"`
}

// Limits, Ordering, Constraints, Coinpath Options
type BitcoinCoinpathOptions struct {
	// Limit number of results
	Limit *int `json:"limit"`
	// Limit number of results by specific field
	LimitBy *LimitByOption `json:"limitBy"`
	// Offset of results, starting from 0
	Offset *int `json:"offset"`
	// Ordering field(s) for ascending
	Asc []string `json:"asc"`
	// Ordering field(s) for descending
	Desc []string `json:"desc"`
	// Flow direction
	Direction *FlowDirection `json:"direction"`
	// Do not include transactions below this amount
	MinimumTxAmount *float64 `json:"minimumTxAmount"`
	// Do not expand addresses having count transactions more than this
	MaximumAddressTxCount *int `json:"maximumAddressTxCount"`
	// Maximum total transaction count returned
	MaximumTotalTxCount *int `json:"maximumTotalTxCount"`
	// Raise error if complexity ( currently measured in transaction count ) is higher than this option
	ComplexityLimit *int `json:"complexityLimit"`
	// Invalidating cache seed
	Seed *int `json:"seed"`
	// Method to use coinpath
	CoinpathMethod *BitcoinCoinpathMethod `json:"coinpathMethod"`
}

type BitcoinInputFilter struct {
	Date            *DateSelector                   `json:"date"`
	Time            *DateTimeSelector               `json:"time"`
	Height          *BlockSelector                  `json:"height"`
	TxHash          *HashSelector                   `json:"txHash"`
	TxIndex         *IntegerSelector                `json:"txIndex"`
	InputIndex      *IntegerSelector                `json:"inputIndex"`
	InputAddress    *AddressSelector                `json:"inputAddress"`
	InOutputTxID    *HashSelector                   `json:"inOutputTxId"`
	InOutputIndex   *IntegerSelector                `json:"inOutputIndex"`
	InputScriptType *BitcoinInputScriptTypeSelector `json:"inputScriptType"`
	InputValue      *FloatSelector                  `json:"inputValue"`
}

// Selector of input script type
type BitcoinInputScriptTypeSelector struct {
	// Equal to Script Type
	Is *BitcoinInputScriptType `json:"is"`
	// Not Equal to Script Type
	Not *BitcoinInputScriptType `json:"not"`
	// In the list of Script Type
	In []BitcoinInputScriptType `json:"in"`
	// Not in the list of Script Type
	NotIn []BitcoinInputScriptType `json:"notIn"`
}

type BitcoinOmniTransactionsFilter struct {
	Date          *DateSelector     `json:"date"`
	Time          *DateTimeSelector `json:"time"`
	Height        *BlockSelector    `json:"height"`
	TxHash        *HashSelector     `json:"txHash"`
	TxIndex       *IntegerSelector  `json:"txIndex"`
	Version       *IntegerSelector  `json:"version"`
	Valid         *IntegerSelector  `json:"valid"`
	InvalidReason *StringSelector   `json:"invalidReason"`
	Type          *StringSelector   `json:"type"`
	TypeID        *IntegerSelector  `json:"typeId"`
	TxSender      *HashSelector     `json:"txSender"`
	FeeValue      *FloatSelector    `json:"feeValue"`
}

// OmniTransactions
type BitcoinOmniTransactiosn struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Hash of the block
	BlockHash string `json:"blockHash"`
	// OmniTransaction s count
	Count *int `json:"count"`
	// OmniTransaction s count
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Transactions total fee value
	FeeValue *float64 `json:"feeValue"`
	// Hash hex representation
	Hash string `json:"hash"`
	// OmniTransactions index in block, 0-based
	Index string `json:"index"`
	// Invalid Reason
	InvalidReason string `json:"invalidReason"`
	// Invalid Reason
	JSON    string  `json:"json"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Transaction Sender
	TxSender string `json:"txSender"`
	// Type
	Type string `json:"type"`
	// Type Int
	TypeInt int `json:"typeInt"`
	// Version
	Valid int `json:"valid"`
	// Version
	Version int `json:"version"`
}

// OmniTransfers
type BitcoinOmniTransfers struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Hash of the block
	BlockHash string `json:"blockHash"`
	// Transaction s count
	Count *int `json:"count"`
	// Transaction s count
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Direction
	Direction *string `json:"direction"`
	// Divisible
	Divisible *int `json:"divisible"`
	// Transactions total fee value
	FeeValue *float64 `json:"feeValue"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transactions index in block, 0-based
	Index string `json:"index"`
	// Ismine
	Ismine  *int    `json:"ismine"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Transfer From
	TransferFrom string `json:"transferFrom"`
	// Transfer From
	TransferTo string `json:"transferTo"`
	// Transaction Sender
	TxSender string `json:"txSender"`
	// Type
	Type string `json:"type"`
	// Type Int
	TypeInt int `json:"typeInt"`
	// value
	Value *float64 `json:"value"`
}

type BitcoinOmniTransfersFilter struct {
	Date          *DateSelector     `json:"date"`
	Time          *DateTimeSelector `json:"time"`
	Height        *BlockSelector    `json:"height"`
	TxHash        *HashSelector     `json:"txHash"`
	TxIndex       *IntegerSelector  `json:"txIndex"`
	Version       *IntegerSelector  `json:"version"`
	Valid         *IntegerSelector  `json:"valid"`
	InvalidReason *StringSelector   `json:"invalidReason"`
	Type          *StringSelector   `json:"type"`
	TypeID        *IntegerSelector  `json:"typeId"`
	TxSender      *HashSelector     `json:"txSender"`
	FeeValue      *FloatSelector    `json:"feeValue"`
}

// A guessed direction of output
type BitcoinOutputDirectionSelector struct {
	// Equal to direction
	Is *BitcoinOutputDirection `json:"is"`
	// Not Equal to direction
	Not *BitcoinOutputDirection `json:"not"`
	// In the list of direction
	In []BitcoinOutputDirection `json:"in"`
	// Not in the list of direction
	NotIn []BitcoinOutputDirection `json:"notIn"`
}

type BitcoinOutputFilter struct {
	Date             *DateSelector                    `json:"date"`
	Time             *DateTimeSelector                `json:"time"`
	Height           *BlockSelector                   `json:"height"`
	TxHash           *HashSelector                    `json:"txHash"`
	TxIndex          *IntegerSelector                 `json:"txIndex"`
	OutputIndex      *IntegerSelector                 `json:"outputIndex"`
	OutputAddress    *AddressSelector                 `json:"outputAddress"`
	OutputScriptType *BitcoinOutputScriptTypeSelector `json:"outputScriptType"`
	OutputDirection  *BitcoinOutputDirectionSelector  `json:"outputDirection"`
	OutputValue      *FloatSelector                   `json:"outputValue"`
}

// Selector of output script type
type BitcoinOutputScriptTypeSelector struct {
	// Equal to Script Type
	Is *BitcoinOutputScriptType `json:"is"`
	// Not Equal to Script Type
	Not *BitcoinOutputScriptType `json:"not"`
	// In the list of Script Type
	In []BitcoinOutputScriptType `json:"in"`
	// Not in the list of Script Type
	NotIn []BitcoinOutputScriptType `json:"notIn"`
}

// Transaction
type BitcoinTransaction struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Transaction  count
	Count *int `json:"count"`
	// Transaction  count
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Transaction total fee value
	FeeValue *float64 `json:"feeValue"`
	// Transaction total fee value
	FeeValueDecimal *string `json:"feeValueDecimal"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0-based
	Index string `json:"index"`
	// Transaction total input count
	InputCount *int `json:"inputCount"`
	// Transaction total input count
	InputCountBigInt *string `json:"inputCountBigInt"`
	// Transaction total input value
	InputValue *float64 `json:"inputValue"`
	// Transaction total input value as decimal
	InputValueDecimal *string `json:"inputValueDecimal"`
	Maximum           *string `json:"maximum"`
	// Transaction total mined value
	MinedValue *float64 `json:"minedValue"`
	// Transaction total mined value
	MinedValueDecimal *string `json:"minedValueDecimal"`
	Minimum           *string `json:"minimum"`
	// Transaction total output count
	OutputCount *int `json:"outputCount"`
	// Transaction total output count
	OutputCountBigInt *string `json:"outputCountBigInt"`
	// Transaction total output value
	OutputValue *float64 `json:"outputValue"`
	// Transaction total output value
	OutputValueDecimal *string `json:"outputValueDecimal"`
	// Transaction is coinbase
	TxCoinbase *bool `json:"txCoinbase"`
	// Transaction locktime
	TxLocktime *string `json:"txLocktime"`
	// Transaction size
	TxSize *int `json:"txSize"`
	// Transaction version
	TxVersion *int `json:"txVersion"`
	// Transaction vsize
	TxVsize *int `json:"txVsize"`
	// Transaction weight
	TxWeight *int `json:"txWeight"`
}

type BitcoinTransactionFilter struct {
	Date          *DateSelector      `json:"date"`
	Time          *DateTimeSelector  `json:"time"`
	Height        *BlockSelector     `json:"height"`
	TxHash        *HashSelector      `json:"txHash"`
	TxIndex       *IntegerSelector   `json:"txIndex"`
	TxSize        *IntegerSelector   `json:"txSize"`
	TxVsize       *IntegerSelector   `json:"txVsize"`
	TxWeight      *IntegerSelector   `json:"txWeight"`
	TxVersion     *IntegerSelector   `json:"txVersion"`
	TxCoinbase    *bool              `json:"txCoinbase"`
	InputCount    *IntegerSelector   `json:"inputCount"`
	OutputCount   *IntegerSelector   `json:"outputCount"`
	InputValue    *FloatSelector     `json:"inputValue"`
	OutputValue   *FloatSelector     `json:"outputValue"`
	FeeValue      *FloatSelector     `json:"feeValue"`
	MinedValue    *FloatSelector     `json:"minedValue"`
	TxLocktime    *IntegerSelector   `json:"txLocktime"`
	OutputAddress *AddressSelectorIn `json:"outputAddress"`
	InputAddress  *AddressSelectorIn `json:"inputAddress"`
}

// Blockchain transaction
type BitcoinTransactionHashIndexValues struct {
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0-based
	Index string `json:"index"`
	// Transaction value in input
	ValueIn float64 `json:"valueIn"`
	// Transaction value in input
	ValueInDecimal string `json:"valueInDecimal"`
	// Transaction value in output
	ValueOut float64 `json:"valueOut"`
	// Transaction value in output
	ValueOutDecimal string `json:"valueOutDecimal"`
}

// Transaction Input
type BitcoinTransactionInput struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Input count
	Count *int `json:"count"`
	// Input count
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Input address
	InputAddress *Address `json:"inputAddress"`
	// Input index
	InputIndex *int `json:"inputIndex"`
	// Input script
	InputScript *string `json:"inputScript"`
	// Input script type and attributes
	InputScriptType *InputScript `json:"inputScriptType"`
	Maximum         *string      `json:"maximum"`
	Minimum         *string      `json:"minimum"`
	// Output Transaction for this input
	OutputTransaction *TransactionHashIndex `json:"outputTransaction"`
	// Transaction ID Hash
	Transaction *TransactionHashIndex `json:"transaction"`
	// Input value
	Value *float64 `json:"value"`
	// Input value as decimal
	ValueDecimal *string `json:"valueDecimal"`
}

// Transaction Output
type BitcoinTransactionOutput struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Output count
	Count *int `json:"count"`
	// Output count
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Output address
	OutputAddress *Address `json:"outputAddress"`
	// Output guessed direction
	OutputDirection *BitcoinOutputDirection `json:"outputDirection"`
	// Output index
	OutputIndex *int `json:"outputIndex"`
	// Output script
	OutputScript *string `json:"outputScript"`
	// Output script type and attributes
	OutputScriptType *OutputScript `json:"outputScriptType"`
	ReqSigs          *int          `json:"reqSigs"`
	// Transaction ID Hash
	Transaction *TransactionHashIndex `json:"transaction"`
	// Output value
	Value *float64 `json:"value"`
	// Output value as decimal
	ValueDecimal *string `json:"valueDecimal"`
}

// Block
type Block struct {
	// Block number (height) in blockchain
	Height int `json:"height"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
}

// BlockExtended
type BlockExtended struct {
	// Hash hex representation
	Hash string `json:"hash"`
	// Block number (height) in blockchain
	Height int `json:"height"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
}

// ConfluxBlock
type BlockInfo struct {
	// Block hash
	Hash *string `json:"hash"`
	// Block number (height) in blockchain
	Height int `json:"height"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
}

// Select block by height ( sequence number)
type BlockSelector struct {
	// Block height is
	Is *int `json:"is"`
	// Block height not
	Not *int `json:"not"`
	// Block height in the list
	In []int `json:"in"`
	// Block height not in the list
	NotIn []int `json:"notIn"`
	// Block height greater than
	Gt *int `json:"gt"`
	// Block height less than
	Lt *int `json:"lt"`
	// Block height less or equal than
	Lteq *int `json:"lteq"`
	// Block height greater or equal than
	Gteq *int `json:"gteq"`
	// Block height in range
	Between []int `json:"between"`
}

// Select block by height ( sequence number)
type BlockSelectorRange struct {
	// Block height less or equal than
	Lteq *int `json:"lteq"`
	// Block height greater or equal than
	Gteq *int `json:"gteq"`
	// Block height in range
	Between []int `json:"between"`
}

// Blockchain network
type BlockchainNetwork struct {
	// Network name
	Network Network `json:"network"`
	// Network protocol type
	Protocol Protocol `json:"protocol"`
}

// Select by boolean (sequence number)
type BooleanSelector struct {
	// Is
	Is *bool `json:"is"`
	// Is not
	Not *bool `json:"not"`
}

// Information about call
type CallElrond struct {
	// Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
	CallDepth *string `json:"callDepth"`
	// Contract method invoked
	SmartContractAddress *string `json:"smartContractAddress"`
	// Smart contract name
	SmartContractName *string `json:"smartContractName"`
	// Smart contract signature
	SmartContractSignature *string `json:"smartContractSignature"`
	// Signature Hash
	SmartContractSignatureHash *string `json:"smartContractSignatureHash"`
}

// Cardano
type Cardano struct {
	// Information about address
	Address []*CardanoAddressInfo `json:"address"`
	// Blockchain Blocks
	Blocks []*CardanoBlock `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*CardanoCoinpath `json:"coinpath"`
	// Blockchain Transaction Inputs
	Inputs []*CardanoTransactionInput `json:"inputs"`
	// Blockchain Tokens Mints
	Mints []*CardanoTransactionMint `json:"mints"`
	// Blockchain Transaction Outputs
	Outputs []*CardanoTransactionOutput `json:"outputs"`
	// Blockchain Transactions
	Transactions []*CardanoTransaction `json:"transactions"`
}

// Address balance information for Cardano network
type CardanoAddressBalance struct {
	// Currency
	Currency *Currency `json:"currency"`
	// Currency value
	Value *float64 `json:"value"`
}

// Address detailed information for Cardano network
type CardanoAddressInfo struct {
	// Address
	Address *Address `json:"address"`
	// Current address balances
	Balance []*CardanoAddressBalance `json:"balance"`
	// Current staking addressese info
	Staking []*CardanoStakingAddress `json:"staking"`
}

// Block
type CardanoBlock struct {
	Any *string `json:"any"`
	// Block Hash
	BlockHash *string `json:"blockHash"`
	// Block size
	BlockSize *int `json:"blockSize"`
	// Block version
	BlockVersion *int    `json:"blockVersion"`
	Count        *int    `json:"count"`
	CountBigInt  *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Epoch number
	Epoch *int `json:"epoch"`
	// Block number (height) in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Op cert
	OpCert *string `json:"opCert"`
	// Slot number
	Slot *int `json:"slot"`
	// Slot in epoch number
	SlotInEpoch *int `json:"slotInEpoch"`
	// Slot leader description
	SlotLeaderDescription *string `json:"slotLeaderDescription"`
	// Slot leader hash
	SlotLeaderHash *string `json:"slotLeaderHash"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Transaction count in block
	TransactionCount *int `json:"transactionCount"`
	// VRF Key
	VrfKey *string `json:"vrfKey"`
}

type CardanoBlockFilter struct {
	Date             *DateSelector     `json:"date"`
	Time             *DateTimeSelector `json:"time"`
	Height           *BlockSelector    `json:"height"`
	BlockHash        *StringIDSelector `json:"blockHash"`
	BlockSize        *IntegerSelector  `json:"blockSize"`
	BlockVersion     *IntegerSelector  `json:"blockVersion"`
	TransactionCount *IntegerSelector  `json:"transactionCount"`
	Epoch            *IntegerSelector  `json:"epoch"`
	Slot             *IntegerSelector  `json:"slot"`
	SlotInEpoch      *IntegerSelector  `json:"slotInEpoch"`
	OpCert           *StringSelector   `json:"opCert"`
	SlotLeaderHash   *StringSelector   `json:"slotLeaderHash"`
	VrfKey           *StringSelector   `json:"vrfKey"`
	Version          *StringSelector   `json:"version"`
}

// Coinpath
type CardanoCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
	// Transaction of transfer happened
	Transaction *CardanoTransactionHashIndexValues `json:"transaction"`
	// Attributes of transaction included in Coinpath result
	Transactions []*CoinpathEntry `json:"transactions"`
}

// Limits, Ordering, Constraints, Coinpath Options
type CardanoCoinpathOptions struct {
	// Limit number of results
	Limit *int `json:"limit"`
	// Limit number of results by specific field
	LimitBy *LimitByOption `json:"limitBy"`
	// Offset of results, starting from 0
	Offset *int `json:"offset"`
	// Ordering field(s) for ascending
	Asc []string `json:"asc"`
	// Ordering field(s) for descending
	Desc []string `json:"desc"`
	// Flow direction
	Direction *FlowDirection `json:"direction"`
	// Do not include transactions below this amount
	MinimumTxAmount *float64 `json:"minimumTxAmount"`
	// Do not expand addresses having count transactions more than this
	MaximumAddressTxCount *int `json:"maximumAddressTxCount"`
	// Maximum total transaction count returned
	MaximumTotalTxCount *int `json:"maximumTotalTxCount"`
	// Raise error if complexity ( currently measured in transaction count ) is higher than this option
	ComplexityLimit *int `json:"complexityLimit"`
	// Invalidating cache seed
	Seed *int `json:"seed"`
	// Method to use coinpath
	CoinpathMethod *CardanoCoinpathMethod `json:"coinpathMethod"`
}

// Cardano token selector by tokenId.
//     Native binance token has ADA symbol, pass it as argument.
//     Otherwise pass asset fingerprint, starting from asset...
type CardanoCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

type CardanoInputFilter struct {
	Date          *DateSelector              `json:"date"`
	Time          *DateTimeSelector          `json:"time"`
	Height        *BlockSelector             `json:"height"`
	TxHash        *HashSelector              `json:"txHash"`
	TxIndex       *IntegerSelector           `json:"txIndex"`
	InputIndex    *IntegerSelector           `json:"inputIndex"`
	InputAddress  *AddressSelector           `json:"inputAddress"`
	InOutputTxID  *HashSelector              `json:"inOutputTxId"`
	InOutputIndex *IntegerSelector           `json:"inOutputIndex"`
	InputValue    *FloatSelector             `json:"inputValue"`
	Currency      []*CardanoCurrencySelector `json:"currency"`
}

type CardanoMintFilter struct {
	Date     *DateSelector              `json:"date"`
	Time     *DateTimeSelector          `json:"time"`
	Height   *BlockSelector             `json:"height"`
	TxHash   *HashSelector              `json:"txHash"`
	TxIndex  *IntegerSelector           `json:"txIndex"`
	Value    *FloatSelector             `json:"value"`
	Currency []*CardanoCurrencySelector `json:"currency"`
}

// A guessed direction of output
type CardanoOutputDirectionSelector struct {
	// Equal to direction
	Is *CardanoOutputDirection `json:"is"`
	// Not Equal to direction
	Not *CardanoOutputDirection `json:"not"`
	// In the list of direction
	In []CardanoOutputDirection `json:"in"`
	// Not in the list of direction
	NotIn []CardanoOutputDirection `json:"notIn"`
}

type CardanoOutputFilter struct {
	Date            *DateSelector                   `json:"date"`
	Time            *DateTimeSelector               `json:"time"`
	Height          *BlockSelector                  `json:"height"`
	TxHash          *HashSelector                   `json:"txHash"`
	TxIndex         *IntegerSelector                `json:"txIndex"`
	OutputIndex     *IntegerSelector                `json:"outputIndex"`
	OutputAddress   *AddressSelector                `json:"outputAddress"`
	OutputDirection *CardanoOutputDirectionSelector `json:"outputDirection"`
	OutputValue     *FloatSelector                  `json:"outputValue"`
	Currency        []*CardanoCurrencySelector      `json:"currency"`
}

// Address staking information for Cardano network
type CardanoStakingAddress struct {
	// Staking Address
	Address *Address `json:"address"`
	// Rewards value
	RewardsAmount *float64 `json:"rewardsAmount"`
	// Staked value
	StakedAmount *float64 `json:"stakedAmount"`
	// Staked value including rewards
	StakedAmountWithRewards *float64 `json:"stakedAmountWithRewards"`
	// Withdrawn value
	WithdrawnAmount *float64 `json:"withdrawnAmount"`
}

// Transaction
type CardanoTransaction struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Transaction  count
	Count *int `json:"count"`
	// Transaction  count
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Transaction total deposit value
	DepositValue *float64 `json:"depositValue"`
	// Transaction total fee value
	DepositValueDecimal *string `json:"depositValueDecimal"`
	// Transaction total fee value
	FeeValue *float64 `json:"feeValue"`
	// Transaction total fee value
	FeeValueDecimal *string `json:"feeValueDecimal"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Included at timestamp
	IncludedAt *DateTime `json:"includedAt"`
	// Transaction index in block, 0-based
	Index string `json:"index"`
	// Transaction total input count
	InputCount *int `json:"inputCount"`
	// Transaction total input count
	InputCountBigInt *string `json:"inputCountBigInt"`
	// Transaction total input value
	InputValue *float64 `json:"inputValue"`
	// Transaction total input value as decimal
	InputValueDecimal *string `json:"inputValueDecimal"`
	// Invalid before
	InvalidBefore *string `json:"invalidBefore"`
	// Invalid hereafter
	InvalidHereafter *string `json:"invalidHereafter"`
	Maximum          *string `json:"maximum"`
	// Metadata
	Metadata *string `json:"metadata"`
	Minimum  *string `json:"minimum"`
	// Transaction total mint count
	MintCount *int `json:"mintCount"`
	// Transaction total mint count
	MintCountBigInt *string `json:"mintCountBigInt"`
	// Transaction total output count
	OutputCount *int `json:"outputCount"`
	// Transaction total output count
	OutputCountBigInt *string `json:"outputCountBigInt"`
	// Transaction total output value
	OutputValue *float64 `json:"outputValue"`
	// Transaction total output value
	OutputValueDecimal *string `json:"outputValueDecimal"`
	// Transaction size
	TxSize *int `json:"txSize"`
	// Transaction total withdrawal count
	WithdrawalCount *int `json:"withdrawalCount"`
	// Transaction total withdrawal count
	WithdrawalCountBigInt *string `json:"withdrawalCountBigInt"`
	// Transaction total withdrawal value
	WithdrawalValue *float64 `json:"withdrawalValue"`
	// Transaction total fee value
	WithdrawalValueDecimal *string `json:"withdrawalValueDecimal"`
}

type CardanoTransactionFilter struct {
	Date            *DateSelector      `json:"date"`
	Time            *DateTimeSelector  `json:"time"`
	Height          *BlockSelector     `json:"height"`
	TxHash          *HashSelector      `json:"txHash"`
	TxIndex         *IntegerSelector   `json:"txIndex"`
	TxSize          *IntegerSelector   `json:"txSize"`
	InputCount      *IntegerSelector   `json:"inputCount"`
	OutputCount     *IntegerSelector   `json:"outputCount"`
	InputValue      *FloatSelector     `json:"inputValue"`
	OutputValue     *FloatSelector     `json:"outputValue"`
	FeeValue        *FloatSelector     `json:"feeValue"`
	WithdrawalCount *IntegerSelector   `json:"withdrawalCount"`
	MintCount       *IntegerSelector   `json:"mintCount"`
	WithdrawalValue *FloatSelector     `json:"withdrawalValue"`
	DepositValue    *FloatSelector     `json:"depositValue"`
	OutputAddress   *AddressSelectorIn `json:"outputAddress"`
	InputAddress    *AddressSelectorIn `json:"inputAddress"`
}

// Blockchain transaction
type CardanoTransactionHashIndexValues struct {
	DepositValue float64 `json:"depositValue"`
	// Transaction deposit value as decimal
	DepositValueDecimal string  `json:"depositValueDecimal"`
	FeeValue            float64 `json:"feeValue"`
	// Transaction fee value as decimal
	FeeValueDecimal string `json:"feeValueDecimal"`
	// Hash hex representation
	Hash       string    `json:"hash"`
	IncludedAt *DateTime `json:"includedAt"`
	// Transaction index in block, 0-based
	Index            string `json:"index"`
	InvalidBefore    string `json:"invalidBefore"`
	InvalidHereafter string `json:"invalidHereafter"`
	Metadata         string `json:"metadata"`
	TxSize           int    `json:"txSize"`
	// Transaction value in input
	ValueIn float64 `json:"valueIn"`
	// Transaction value in input as decimal
	ValueInDecimal string `json:"valueInDecimal"`
	// Transaction value in output
	ValueOut float64 `json:"valueOut"`
	// Transaction value in output as decimal
	ValueOutDecimal string  `json:"valueOutDecimal"`
	WithdrawalValue float64 `json:"withdrawalValue"`
	// Transaction withdraw value as decimal
	WithdrawalValueDecimal string `json:"withdrawalValueDecimal"`
}

// Transaction Input
type CardanoTransactionInput struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Input count
	Count *int `json:"count"`
	// Input count
	CountBigInt *string `json:"countBigInt"`
	// Currency of the input
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Input address
	InputAddress *Address `json:"inputAddress"`
	// Input index
	InputIndex *int    `json:"inputIndex"`
	Maximum    *string `json:"maximum"`
	Minimum    *string `json:"minimum"`
	// Output Transaction for this input
	OutputTransaction *TransactionHashIndex `json:"outputTransaction"`
	// Source of the input
	Source *CardanoInputSource `json:"source"`
	// Transaction ID Hash
	Transaction *TransactionHashIndex `json:"transaction"`
	// Input value
	Value *float64 `json:"value"`
	// Input value as decimal
	ValueDecimal *string `json:"valueDecimal"`
}

// Transaction Mint
type CardanoTransactionMint struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Mint count
	Count *int `json:"count"`
	// Mint count
	CountBigInt *string `json:"countBigInt"`
	// Currency of the mint
	Currency *Currency `json:"currency"`
	// Calendar date
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Transaction ID Hash
	Transaction *TransactionHashIndex `json:"transaction"`
	// Mint value
	Value *float64 `json:"value"`
}

// Transaction Output
type CardanoTransactionOutput struct {
	Any *string `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Output count
	Count *int `json:"count"`
	// Output count
	CountBigInt *string `json:"countBigInt"`
	// Currency of the output
	Currency *Currency `json:"currency"`
	// Calendar date
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Output address
	OutputAddress *Address `json:"outputAddress"`
	// Output guessed direction
	OutputDirection *CardanoOutputDirection `json:"outputDirection"`
	// Output index
	OutputIndex *int `json:"outputIndex"`
	// Transaction ID Hash
	Transaction *TransactionHashIndex `json:"transaction"`
	// Output value
	Value *float64 `json:"value"`
	// Input value as decimal
	ValueDecimal *string `json:"valueDecimal"`
}

// Transaction attributes in coinpath
type CoinpathEntry struct {
	// Amount involved in the flow
	Amount float64 `json:"amount"`
	// Block of transaction
	Height int `json:"height"`
	// Time of transaction in ISO 8601 format
	Timestamp string `json:"timestamp"`
	// Hash of transaction
	TxHash string `json:"txHash"`
	// Amount transfered in transaction
	TxValue float64 `json:"txValue"`
}

// Limits, Ordering, Constraints, Coinpath Options
type CoinpathOptions struct {
	// Limit number of results
	Limit *int `json:"limit"`
	// Limit number of results by specific field
	LimitBy *LimitByOption `json:"limitBy"`
	// Offset of results, starting from 0
	Offset *int `json:"offset"`
	// Ordering field(s) for ascending
	Asc []string `json:"asc"`
	// Ordering field(s) for descending
	Desc []string `json:"desc"`
	// Flow direction
	Direction *FlowDirection `json:"direction"`
	// Do not include transactions below this amount
	MinimumTxAmount *float64 `json:"minimumTxAmount"`
	// Do not expand addresses having count transactions more than this
	MaximumAddressTxCount *int `json:"maximumAddressTxCount"`
	// Maximum total transaction count returned
	MaximumTotalTxCount *int `json:"maximumTotalTxCount"`
	// Raise error if complexity ( currently measured in transaction count ) is higher than this option
	ComplexityLimit *int `json:"complexityLimit"`
	// Invalidating cache seed
	Seed *int `json:"seed"`
}

// Conflux Chain
type Conflux struct {
	// Basic information about address ( or smart contract )
	Address []*EthereumAddressInfoWithBalance `json:"address"`
	// Arguments of Smart Contract Calls and Events
	Arguments []*EthereumArguments `json:"arguments"`
	// Blockchain Blocks
	Blocks []*ConfluxBlocks `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*EthereumCoinpath `json:"coinpath"`
	// Trades on Ethereum DEX Smart Contracts
	DexTrades []*EthereumDexTrades `json:"dexTrades"`
	// Smart Contract Calls
	SmartContractCalls []*EthereumSmartContractCalls `json:"smartContractCalls"`
	// Smart Contract Events
	SmartContractEvents []*EthereumSmartContractEvent `json:"smartContractEvents"`
	// Blockchain Transactions
	Transactions []*ConfluxTransactions `json:"transactions"`
	// Currency Transfers
	Transfers []*EthereumTransfers `json:"transfers"`
}

type ConfluxBlockFilter struct {
	Date               *DateSelector              `json:"date"`
	Time               *DateTimeSelector          `json:"time"`
	Height             *BlockSelector             `json:"height"`
	Epoch              *BlockSelector             `json:"epoch"`
	Pivot              *bool                      `json:"pivot"`
	BlockHash          *HashSelector              `json:"blockHash"`
	ReferenceBlockHash *HashSelector              `json:"referenceBlockHash"`
	Miner              []*EthereumAddressSelector `json:"miner"`
	RefereeCount       []*IntegerSelector         `json:"refereeCount"`
	TransactionCount   []*IntegerSelector         `json:"transactionCount"`
	UncleCount         []*IntegerSelector         `json:"uncleCount"`
	Size               []*IntegerSelector         `json:"size"`
}

// Blocks in Conflux blockchain
type ConfluxBlocks struct {
	// Block is adaptive
	Adaptive bool    `json:"adaptive"`
	Any      *string `json:"any"`
	// Blame
	Blame int `json:"blame"`
	// Block index in epoch
	BlockPosition int     `json:"blockPosition"`
	Count         *int    `json:"count"`
	CountBigInt   *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Epoch in blockchain
	Epoch int `json:"epoch"`
	// Block hash
	Hash string `json:"hash"`
	// Block height in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	// Block miner
	Miner   *EthereumAddressInfo `json:"miner"`
	Minimum *string              `json:"minimum"`
	// Block nonce
	Nonce int `json:"nonce"`
	// Parent block hash
	ParentHash string `json:"parentHash"`
	// Block is pivot
	Pivot bool `json:"pivot"`
	// Power Quality
	PowerQuality       string  `json:"powerQuality"`
	RefereeCount       *int    `json:"refereeCount"`
	RefereeCountBigInt *string `json:"refereeCountBigInt"`
	// Reference Block hash
	ReferenceBlockHash string `json:"referenceBlockHash"`
	Size               *int   `json:"size"`
	// Block timestamp
	Timestamp              *DateTime `json:"timestamp"`
	TotalDifficulty        *float64  `json:"totalDifficulty"`
	TransactionCount       *int      `json:"transactionCount"`
	TransactionCountBigInt *string   `json:"transactionCountBigInt"`
	// Hash of Transaction included in block
	TxHash           string  `json:"txHash"`
	UncleCount       *int    `json:"uncleCount"`
	UncleCountBigInt *string `json:"uncleCountBigInt"`
}

type ConfluxTransactionFilter struct {
	Date        *DateSelector               `json:"date"`
	Time        *DateTimeSelector           `json:"time"`
	Height      *BlockSelector              `json:"height"`
	TxHash      *HashSelector               `json:"txHash"`
	TxSender    []*EthereumAddressSelector  `json:"txSender"`
	TxTo        []*EthereumAddressSelector  `json:"txTo"`
	TxCreates   []*EthereumAddressSelector  `json:"txCreates"`
	TxIndex     *TxIndexSelector            `json:"txIndex"`
	Success     *bool                       `json:"success"`
	Amount      []*AmountSelector           `json:"amount"`
	GasCurrency []*EthereumCurrencySelector `json:"gasCurrency"`
	BlockHash   *HashSelector               `json:"blockHash"`
}

// Transactions in Conflux blockchain
type ConfluxTransactions struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *BlockInfo `json:"block"`
	Count       *int       `json:"count"`
	CountBigInt *string    `json:"countBigInt"`
	// Created smart contract
	Creates *EthereumAddressInfo `json:"creates"`
	// Currency of amount
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Error message if any
	Error *string `json:"error"`
	Gas   *int    `json:"gas"`
	// Currency of gas
	GasCurrency *Currency `json:"gasCurrency"`
	// Gas price in Gwei
	GasPrice float64  `json:"gasPrice"`
	GasValue *float64 `json:"gasValue"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0 based
	Index   *int    `json:"index"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Transaction nonce
	Nonce *int `json:"nonce"`
	// Transaction sender
	Sender *EthereumAddressInfo `json:"sender"`
	// Success
	Success *bool `json:"success"`
	// Transaction receiver
	To *EthereumAddressInfo `json:"to"`
}

// Continent selector
type ContinentSelector struct {
	// Country code is
	Is *Continent `json:"is"`
	// Country code not
	Not *Continent `json:"not"`
	// Country code in the list
	In []Continent `json:"in"`
	// Country code not in the list
	NotIn []Continent `json:"notIn"`
}

// Country selector by 3 digit ISO code
type CountrySelector struct {
	// Country code is
	Is *CountryCode `json:"is"`
	// Country code not
	Not *CountryCode `json:"not"`
	// Country code in the list
	In []CountryCode `json:"in"`
	// Country code not in the list
	NotIn []CountryCode `json:"notIn"`
}

// Country
type CovidCountry struct {
	// Area, km2
	AreaKm2 *float64 `json:"areaKm2"`
	// Continent name
	Continent *Continent `json:"continent"`
	// Gross Domestic Product
	Gdp *float64 `json:"gdp"`
	// ISO 2 letter code
	Iso2 *CountryCode `json:"iso2"`
	// ISO 3 letter code
	Iso3 *string `json:"iso3"`
	// ISO numeric code
	IsoNumeric *int `json:"isoNumeric"`
	// Location latitude
	Latitude *float64 `json:"latitude"`
	// Location longitude
	Longitude *float64 `json:"longitude"`
	// Country name
	Name *string `json:"name"`
	// Population density in thousands per km2
	PopulationPerKm2 *float64 `json:"populationPerKm2"`
	// Population total in thousands
	PopulationTotal *float64 `json:"populationTotal"`
}

// Facts of Covid virus development
type CovidFact struct {
	// Count of confirmed cases
	Confirmed *int `json:"confirmed"`
	// Country
	Country *CovidCountry `json:"country"`
	// Calendar date
	Date *Date `json:"date"`
	// Count of death cases
	Deaths *int `json:"deaths"`
	// Location
	Location *CovidLocation `json:"location"`
	// Count of recovered cases
	Recovered *int `json:"recovered"`
}

// Covid History
type CovidHistory struct {
	// COVID daily facts
	Facts []*CovidFact `json:"facts"`
}

// Geo Location
type CovidLocation struct {
	// Admin center name
	AdminCenter *string `json:"adminCenter"`
	// FIPS code for USA
	FipsCode *int `json:"fipsCode"`
	// Location latitude
	Latitude *float64 `json:"latitude"`
	// Location longitude
	Longitude *float64 `json:"longitude"`
	// Location Country name
	Name *string `json:"name"`
	// Location Province / State name
	Province *string `json:"province"`
}

// Crypto currency ( token, coin, currency )
type Currency struct {
	// Token Smart Contract Address
	Address *string `json:"address"`
	// Decimals
	Decimals int `json:"decimals"`
	// Currency name
	Name *string `json:"name"`
	// Currency symbol
	Symbol string `json:"symbol"`
	// Token ID
	TokenID *string `json:"tokenId"`
	// Token Type
	TokenType *string `json:"tokenType"`
}

func (Currency) IsSubject() {}

// Currency selector
type CurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

// Instruction Data
type Data struct {
	Base58 string `json:"base58"`
	Hex    string `json:"hex"`
}

// Date
type Date struct {
	// String date representation with default format as YYYY-MM-DD
	Date string `json:"date"`
	// Day of month (1-31)
	DayOfMonth int `json:"dayOfMonth"`
	// Day of week  (Monday is 1, and Sunday is 7)
	DayOfWeek int `json:"dayOfWeek"`
	// Month number (1-12)
	Month int `json:"month"`
	// Returns start of date interval ,
	//     date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
	//   starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
	StartOfInterval string `json:"startOfInterval"`
	// Year number
	Year int `json:"year"`
}

// Selecting the date in a range, list or just date
type DateSelector struct {
	// Since date
	Since *string `json:"since"`
	// Till date
	Till *string `json:"till"`
	// Range of dates
	Between []string `json:"between"`
	// Before date
	Before *string `json:"before"`
	// After date
	After *string `json:"after"`
	// In dates
	In []string `json:"in"`
	// Not in dates
	NotIn []string `json:"notIn"`
	// Date equals
	Is *string `json:"is"`
	// Date not equals
	Not *string `json:"not"`
}

// Date and Time
type DateTime struct {
	// Day of month (1-31)
	DayOfMonth int `json:"dayOfMonth"`
	// Day of week  (Monday is 1, and Sunday is 7)
	DayOfWeek int `json:"dayOfWeek"`
	// Hour (0-23)
	Hour int `json:"hour"`
	// ISO8601 date time such as '2020-03-02T13:30:41+00:00'
	Iso8601 string `json:"iso8601"`
	// Minute (0-59)
	Minute int `json:"minute"`
	// Month number (1-12)
	Month int `json:"month"`
	// Second (0-59)
	Second int `json:"second"`
	// String date representation with default format as YYYY-MM-DD
	Time string `json:"time"`
	// Unix timestamp
	Unixtime int `json:"unixtime"`
	// Year number
	Year int `json:"year"`
}

// Selecting the time in a range, list or just time
type DateTimeSelector struct {
	// Since time
	Since *string `json:"since"`
	// Till time
	Till *string `json:"till"`
	// Range of time
	Between []string `json:"between"`
	// Before time
	Before *string `json:"before"`
	// After time
	After *string `json:"after"`
	// In times
	In []string `json:"in"`
	// Not in times
	NotIn []string `json:"notIn"`
	// Time equals
	Is *string `json:"is"`
	// Time not equals
	Not *string `json:"not"`
}

// Elrond Chain
type Elrond struct {
	// Arguments of Smart Contract Calls and Events
	Arguments []*ElrondArgument `json:"arguments"`
	// Information about validators of the block
	BlockValidators []*ElrondBlockValidator `json:"blockValidators"`
	// Information about blocks
	Blocks []*ElrondBlock `json:"blocks"`
	// Information about calls
	CallResults []*ElrondCallResult `json:"callResults"`
	// Information about calls
	Calls []*ElrondCall `json:"calls"`
	// Money flow using Coinpath technology
	Coinpath []*ElrondCoinpath `json:"coinpath"`
	// Information about miniblocks
	Miniblocks []*ElrondMiniblock `json:"miniblocks"`
	// Information about notarized block
	NotarizedBlock []*ElrondNotarizedBlock `json:"notarizedBlock"`
	// Information about transactions
	Transactions []*ElrondTransaction `json:"transactions"`
	// Information about transactions
	Transfers []*ElrondTransfer `json:"transfers"`
}

// Blockchain address hash
type ElrondAddressHash struct {
	// String hex address representation
	Hex string `json:"hex"`
}

// Arguments of Smart Contract Calls and Events
type ElrondArgument struct {
	Any *string `json:"any"`
	// Information about arguments call
	Call        *CallElrond `json:"call"`
	Count       *int        `json:"count"`
	CountBigInt *string     `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Index of the argument
	Index   *int    `json:"index"`
	Maximum *string `json:"maximum"`
	// Information about arguments miniblock
	Miniblock *MiniblockElrond `json:"miniblock"`
	Minimum   *string          `json:"minimum"`
	// Information about arguments block
	SenderBlock *ElrondBlockDimension `json:"senderBlock"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Information about arguments transaction
	Transaction *TransactionElrond `json:"transaction"`
	// Value of the argument
	Value *string `json:"value"`
}

type ElrondArgumentFilter struct {
	Date                       *DateSelector     `json:"date"`
	Time                       *DateTimeSelector `json:"time"`
	Height                     *BlockSelector    `json:"height"`
	PreviousBlockHash          *HashSelector     `json:"previousBlockHash"`
	BlockHash                  *HashSelector     `json:"blockHash"`
	Shard                      *BigIntIDSelector `json:"shard"`
	Proposer                   *HashSelector     `json:"proposer"`
	Epoch                      *IntegerSelector  `json:"epoch"`
	BlockNonce                 *IntegerSelector  `json:"blockNonce"`
	Round                      *IntegerSelector  `json:"round"`
	Size                       *IntegerSelector  `json:"size"`
	SizeTxs                    *IntegerSelector  `json:"sizeTxs"`
	PublicKeyBitmap            *StringSelector   `json:"publicKeyBitmap"`
	StateRootHash              *HashSelector     `json:"stateRootHash"`
	TransactionCount           *IntegerSelector  `json:"transactionCount"`
	MiniblockHash              *HashSelector     `json:"miniblockHash"`
	MiniblockReceiverBlockHash *HashSelector     `json:"miniblockReceiverBlockHash"`
	MiniblockReceiverShard     *BigIntIDSelector `json:"miniblockReceiverShard"`
	Type                       *StringSelector   `json:"type"`
	TxHash                     *HashSelector     `json:"txHash"`
	Index                      *IntegerSelector  `json:"index"`
	Nonce                      *IntegerSelector  `json:"nonce"`
	TxReceiver                 *HashSelector     `json:"txReceiver"`
	TxReceiverShard            *BigIntIDSelector `json:"txReceiverShard"`
	TxSender                   *HashSelector     `json:"txSender"`
	TxSenderShard              *BigIntIDSelector `json:"txSenderShard"`
	Signature                  *HashSelector     `json:"signature"`
	Status                     *StringSelector   `json:"status"`
	Data                       *StringSelector   `json:"data"`
	DataOperation              *StringSelector   `json:"dataOperation"`
	SmartContractAddress       *HashSelector     `json:"smartContractAddress"`
	CallDepth                  *IntegerSelector  `json:"callDepth"`
	ArgumentIndex              *IntegerSelector  `json:"argumentIndex"`
	ArgumentValue              *IntIDSelector    `json:"argumentValue"`
}

// Blocks in Elrond  blockchain
type ElrondBlock struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Epoch
	Epoch *int `json:"epoch"`
	// Hash of the the block
	Hash *string `json:"hash"`
	// Number of block in the blockchains
	Height  *string `json:"height"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Block Height
	Nonce *string `json:"nonce"`
	// The block hash of this block`s parent
	PreviousBlockHash *string `json:"previousBlockHash"`
	// Proposer block hash
	Proposer *ElrondAddressHash `json:"proposer"`
	// Public Key Bitmap
	PublicKeyBitmap *string `json:"publicKeyBitmap"`
	// Round
	Round *string `json:"round"`
	// Shard number of block
	Shard *string `json:"shard"`
	// Size
	Size *int `json:"size"`
	// Size Tx
	SizeTxs *int `json:"sizeTxs"`
	// State root hash
	StateRootHash *string `json:"stateRootHash"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Count of transactions in this block
	TransactionCount *string `json:"transactionCount"`
}

// Information about block
type ElrondBlockDimension struct {
	// Epoch
	Epoch *int `json:"epoch"`
	// Hash of the block
	Hash *string `json:"hash"`
	// Number of block in the blockchains
	Height *string `json:"height"`
	// Block Height
	Nonce *string `json:"nonce"`
	// The block hash of this block`s parent
	PreviousBlockHash *string `json:"previousBlockHash"`
	// Proposer block hash
	Proposer *ElrondAddressHash `json:"proposer"`
	// Public Key Bitmap
	PublicKeyBitmap *string `json:"publicKeyBitmap"`
	// Round
	Round *string `json:"round"`
	// Shard number of block
	Shard *string `json:"shard"`
	// Size
	Size *int `json:"size"`
	// Size Tx
	SizeTxs *int `json:"sizeTxs"`
	// State root hash
	StateRootHash *string `json:"stateRootHash"`
	// Count of transactions in this block
	TransactionCount *string `json:"transactionCount"`
}

type ElrondBlockFilter struct {
	Date              *DateSelector     `json:"date"`
	Time              *DateTimeSelector `json:"time"`
	Hash              *HashSelector     `json:"hash"`
	Height            *BlockSelector    `json:"height"`
	PreviousBlockHash *HashSelector     `json:"previousBlockHash"`
	Shard             *BigIntIDSelector `json:"shard"`
	Proposer          *HashSelector     `json:"proposer"`
	Epoch             *IntegerSelector  `json:"epoch"`
	Nonce             *IntegerSelector  `json:"nonce"`
	Round             *IntegerSelector  `json:"round"`
	PublicKeyBitmap   *StringSelector   `json:"publicKeyBitmap"`
	Size              *IntegerSelector  `json:"size"`
	SizeTxs           *IntegerSelector  `json:"sizeTxs"`
	StateRootHash     *IntegerSelector  `json:"stateRootHash"`
	TransactionCount  *IntegerSelector  `json:"transactionCount"`
}

// BlockValidators in Elrond  blockchain
type ElrondBlockValidator struct {
	Any *string `json:"any"`
	// Information about blocks notarized block
	Block       *ElrondBlockDimension `json:"block"`
	Count       *int                  `json:"count"`
	CountBigInt *string               `json:"countBigInt"`
	// The date this transaction was created
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Hash of validator
	Validator *ElrondAddressHash `json:"validator"`
}

type ElrondBlockValidatorFilter struct {
	Date              *DateSelector     `json:"date"`
	Time              *DateTimeSelector `json:"time"`
	Height            *BlockSelector    `json:"height"`
	PreviousBlockHash *HashSelector     `json:"previousBlockHash"`
	BlockHash         *HashSelector     `json:"blockHash"`
	Shard             *BigIntIDSelector `json:"shard"`
	Proposer          *HashSelector     `json:"proposer"`
	Epoch             *IntegerSelector  `json:"epoch"`
	BlockNonce        *IntegerSelector  `json:"blockNonce"`
	Round             *IntegerSelector  `json:"round"`
	Size              *IntegerSelector  `json:"size"`
	SizeTxs           *IntegerSelector  `json:"sizeTxs"`
	PublicKeyBitmap   *StringSelector   `json:"publicKeyBitmap"`
	StateRootHash     *HashSelector     `json:"stateRootHash"`
	TransactionCount  *IntegerSelector  `json:"transactionCount"`
	Validator         *HashSelector     `json:"validator"`
}

// Calls in Elrond blockchain
type ElrondCall struct {
	Any *string `json:"any"`
	// Depth of the call. Empty string for external call, then counted
	//         as 0...N, and the next layer is added through '-'. For example 0-3-9.
	CallDepth   *string `json:"callDepth"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	// Information about calls miniblock
	Miniblock *MiniblockElrond `json:"miniblock"`
	Minimum   *string          `json:"minimum"`
	// Information about calls block
	SenderBlock *ElrondBlockDimension `json:"senderBlock"`
	// Contract method invoked
	SmartContractAddress *Address `json:"smartContractAddress"`
	// Contract method invoked
	SmartContractMethod *Method `json:"smartContractMethod"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Information about calls transaction
	Transaction *TransactionElrond `json:"transaction"`
}

type ElrondCallFilter struct {
	Date                       *DateSelector     `json:"date"`
	Time                       *DateTimeSelector `json:"time"`
	Height                     *BlockSelector    `json:"height"`
	PreviousBlockHash          *HashSelector     `json:"previousBlockHash"`
	BlockHash                  *HashSelector     `json:"blockHash"`
	Shard                      *BigIntIDSelector `json:"shard"`
	Proposer                   *HashSelector     `json:"proposer"`
	Epoch                      *IntegerSelector  `json:"epoch"`
	BlockNonce                 *IntegerSelector  `json:"blockNonce"`
	Round                      *IntegerSelector  `json:"round"`
	Size                       *IntegerSelector  `json:"size"`
	SizeTxs                    *IntegerSelector  `json:"sizeTxs"`
	PublicKeyBitmap            *StringSelector   `json:"publicKeyBitmap"`
	StateRootHash              *HashSelector     `json:"stateRootHash"`
	TransactionCount           *IntegerSelector  `json:"transactionCount"`
	MiniblockHash              *HashSelector     `json:"miniblockHash"`
	MiniblockReceiverBlockHash *HashSelector     `json:"miniblockReceiverBlockHash"`
	MiniblockReceiverShard     *BigIntIDSelector `json:"miniblockReceiverShard"`
	Type                       *StringSelector   `json:"type"`
	TxHash                     *HashSelector     `json:"txHash"`
	Index                      *IntegerSelector  `json:"index"`
	Nonce                      *IntegerSelector  `json:"nonce"`
	TxReceiver                 *HashSelector     `json:"txReceiver"`
	TxReceiverShard            *BigIntIDSelector `json:"txReceiverShard"`
	TxSender                   *HashSelector     `json:"txSender"`
	TxSenderShard              *BigIntIDSelector `json:"txSenderShard"`
	Signature                  *HashSelector     `json:"signature"`
	Status                     *StringSelector   `json:"status"`
	Data                       *StringSelector   `json:"data"`
	DataOperation              *StringSelector   `json:"dataOperation"`
	SmartContractAddress       *HashSelector     `json:"smartContractAddress"`
	SmartContractMethod        *MethodSelector   `json:"smartContractMethod"`
	CallDepth                  *StringSelector   `json:"callDepth"`
}

// CallResults in Elrond blockchain
type ElrondCallResult struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Call result data
	Data *string `json:"data"`
	// Call result data operation
	DataOperation *string `json:"dataOperation"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Call result gas limit
	GasLimit *string `json:"gasLimit"`
	// Call result gas price
	GasPrice *string `json:"gasPrice"`
	// Hash of the call result
	Hash *string `json:"hash"`
	// Call result index
	Index   *int    `json:"index"`
	Maximum *string `json:"maximum"`
	// Information about calls miniblock
	Miniblock *MiniblockElrond `json:"miniblock"`
	Minimum   *string          `json:"minimum"`
	// Nonce of the call result
	Nonce *string `json:"nonce"`
	// Hash of the origin transaction
	OriginTxHash *string `json:"originTxHash"`
	// Hash of the previous transaction
	PreviousTxHash *string `json:"previousTxHash"`
	// Call result receiver
	Receiver *Address `json:"receiver"`
	// Call result relayed
	Relayed      *string  `json:"relayed"`
	RelayedValue *float64 `json:"relayedValue"`
	// Call result return message
	ReturnMessage *string `json:"returnMessage"`
	// Call result sender
	Sender *Address `json:"sender"`
	// Information about calls block
	SenderBlock *ElrondBlockDimension `json:"senderBlock"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Information about calls transaction
	Transaction *TransactionElrond `json:"transaction"`
	// Call result type
	Type  *string  `json:"type"`
	Value *float64 `json:"value"`
}

type ElrondCallResultFilter struct {
	Date                       *DateSelector     `json:"date"`
	Time                       *DateTimeSelector `json:"time"`
	Height                     *BlockSelector    `json:"height"`
	BlockHash                  *HashSelector     `json:"blockHash"`
	PreviousBlockHash          *HashSelector     `json:"previousBlockHash"`
	Shard                      *BigIntIDSelector `json:"shard"`
	Proposer                   *HashSelector     `json:"proposer"`
	Epoch                      *IntegerSelector  `json:"epoch"`
	BlockNonce                 *IntegerSelector  `json:"blockNonce"`
	Round                      *IntegerSelector  `json:"round"`
	Size                       *IntegerSelector  `json:"size"`
	SizeTxs                    *IntegerSelector  `json:"sizeTxs"`
	PublicKeyBitmap            *StringSelector   `json:"publicKeyBitmap"`
	StateRootHash              *HashSelector     `json:"stateRootHash"`
	TransactionCount           *IntegerSelector  `json:"transactionCount"`
	MiniblockHash              *HashSelector     `json:"miniblockHash"`
	MiniblockReceiverBlockHash *HashSelector     `json:"miniblockReceiverBlockHash"`
	MiniblockReceiverShard     *BigIntIDSelector `json:"miniblockReceiverShard"`
	Type                       *StringSelector   `json:"type"`
	TxHash                     *HashSelector     `json:"txHash"`
	Index                      *IntegerSelector  `json:"index"`
	Nonce                      *IntegerSelector  `json:"nonce"`
	TxReceiver                 *HashSelector     `json:"txReceiver"`
	TxReceiverShard            *BigIntIDSelector `json:"txReceiverShard"`
	TxSender                   *HashSelector     `json:"txSender"`
	TxSenderShard              *BigIntIDSelector `json:"txSenderShard"`
	Signature                  *HashSelector     `json:"signature"`
	Status                     *StringSelector   `json:"status"`
	Data                       *StringSelector   `json:"data"`
	DataOperation              *StringSelector   `json:"dataOperation"`
	CallResultIndex            *IntegerSelector  `json:"callResultIndex"`
	CallResultType             *StringSelector   `json:"callResultType"`
	CallResultData             *StringSelector   `json:"callResultData"`
	CallResultDataOperation    *StringSelector   `json:"callResultDataOperation"`
	CallResultHash             *HashSelector     `json:"callResultHash"`
	CallResultNonce            *IntegerSelector  `json:"callResultNonce"`
	OriginTxHash               *HashSelector     `json:"originTxHash"`
	PreviousTxHash             *HashSelector     `json:"previousTxHash"`
	CallResultReceiver         *HashSelector     `json:"callResultReceiver"`
	CallResultSender           *HashSelector     `json:"callResultSender"`
	ReturnMessage              *StringSelector   `json:"returnMessage"`
	Relayed                    *StringSelector   `json:"relayed"`
	CallResultValue            *FloatSelector    `json:"callResultValue"`
	CallResultRelayedValue     *FloatSelector    `json:"callResultRelayedValue"`
	CallResultGasPrice         *FloatSelector    `json:"callResultGasPrice"`
	CallResultGasLimit         *FloatSelector    `json:"callResultGasLimit"`
}

// Elrond Coinpath
type ElrondCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
	// Transaction of transfer happened
	Transaction *ElrondTransactionValueDimension `json:"transaction"`
}

// Miniblocks in Elrond  blockchain
type ElrondMiniblock struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Miniblock hash
	Hash    *string `json:"hash"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Hash of the receiver block
	ReceiverBlockHash *string `json:"receiverBlockHash"`
	// Number of the receiver shard
	ReceiverShard *string `json:"receiverShard"`
	// Information about miniblocks block
	SenderBlock *ElrondBlockDimension `json:"senderBlock"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Miniblock type
	Type *string `json:"type"`
}

type ElrondMiniblockFilter struct {
	Date              *DateSelector     `json:"date"`
	Time              *DateTimeSelector `json:"time"`
	Height            *BlockSelector    `json:"height"`
	PreviousBlockHash *HashSelector     `json:"previousBlockHash"`
	BlockHash         *HashSelector     `json:"blockHash"`
	Shard             *BigIntIDSelector `json:"shard"`
	Proposer          *HashSelector     `json:"proposer"`
	Epoch             *IntegerSelector  `json:"epoch"`
	BlockNonce        *IntegerSelector  `json:"blockNonce"`
	Round             *IntegerSelector  `json:"round"`
	Size              *IntegerSelector  `json:"size"`
	SizeTxs           *IntegerSelector  `json:"sizeTxs"`
	PublicKeyBitmap   *StringSelector   `json:"publicKeyBitmap"`
	StateRootHash     *HashSelector     `json:"stateRootHash"`
	TransactionCount  *IntegerSelector  `json:"transactionCount"`
	MiniblockHash     *HashSelector     `json:"miniblockHash"`
	ReceiverBlockHash *HashSelector     `json:"receiverBlockHash"`
	ReceiverShard     *BigIntIDSelector `json:"receiverShard"`
	Type              *StringSelector   `json:"type"`
}

// NotarizedBlocks in Elrond blockchain
type ElrondNotarizedBlock struct {
	Any *string `json:"any"`
	// Information about blocks notarized block
	Block       *ElrondBlockDimension `json:"block"`
	Count       *int                  `json:"count"`
	CountBigInt *string               `json:"countBigInt"`
	// The date this transaction was created
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Hash of the notarized block
	NotarizedBlockHash *string `json:"notarizedBlockHash"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
}

type ElrondNotarizedBlockFilter struct {
	Date               *DateSelector     `json:"date"`
	Time               *DateTimeSelector `json:"time"`
	Height             *BlockSelector    `json:"height"`
	PreviousBlockHash  *HashSelector     `json:"previousBlockHash"`
	BlockHash          *HashSelector     `json:"blockHash"`
	Shard              *BigIntIDSelector `json:"shard"`
	Proposer           *HashSelector     `json:"proposer"`
	Epoch              *IntegerSelector  `json:"epoch"`
	BlockNonce         *IntegerSelector  `json:"blockNonce"`
	Round              *IntegerSelector  `json:"round"`
	Size               *IntegerSelector  `json:"size"`
	SizeTxs            *IntegerSelector  `json:"sizeTxs"`
	PublicKeyBitmap    *StringSelector   `json:"publicKeyBitmap"`
	StateRootHash      *HashSelector     `json:"stateRootHash"`
	TransactionCount   *IntegerSelector  `json:"transactionCount"`
	NotarizedBlockHash *HashSelector     `json:"notarizedBlockHash"`
}

// Transactions in Elrond blockchain
type ElrondTransaction struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Data
	Data *string `json:"data"`
	// Data operation
	DataOperation *string `json:"dataOperation"`
	// The date this transaction was created
	Date *Date    `json:"date"`
	Fee  *float64 `json:"fee"`
	// Number of gas limit
	GasLimit *string `json:"gasLimit"`
	// Number of gas price
	GasPrice *string `json:"gasPrice"`
	// Number of gas used
	GasUsed *string `json:"gasUsed"`
	// Transaction hash
	Hash *string `json:"hash"`
	// Transaction index
	Index   *int    `json:"index"`
	Maximum *string `json:"maximum"`
	// Information about transactions miniblock
	Miniblock *MiniblockElrond `json:"miniblock"`
	Minimum   *string          `json:"minimum"`
	// Transaction nonce
	Nonce *int `json:"nonce"`
	// TX  receiver
	Receiver *Address `json:"receiver"`
	// Shard number of receiver
	ReceiverShard *string `json:"receiverShard"`
	// Hash of the sender
	Sender *Address `json:"sender"`
	// Information about transactions block
	SenderBlock *ElrondBlockDimension `json:"senderBlock"`
	// Shard number of sender
	SenderShard *string `json:"senderShard"`
	// Signature
	Signature *string `json:"signature"`
	// Tx Status
	Status *string `json:"status"`
	// The time this transaction was created
	Time  *DateTime `json:"time"`
	Value *float64  `json:"value"`
}

type ElrondTransactionFilter struct {
	Date                       *DateSelector     `json:"date"`
	Time                       *DateTimeSelector `json:"time"`
	Height                     *BlockSelector    `json:"height"`
	PreviousBlockHash          *HashSelector     `json:"previousBlockHash"`
	BlockHash                  *HashSelector     `json:"blockHash"`
	Shard                      *BigIntIDSelector `json:"shard"`
	Proposer                   *HashSelector     `json:"proposer"`
	Epoch                      *IntegerSelector  `json:"epoch"`
	BlockNonce                 *IntegerSelector  `json:"blockNonce"`
	Round                      *IntegerSelector  `json:"round"`
	Size                       *IntegerSelector  `json:"size"`
	SizeTxs                    *IntegerSelector  `json:"sizeTxs"`
	PublicKeyBitmap            *StringSelector   `json:"publicKeyBitmap"`
	StateRootHash              *HashSelector     `json:"stateRootHash"`
	TransactionCount           *IntegerSelector  `json:"transactionCount"`
	MiniblockHash              *HashSelector     `json:"miniblockHash"`
	MiniblockReceiverBlockHash *HashSelector     `json:"miniblockReceiverBlockHash"`
	MiniblockReceiverShard     *BigIntIDSelector `json:"miniblockReceiverShard"`
	Type                       *StringSelector   `json:"type"`
	TxHash                     *HashSelector     `json:"txHash"`
	TxIndex                    *IntegerSelector  `json:"txIndex"`
	TxNonce                    *IntegerSelector  `json:"txNonce"`
	TxReceiver                 *HashSelector     `json:"txReceiver"`
	TxReceiverShard            *BigIntIDSelector `json:"txReceiverShard"`
	TxSender                   *HashSelector     `json:"txSender"`
	TxSenderShard              *BigIntIDSelector `json:"txSenderShard"`
	Signature                  *HashSelector     `json:"signature"`
	Status                     *StringSelector   `json:"status"`
	Data                       *StringSelector   `json:"data"`
	DataOperation              *StringSelector   `json:"dataOperation"`
	Fee                        *FloatSelector    `json:"fee"`
	GasUsed                    *FloatSelector    `json:"gasUsed"`
	GasLimit                   *FloatSelector    `json:"gasLimit"`
	GasPrice                   *FloatSelector    `json:"gasPrice"`
	TxValue                    *FloatSelector    `json:"txValue"`
}

// Blockchain transaction with value
type ElrondTransactionValueDimension struct {
	// Transaction hash
	Hash string `json:"hash"`
	// Transaction value
	Value float64 `json:"value"`
}

// Transfers of Smart Contract Calls and Events
type ElrondTransfer struct {
	Amount      *float64 `json:"amount"`
	Any         *string  `json:"any"`
	Count       *int     `json:"count"`
	CountBigInt *string  `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// The date this transaction was created
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	// Metadata
	Metadata *string `json:"metadata"`
	// Information about arguments miniblock
	Miniblock *MiniblockElrond `json:"miniblock"`
	Minimum   *string          `json:"minimum"`
	// NFT nonce
	NftNonce *string `json:"nftNonce"`
	// How the money was transferred
	Reason *string `json:"reason"`
	// Receiver account address
	Receiver *Address `json:"receiver"`
	// Sender account address
	Sender *Address `json:"sender"`
	// Information about arguments block
	SenderBlock *ElrondBlockDimension `json:"senderBlock"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Information about arguments transaction
	Transaction *TransactionElrond `json:"transaction"`
}

type ElrondTransferFilter struct {
	Date                       *DateSelector           `json:"date"`
	Time                       *DateTimeSelector       `json:"time"`
	Height                     *BlockSelector          `json:"height"`
	PreviousBlockHash          *HashSelector           `json:"previousBlockHash"`
	BlockHash                  *HashSelector           `json:"blockHash"`
	Shard                      *BigIntIDSelector       `json:"shard"`
	Proposer                   *HashSelector           `json:"proposer"`
	Epoch                      *IntegerSelector        `json:"epoch"`
	BlockNonce                 *IntegerSelector        `json:"blockNonce"`
	Round                      *IntegerSelector        `json:"round"`
	Size                       *IntegerSelector        `json:"size"`
	SizeTxs                    *IntegerSelector        `json:"sizeTxs"`
	PublicKeyBitmap            *StringSelector         `json:"publicKeyBitmap"`
	StateRootHash              *HashSelector           `json:"stateRootHash"`
	TransactionCount           *IntegerSelector        `json:"transactionCount"`
	MiniblockHash              *HashSelector           `json:"miniblockHash"`
	MiniblockReceiverBlockHash *HashSelector           `json:"miniblockReceiverBlockHash"`
	MiniblockReceiverShard     *BigIntIDSelector       `json:"miniblockReceiverShard"`
	Type                       *StringSelector         `json:"type"`
	TxHash                     *HashSelector           `json:"txHash"`
	Index                      *IntegerSelector        `json:"index"`
	Nonce                      *IntegerSelector        `json:"nonce"`
	TxReceiver                 *HashSelector           `json:"txReceiver"`
	TxReceiverShard            *BigIntIDSelector       `json:"txReceiverShard"`
	TxSender                   *HashSelector           `json:"txSender"`
	TxSenderShard              *BigIntIDSelector       `json:"txSenderShard"`
	Signature                  *HashSelector           `json:"signature"`
	Status                     *StringSelector         `json:"status"`
	Data                       *StringSelector         `json:"data"`
	DataOperation              *StringSelector         `json:"dataOperation"`
	Currency                   *CurrencySelector       `json:"currency"`
	TransferSender             *AddressSelector        `json:"transferSender"`
	TransferReceiver           *AddressSelector        `json:"transferReceiver"`
	TransferReason             *TransferReasonSelector `json:"transferReason"`
	NftNonce                   *IntIDSelector          `json:"nftNonce"`
	Metadata                   *StringSelector         `json:"metadata"`
}

// Entity
type Entity struct {
	// Entity ID
	ID string `json:"id"`
	// Entity number
	Num int `json:"num"`
	// Entity realm ID
	RealmID int `json:"realmId"`
	// Entity shard ID
	ShardID int `json:"shardId"`
	// Entity Type
	Type string `json:"type"`
}

// Selector of entity ID for NFT  tokens
type EntitySelector struct {
	// EntityID is
	Is *string `json:"is"`
	// EntityID not
	Not *string `json:"not"`
	// EntityID in the list
	In []string `json:"in"`
	// EntityID not in the list
	NotIn []string `json:"notIn"`
}

// Select by entity type
type EntityTypeSelector struct {
	// Type is
	Is *EntityTypeEnum `json:"is"`
	// Type not
	Not *EntityTypeEnum `json:"not"`
	// Type in the list
	In []EntityTypeEnum `json:"in"`
	// Type not in the list
	NotIn []EntityTypeEnum `json:"notIn"`
}

// EOS Chain
type Eos struct {
	// Basic information about address ( or smart contract )
	Address []*EosAddressInfo `json:"address"`
	// Blockchain Blocks
	Blocks []*EosBlocks `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*EosCoinpath `json:"coinpath"`
	// Smart Contract Calls
	SmartContractCalls []*EosSmartContractCalls `json:"smartContractCalls"`
	// Blockchain Transactions
	Transactions []*EosTransactions `json:"transactions"`
	// Currency Transfers
	Transfers []*EosTransfers `json:"transfers"`
}

// Address detailed information for EOS network
type EosAddressInfo struct {
	// Address
	Address *string `json:"address"`
	// Annotations ( tags ), if exists
	Annotation *string `json:"annotation"`
	// Smart Contract if exists on the address
	SmartContract *EosSmartContractInfo `json:"smartContract"`
}

type EosBlockFilter struct {
	Date      *DateSelector     `json:"date"`
	Time      *DateTimeSelector `json:"time"`
	Height    *BlockSelector    `json:"height"`
	BlockHash *HashSelector     `json:"blockHash"`
	Proposer  *AddressSelector  `json:"proposer"`
}

// Blocks in EOS blockchain
type EosBlocks struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Block hash
	Hash string `json:"hash"`
	// Block number (height) in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Block producer
	Producer *Address `json:"producer"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
}

// Coinpath
type EosCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *EosAddressInfo `json:"receiver"`
	// Sender address
	Sender *EosAddressInfo `json:"sender"`
	// Transaction of transfer happened
	Transaction *TransactionHashValue `json:"transaction"`
}

// Currency selector in EOS blockchain.
// Token identified by address of contract ( eosio.token for main EOS token )
type EosCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

// Eos smart contract
type EosSmartContract struct {
	// Smart Contract Address
	Address *Address `json:"address"`
	// Smart Contract Type
	ContractType *SmartContractType `json:"contractType"`
	// Token implemented in this smart contract
	Currency *Currency `json:"currency"`
	// Smart Contract Protocol Type
	ProtocolType *string `json:"protocolType"`
}

type EosSmartContractCallFilter struct {
	Date                 *DateSelector     `json:"date"`
	Time                 *DateTimeSelector `json:"time"`
	Height               *BlockSelector    `json:"height"`
	TxHash               *HashSelector     `json:"txHash"`
	TxFrom               *AddressSelector  `json:"txFrom"`
	TxTo                 *AddressSelector  `json:"txTo"`
	SmartContractAddress *AddressSelector  `json:"smartContractAddress"`
	SmartContractMethod  *MethodSelector   `json:"smartContractMethod"`
	External             *bool             `json:"external"`
	Success              *bool             `json:"success"`
	Scheduled            *bool             `json:"scheduled"`
}

// Smart Contract Calls
type EosSmartContractCalls struct {
	// Actors
	Actors *string `json:"actors"`
	Any    *string `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
	CallDepth *string `json:"callDepth"`
	// Console
	Console *string `json:"console"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Error Code
	ErrorCode *int `json:"errorCode"`
	// External call executed explicitly by tx sender. Internal calls executed by smart contracts.
	External *bool   `json:"external"`
	Maximum  *string `json:"maximum"`
	Minimum  *string `json:"minimum"`
	// Permissions
	Permissions *string `json:"permissions"`
	// Receivers
	Receivers *string `json:"receivers"`
	// True if call scheduled
	Scheduled *bool `json:"scheduled"`
	// Smart contract being called
	SmartContract *EosSmartContract `json:"smartContract"`
	// Contract method invoked
	SmartContractMethod *Method `json:"smartContractMethod"`
	// True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
	Success *bool `json:"success"`
	// Action from address
	TxFrom *Address `json:"txFrom"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Action to address
	TxTo *Address `json:"txTo"`
}

// Blockchain smart contract
type EosSmartContractInfo struct {
	// Smart Contract Type
	ContractType *SmartContractType `json:"contractType"`
	// Token implemented in this smart contract
	Currency *Currency `json:"currency"`
	// Smart Contract Protocol Type
	ProtocolType *string `json:"protocolType"`
}

type EosTransactionFilter struct {
	Date      *DateSelector     `json:"date"`
	Time      *DateTimeSelector `json:"time"`
	Height    *BlockSelector    `json:"height"`
	TxHash    *HashSelector     `json:"txHash"`
	TxIndex   *TxIndexSelector  `json:"txIndex"`
	Success   *bool             `json:"success"`
	Scheduled *bool             `json:"scheduled"`
}

// Transactions in EOS blockchain
type EosTransactions struct {
	Any *string `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	CPUUsageUs  *int    `json:"cpuUsageUs"`
	// Calendar date
	Date *Date `json:"date"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0 based
	Index         *int    `json:"index"`
	Maximum       *string `json:"maximum"`
	Minimum       *string `json:"minimum"`
	NetUsageWords *int    `json:"netUsageWords"`
	// Success
	Scheduled *bool `json:"scheduled"`
	// Success
	Success *bool `json:"success"`
}

type EosTransferFilter struct {
	Date     *DateSelector        `json:"date"`
	Time     *DateTimeSelector    `json:"time"`
	Height   *BlockSelector       `json:"height"`
	TxHash   *HashSelector        `json:"txHash"`
	TxFrom   *AddressSelector     `json:"txFrom"`
	TxTo     *AddressSelector     `json:"txTo"`
	Sender   *AddressSelector     `json:"sender"`
	Receiver *AddressSelector     `json:"receiver"`
	Currency *EosCurrencySelector `json:"currency"`
	EntityID *EntitySelector      `json:"entityId"`
	External *bool                `json:"external"`
	Success  *bool                `json:"success"`
	Amount   []*AmountSelector    `json:"amount"`
}

// Currency transfers from/to addresses in crypto currencies
type EosTransfers struct {
	// Actors
	Actors *string  `json:"actors"`
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Entity identifier ( for ERC-721 NFT tokens )
	EntityID *string `json:"entityId"`
	// External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
	External *bool   `json:"external"`
	Maximum  *string `json:"maximum"`
	// Memo
	Memo    *string `json:"memo"`
	Minimum *string `json:"minimum"`
	// Transfer receiver
	Receiver *Address `json:"receiver"`
	// Transfer sender
	Sender *Address `json:"sender"`
	// Transfer succeeded
	Success *bool `json:"success"`
	// Action from address
	TxFrom *Address `json:"txFrom"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Action to address
	TxTo *Address `json:"txTo"`
}

// Ethereum Chain
type Ethereum struct {
	// Basic information about address ( or smart contract )
	Address []*EthereumAddressInfoWithBalance `json:"address"`
	// Arguments of Smart Contract Calls and Events
	Arguments []*EthereumArguments `json:"arguments"`
	// Blockchain Blocks
	Blocks []*EthereumBlocks `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*EthereumCoinpath `json:"coinpath"`
	// Trades on Ethereum DEX Smart Contracts
	DexTrades []*EthereumDexTrades `json:"dexTrades"`
	// Smart Contract Calls
	SmartContractCalls []*EthereumSmartContractCalls `json:"smartContractCalls"`
	// Smart Contract Events
	SmartContractEvents []*EthereumSmartContractEvent `json:"smartContractEvents"`
	// Blockchain Transactions
	Transactions []*EthereumTransactions `json:"transactions"`
	// Currency Transfers
	Transfers []*EthereumTransfers `json:"transfers"`
}

// Ethereum v 2.0 Baecon Chain
type Ethereum2 struct {
	// Attestations in block
	Attestations []*Ethereum2Attestation `json:"attestations"`
	// Attester Slashings
	AttesterSlashings []*Ethereum2AttesterSlashing `json:"attesterSlashings"`
	// Blockchain Blocks
	Blocks []*Ethereum2Blocks `json:"blocks"`
	// Attestations of blocks
	Deposits []*Ethereum2Deposit `json:"deposits"`
	// Proposer Slashings
	ProposerSlashings []*Ethereum2ProposerSlashing `json:"proposerSlashings"`
	// Voluntary Exits
	VoluntaryExits []*Ethereum2VoluntaryExit `json:"voluntaryExits"`
}

// Attestations in Ethereum v2.0 blockchain
type Ethereum2Attestation struct {
	AggregationBits string                    `json:"aggregationBits"`
	Any             *string                   `json:"any"`
	Attestation     *Ethereum2AttestationInfo `json:"attestation"`
	// Attestation Index (0 based ) in block
	AttestationIndex int `json:"attestationIndex"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Block root hash
	BlockRoot string `json:"blockRoot"`
	// Committee index for attestation
	CommitteeIndex int     `json:"committeeIndex"`
	Count          *int    `json:"count"`
	CountBigInt    *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Block Eth1 information
	Eth1    *Ethereum2Eth1Info `json:"eth1"`
	Maximum *string            `json:"maximum"`
	Minimum *string            `json:"minimum"`
	// Block parent hash
	ParentRoot string `json:"parentRoot"`
	// Block proposer
	Proposer *Ethereum2ValidatorInfo `json:"proposer"`
	// Block state root hash
	StateRoot string `json:"stateRoot"`
	// Validator
	Validator *Ethereum2ValidatorInfo `json:"validator"`
	// Sequential index of validator in committee ( 0-based)
	ValidatorInCommitteeIndex int `json:"validatorInCommitteeIndex"`
}

// AttestationFieldInfo for Ethereum v 2.0 network
type Ethereum2AttestationFieldInfo struct {
	Epoch int `json:"epoch"`
	// Root Hash
	Root string `json:"root"`
}

// AttestationInfo for Ethereum v 2.0 network
type Ethereum2AttestationInfo struct {
	BeaconBlockRoot string                         `json:"beaconBlockRoot"`
	Epoch           int                            `json:"epoch"`
	Signature       string                         `json:"signature"`
	Slot            int                            `json:"slot"`
	Source          *Ethereum2AttestationFieldInfo `json:"source"`
	Target          *Ethereum2AttestationFieldInfo `json:"target"`
}

// Attester Slashing in Ethereum v2.0 blockchain
type Ethereum2AttesterSlashing struct {
	Any         *string                   `json:"any"`
	Attestation *Ethereum2AttestationInfo `json:"attestation"`
	// Attestation slashing sequential number
	AttestationOrder int `json:"attestationOrder"`
	// Attester Slashing Index (0 based ) in block
	AttesterSlashingIndex int `json:"attesterSlashingIndex"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Block root hash
	BlockRoot   string  `json:"blockRoot"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Block Eth1 information
	Eth1    *Ethereum2Eth1Info `json:"eth1"`
	Maximum *string            `json:"maximum"`
	Minimum *string            `json:"minimum"`
	// Block parent hash
	ParentRoot string `json:"parentRoot"`
	// Block proposer
	Proposer *Ethereum2ValidatorInfo `json:"proposer"`
	// Block state root hash
	StateRoot string `json:"stateRoot"`
	// Validator
	Validator *Ethereum2ValidatorInfo `json:"validator"`
	// Validator index in slashing sequential numbern
	ValidatorInAttestationIndex int `json:"validatorInAttestationIndex"`
}

// Blocks in Ethereum v2.0 blockchain
type Ethereum2Blocks struct {
	Any                          *string `json:"any"`
	AttestationsCount            *int    `json:"attestationsCount"`
	AttestationsCountBigInt      *string `json:"attestationsCountBigInt"`
	AttesterSlashingsCount       *int    `json:"attesterSlashingsCount"`
	AttesterSlashingsCountBigInt *string `json:"attesterSlashingsCountBigInt"`
	// Block root hash
	BlockRoot   string  `json:"blockRoot"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date                *Date   `json:"date"`
	DepositsCount       *int    `json:"depositsCount"`
	DepositsCountBigInt *string `json:"depositsCountBigInt"`
	// Block Eth1 information
	Eth1 *Ethereum2Eth1Info `json:"eth1"`
	// Graffiti
	Graffiti string `json:"graffiti"`
	// Block number (height) in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Block parent hash
	ParentRoot string `json:"parentRoot"`
	// Block proposer
	Proposer                     *Ethereum2ValidatorInfo `json:"proposer"`
	ProposerSlashingsCount       *int                    `json:"proposerSlashingsCount"`
	ProposerSlashingsCountBigInt *string                 `json:"proposerSlashingsCountBigInt"`
	// Randao Reveal
	RandaoReveal string `json:"randaoReveal"`
	// Block signature
	Signature string `json:"signature"`
	// Block state root hash
	StateRoot string `json:"stateRoot"`
	// Block timestamp
	Timestamp                 *DateTime `json:"timestamp"`
	VoluntaryExitsCount       *int      `json:"voluntaryExitsCount"`
	VoluntaryExitsCountBigInt *string   `json:"voluntaryExitsCountBigInt"`
}

// Deposit in Ethereum v2.0 blockchain
type Ethereum2Deposit struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Block root hash
	BlockRoot   string  `json:"blockRoot"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Deposit Index (0 based ) in block
	DepositIndex int `json:"depositIndex"`
	// Block Eth1 information
	Eth1    *Ethereum2Eth1Info `json:"eth1"`
	Maximum *string            `json:"maximum"`
	Minimum *string            `json:"minimum"`
	// Block parent hash
	ParentRoot string `json:"parentRoot"`
	Proof      string `json:"proof"`
	// Block proposer
	Proposer  *Ethereum2ValidatorInfo `json:"proposer"`
	Signature string                  `json:"signature"`
	// Block state root hash
	StateRoot string `json:"stateRoot"`
	// Validator
	Validator *Ethereum2ValidatorInfo `json:"validator"`
}

// Eth1 attributes for Ethereum v 2.0 network
type Ethereum2Eth1Info struct {
	// Block Eth1 block hash
	BlockHash string `json:"blockHash"`
	// Block Eth1 deposit count
	DepositCount int `json:"depositCount"`
	// Block Eth1 deposit root hash
	DepositRoot string `json:"depositRoot"`
}

type Ethereum2Filter struct {
	Date               *DateSelector      `json:"date"`
	Time               *DateTimeSelector  `json:"time"`
	Height             *BlockSelector     `json:"height"`
	BlockRootHash      *HashSelector      `json:"blockRootHash"`
	BlockProposerIndex []*IntegerSelector `json:"blockProposerIndex"`
}

// Proposer Slashing in Ethereum v2.0 blockchain
type Ethereum2ProposerSlashing struct {
	Any *string `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Block root hash
	BlockRoot   string  `json:"blockRoot"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Block Eth1 information
	Eth1 *Ethereum2Eth1Info `json:"eth1"`
	// Header slashing sequential numbern
	HeaderOrder int     `json:"headerOrder"`
	Maximum     *string `json:"maximum"`
	Minimum     *string `json:"minimum"`
	// Block parent hash
	ParentRoot string `json:"parentRoot"`
	// Block proposer
	Proposer *Ethereum2ValidatorInfo `json:"proposer"`
	// Proposer Slashing Index (0 based ) in block
	ProposerSlashingIndex int                    `json:"proposerSlashingIndex"`
	Slashing              *Ethereum2SlashingInfo `json:"slashing"`
	// Block state root hash
	StateRoot string `json:"stateRoot"`
}

// SlashingInfo for Ethereum v 2.0 network
type Ethereum2SlashingInfo struct {
	// Block body hash
	BodyRoot string `json:"bodyRoot"`
	Epoch    int    `json:"epoch"`
	// Block parent hash
	ParentRoot string `json:"parentRoot"`
	// Block proposer
	Proposer  *Ethereum2ValidatorInfo `json:"proposer"`
	Signature string                  `json:"signature"`
	Slot      int                     `json:"slot"`
	// Block state root hash
	StateRoot string `json:"stateRoot"`
}

// Validator attributes for Ethereum v 2.0 network
type Ethereum2ValidatorInfo struct {
	// Validator Index as Integer
	Index int `json:"index"`
	// Validator Pub Key
	Pubkey string `json:"pubkey"`
	// Validator Withdrawal
	WithdrawalCredentials string `json:"withdrawalCredentials"`
}

// Voluntary Exit in Ethereum v2.0 blockchain
type Ethereum2VoluntaryExit struct {
	Any *string `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Block root hash
	BlockRoot   string  `json:"blockRoot"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Block Eth1 information
	Eth1    *Ethereum2Eth1Info `json:"eth1"`
	Maximum *string            `json:"maximum"`
	Minimum *string            `json:"minimum"`
	// Block parent hash
	ParentRoot string `json:"parentRoot"`
	// Block proposer
	Proposer *Ethereum2ValidatorInfo `json:"proposer"`
	// Signature
	Signature string `json:"signature"`
	// Block state root hash
	StateRoot string `json:"stateRoot"`
	// Validator
	Validator          *Ethereum2ValidatorInfo `json:"validator"`
	VoluntaryExitEpoch int                     `json:"voluntaryExitEpoch"`
	// Voluntary Exit Index (0 based ) in block
	VoluntaryExitIndex int `json:"voluntaryExitIndex"`
}

// Address detailed information for Ethereum network
type EthereumAddressInfo struct {
	// Address
	Address *string `json:"address"`
	// Annotations ( tags ), if exists
	Annotation *string `json:"annotation"`
	// Smart Contract if exists on the address
	SmartContract *EthereumSmartContractInfo `json:"smartContract"`
}

// Blockchain address
type EthereumAddressInfoWithBalance struct {
	// Address
	Address *string `json:"address"`
	// Annotations ( tags ), if exists
	Annotation *string `json:"annotation"`
	// DEPRECATED Current address balance
	Balance *float64 `json:"balance"`
	// DEPRECATED Balances by currencies for the address
	Balances []*EthereumBalance `json:"balances"`
	// Smart Contract if exists on the address
	SmartContract *EthereumSmartContractInfoWithAttributes `json:"smartContract"`
}

// Address should start from 0x and contain hex digits.
//   If digits are case sensitive, address is checked against checksum according to EIP-55.
type EthereumAddressSelector struct {
	// Equal to Address
	Is *string `json:"is"`
	// Not Equal to Address
	Not *string `json:"not"`
	// In the list of Addresses
	In []string `json:"in"`
	// Not in the list of Addresses
	NotIn []string `json:"notIn"`
}

// Address should start from 0x and contain hex digits.
//   If digits are case sensitive, address is checked against checksum according to EIP-55.
type EthereumAddressSelectorIn struct {
	// Equal to Address
	Is *string `json:"is"`
	// In the list of Addresses
	In []string `json:"in"`
}

type EthereumArgumentFilter struct {
	Date                 *DateSelector              `json:"date"`
	Time                 *DateTimeSelector          `json:"time"`
	Height               *BlockSelector             `json:"height"`
	TxHash               *HashSelector              `json:"txHash"`
	TxFrom               []*EthereumAddressSelector `json:"txFrom"`
	Caller               []*EthereumAddressSelector `json:"caller"`
	Reference            []*EthereumAddressSelector `json:"reference"`
	Value                []*ArgumentValueSelector   `json:"value"`
	Argument             []*ArgumentSelector        `json:"argument"`
	ArgumentType         []*ArgumentTypeSelector    `json:"argumentType"`
	SignatureType        *SignatureTypeSelector     `json:"signatureType"`
	SmartContractAddress []*EthereumAddressSelector `json:"smartContractAddress"`
	SmartContractMethod  *MethodSelector            `json:"smartContractMethod"`
	SmartContractEvent   *EventSelector             `json:"smartContractEvent"`
	External             *bool                      `json:"external"`
}

// Arguments of Smart Contract Calls and Events
type EthereumArguments struct {
	Any *string `json:"any"`
	// Method or event argument
	Argument *ArgumentName `json:"argument"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
	CallDepth *string `json:"callDepth"`
	// Caller of the method invocation ( tx sender or another smart contract )
	Caller *EthereumAddressInfo `json:"caller"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// External call executed explicitly by tx sender. Internal calls executed by smart contracts.
	External *bool `json:"external"`
	// Sequential index of value in array ( multi-dimensional)
	Index   string   `json:"index"`
	Maximum *string  `json:"maximum"`
	Minimum *string  `json:"minimum"`
	Number  *float64 `json:"number"`
	// Address value of method or event argument
	Reference *EthereumAddressInfo `json:"reference"`
	// Smart contract being called
	SmartContract *EthereumSmartContract `json:"smartContract"`
	// Contract method or event
	SmartContractSignature Signature `json:"smartContractSignature"`
	// True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
	Success *bool `json:"success"`
	// Transaction where call happened
	Transaction *EthereumTransactionInfo `json:"transaction"`
	// The Value of method or event argument
	Value *ArgumentValue `json:"value"`
}

// Balance in a currency
type EthereumBalance struct {
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// History of balance changes by currencies for the address
	History []*EthereumBalanceChange `json:"history"`
	Value   *float64                 `json:"value"`
}

// Change of balance in a currency
type EthereumBalanceChange struct {
	// Block number (height) in blockchain
	Block int `json:"block"`
	// Block timestamp
	Timestamp *string `json:"timestamp"`
	// Transfer amount ( positive inbound, negative outbound)
	TransferAmount *float64 `json:"transferAmount"`
	Value          *float64 `json:"value"`
}

type EthereumBlockFilter struct {
	Date             *DateSelector              `json:"date"`
	Time             *DateTimeSelector          `json:"time"`
	Height           *BlockSelector             `json:"height"`
	BlockHash        *HashSelector              `json:"blockHash"`
	Miner            []*EthereumAddressSelector `json:"miner"`
	BlockReward      []*AmountSelector          `json:"blockReward"`
	TransactionCount []*IntegerSelector         `json:"transactionCount"`
	UncleCount       []*IntegerSelector         `json:"uncleCount"`
	Size             []*IntegerSelector         `json:"size"`
}

// Blocks in Ethereum blockchain
type EthereumBlocks struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date       *Date    `json:"date"`
	Difficulty *float64 `json:"difficulty"`
	// Block hash
	Hash string `json:"hash"`
	// Block number (height) in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	// Block miner
	Miner   *EthereumAddressInfo `json:"miner"`
	Minimum *string              `json:"minimum"`
	// Block nonce
	Nonce int `json:"nonce"`
	// Parent block hash
	ParentHash string   `json:"parentHash"`
	Reward     *float64 `json:"reward"`
	// Currency of reward
	RewardCurrency *Currency `json:"rewardCurrency"`
	Size           *int      `json:"size"`
	// Block timestamp
	Timestamp              *DateTime `json:"timestamp"`
	TotalDifficulty        *float64  `json:"totalDifficulty"`
	TransactionCount       *int      `json:"transactionCount"`
	TransactionCountBigInt *string   `json:"transactionCountBigInt"`
	UncleCount             *int      `json:"uncleCount"`
	UncleCountBigInt       *string   `json:"uncleCountBigInt"`
}

// Coinpath
type EthereumCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *EthereumAddressInfo `json:"receiver"`
	// Sender address
	Sender *EthereumAddressInfo `json:"sender"`
	// Transaction of transfer happened
	Transaction *TransactionHashValue `json:"transaction"`
	// Attributes of transaction included in Coinpath result
	Transactions []*CoinpathEntry `json:"transactions"`
}

// Currency selector in Ethereum blockchain.
//   Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
//   You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
//   Ethereum Smart contract address should start from 0x and contain 40 hex digits.
//   If digits are case sensitive, address is checked against checksum according to EIP-55.
type EthereumCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

// Ethereum DEX attributes
type EthereumDex struct {
	// Address for DEX exchange identification
	Address *Address `json:"address"`
	// Full name ( name for known, Protocol for unknown )
	FullName string `json:"fullName"`
	// Full name ( name for known, Protocol / address for unknown )
	FullNameWithID string `json:"fullNameWithId"`
	// Name for known exchanges
	Name *string `json:"name"`
}

type EthereumDexTradeFilter struct {
	Date                   *DateSelector                `json:"date"`
	Time                   *DateTimeSelector            `json:"time"`
	Height                 *BlockSelector               `json:"height"`
	TxHash                 *HashSelector                `json:"txHash"`
	TxSender               []*EthereumAddressSelector   `json:"txSender"`
	TxTo                   []*EthereumAddressSelector   `json:"txTo"`
	Protocol               []*StringSelector            `json:"protocol"`
	SmartContractAddress   []*EthereumAddressSelector   `json:"smartContractAddress"`
	ExchangeAddress        []*EthereumAddressSelector   `json:"exchangeAddress"`
	ExchangeName           []*StringSelector            `json:"exchangeName"`
	SellCurrency           []*EthereumCurrencySelector  `json:"sellCurrency"`
	BuyCurrency            []*EthereumCurrencySelector  `json:"buyCurrency"`
	BaseCurrency           []*EthereumCurrencySelector  `json:"baseCurrency"`
	QuoteCurrency          []*EthereumCurrencySelector  `json:"quoteCurrency"`
	Maker                  []*EthereumAddressSelector   `json:"maker"`
	MakerSmartContractType []*SmartContractTypeSelector `json:"makerSmartContractType"`
	Taker                  []*EthereumAddressSelector   `json:"taker"`
	TakerSmartContractType []*SmartContractTypeSelector `json:"takerSmartContractType"`
	MakerOrTaker           []*EthereumAddressSelector   `json:"makerOrTaker"`
	TradeIndex             []*StringSelector            `json:"tradeIndex"`
	BuyAmount              []*AmountSelector            `json:"buyAmount"`
	SellAmount             []*AmountSelector            `json:"sellAmount"`
	Price                  []*AmountSelector            `json:"price"`
	PriceAsymmetry         []*FloatSelector             `json:"priceAsymmetry"`
	TradeAmountUsd         []*FloatSelector             `json:"tradeAmountUsd"`
}

// Trades on DEX smart contracts
type EthereumDexTrades struct {
	// Trader (maker or taker)
	Address    *EthereumAddressInfo `json:"address"`
	Any        *string              `json:"any"`
	BaseAmount *float64             `json:"baseAmount"`
	// Base currency
	BaseCurrency *Currency `json:"baseCurrency"`
	// Block in the blockchain
	Block     *BlockExtended `json:"block"`
	BuyAmount *float64       `json:"buyAmount"`
	// Maker buys this currency
	BuyCurrency *Currency `json:"buyCurrency"`
	Count       *int      `json:"count"`
	CountBigInt *string   `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Identification of admin / manager / factory of smart contract, executing trades
	Exchange *EthereumDex `json:"exchange"`
	Gas      *float64     `json:"gas"`
	// Gas price in Gwei
	GasPrice float64  `json:"gasPrice"`
	GasValue *float64 `json:"gasValue"`
	// Trade 'maker' side
	Maker   *EthereumAddressInfo `json:"maker"`
	Maximum *string              `json:"maximum"`
	Minimum *string              `json:"minimum"`
	Price   *float64             `json:"price"`
	// Protocol name of the smart contract
	Protocol    *string  `json:"protocol"`
	QuoteAmount *float64 `json:"quoteAmount"`
	// Quote currency
	QuoteCurrency *Currency `json:"quoteCurrency"`
	QuotePrice    *float64  `json:"quotePrice"`
	SellAmount    *float64  `json:"sellAmount"`
	// Maker sells this currency
	SellCurrency *Currency `json:"sellCurrency"`
	// Side of trade ( SELL / BUY )
	Side *TradeSide `json:"side"`
	// Smart contract being called
	SmartContract *EthereumSmartContract `json:"smartContract"`
	// Trade 'taker' side
	Taker *EthereumAddressInfo `json:"taker"`
	// Time interval
	TimeInterval *TimeInterval `json:"timeInterval"`
	TradeAmount  *float64      `json:"tradeAmount"`
	// Index of trade in transaction, used to separate trades in transaction
	TradeIndex *string `json:"tradeIndex"`
	// Transaction of DexTrade
	Transaction *EthereumTransactionInfoExtended `json:"transaction"`
}

// Ethereum smart contract
type EthereumSmartContract struct {
	// Smart Contract Address
	Address *Address `json:"address"`
	// Smart Contract Type
	ContractType *SmartContractType `json:"contractType"`
	// Token implemented in this smart contract
	Currency *Currency `json:"currency"`
	// Smart Contract Protocol Type
	ProtocolType *string `json:"protocolType"`
}

type EthereumSmartContractCallFilter struct {
	Date                 *DateSelector              `json:"date"`
	Time                 *DateTimeSelector          `json:"time"`
	Height               *BlockSelector             `json:"height"`
	TxHash               *HashSelector              `json:"txHash"`
	TxFrom               []*EthereumAddressSelector `json:"txFrom"`
	Caller               []*EthereumAddressSelector `json:"caller"`
	SmartContractAddress []*EthereumAddressSelector `json:"smartContractAddress"`
	SmartContractMethod  *MethodSelector            `json:"smartContractMethod"`
	SmartContractType    *SmartContractTypeSelector `json:"smartContractType"`
	External             *bool                      `json:"external"`
	Success              []bool                     `json:"success"`
}

// Smart Contract Calls
type EthereumSmartContractCalls struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Call arguments
	Arguments []*ArgumentNameValue `json:"arguments"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
	CallDepth *string `json:"callDepth"`
	// Caller of the method invocation ( tx sender or another smart contract )
	Caller *EthereumAddressInfo `json:"caller"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// External call executed explicitly by tx sender. Internal calls executed by smart contracts.
	External *bool `json:"external"`
	// Gas used for transaction in external call, or by methd in internal call
	GasValue *float64 `json:"gasValue"`
	Maximum  *string  `json:"maximum"`
	Minimum  *string  `json:"minimum"`
	// Smart contract being called
	SmartContract *EthereumSmartContract `json:"smartContract"`
	// Contract method invoked
	SmartContractMethod *Method `json:"smartContractMethod"`
	// True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
	Success *bool `json:"success"`
	// Transaction where call happened
	Transaction *EthereumTransactionInfo `json:"transaction"`
}

// Smart Contract Events
type EthereumSmartContractEvent struct {
	Any *string `json:"any"`
	// Event arguments
	Arguments []*ArgumentNameValue `json:"arguments"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Event index
	EventIndex *string `json:"eventIndex"`
	Maximum    *string `json:"maximum"`
	Minimum    *string `json:"minimum"`
	// Smart contract being called
	SmartContract *EthereumSmartContract `json:"smartContract"`
	// Contract event logged
	SmartContractEvent *Event `json:"smartContractEvent"`
	// Transaction where event happened
	Transaction *EthereumTransactionInfo `json:"transaction"`
}

type EthereumSmartContractEventFilter struct {
	Date                 *DateSelector              `json:"date"`
	Time                 *DateTimeSelector          `json:"time"`
	Height               *BlockSelector             `json:"height"`
	TxHash               *HashSelector              `json:"txHash"`
	TxFrom               []*EthereumAddressSelector `json:"txFrom"`
	SmartContractType    *SmartContractTypeSelector `json:"smartContractType"`
	SmartContractAddress []*EthereumAddressSelector `json:"smartContractAddress"`
	SmartContractEvent   *EventSelector             `json:"smartContractEvent"`
}

// Blockchain smart contract
type EthereumSmartContractInfo struct {
	// Smart Contract Type
	ContractType *SmartContractType `json:"contractType"`
	// Token implemented in this smart contract
	Currency *Currency `json:"currency"`
	// Smart Contract Protocol Type
	ProtocolType *string `json:"protocolType"`
}

// Blockchain smart contract
type EthereumSmartContractInfoWithAttributes struct {
	// Attributes from readonly methods
	Attributes []*SmartContractReadonlyAttribute `json:"attributes"`
	// Smart Contract Type
	ContractType *SmartContractType `json:"contractType"`
	// Token implemented in this smart contract
	Currency *Currency `json:"currency"`
	// Smart Contract Protocol Type
	ProtocolType *string `json:"protocolType"`
}

type EthereumTransactionFilter struct {
	Date        *DateSelector               `json:"date"`
	Time        *DateTimeSelector           `json:"time"`
	Height      *BlockSelector              `json:"height"`
	TxHash      *HashSelector               `json:"txHash"`
	TxSender    []*EthereumAddressSelector  `json:"txSender"`
	TxTo        []*EthereumAddressSelector  `json:"txTo"`
	TxCreates   []*EthereumAddressSelector  `json:"txCreates"`
	TxIndex     *TxIndexSelector            `json:"txIndex"`
	Success     *bool                       `json:"success"`
	Amount      []*AmountSelector           `json:"amount"`
	GasCurrency []*EthereumCurrencySelector `json:"gasCurrency"`
	GasValue    []*AmountSelector           `json:"gasValue"`
}

// Blockchain transaction info
type EthereumTransactionInfo struct {
	// Gas consumed
	Gas int `json:"gas"`
	// Gas price in Gwei
	GasPrice float64 `json:"gasPrice"`
	// Gas value cost
	GasValue float64 `json:"gasValue"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction from address
	TxFrom *EthereumAddressInfo `json:"txFrom"`
}

// Blockchain Transaction Extended info
type EthereumTransactionInfoExtended struct {
	// Gas consumed
	Gas int `json:"gas"`
	// Gas price in Gwei
	GasPrice float64 `json:"gasPrice"`
	// Gas value cost
	GasValue float64 `json:"gasValue"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0 based
	Index *int `json:"index"`
	// Transaction nonce
	Nonce *int `json:"nonce"`
	// Transaction receiver
	To *EthereumAddressInfo `json:"to"`
	// Transaction from address
	TxFrom *EthereumAddressInfo `json:"txFrom"`
}

// Transactions in Ethereum blockchain
type EthereumTransactions struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Created smart contract
	Creates *EthereumAddressInfo `json:"creates"`
	// Currency of amount
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Error message if any
	Error *string  `json:"error"`
	Gas   *float64 `json:"gas"`
	// Currency of gas
	GasCurrency *Currency `json:"gasCurrency"`
	// Gas price in Gwei
	GasPrice float64  `json:"gasPrice"`
	GasValue *float64 `json:"gasValue"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0 based
	Index   *int    `json:"index"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Transaction nonce
	Nonce *int `json:"nonce"`
	// Transaction sender
	Sender *EthereumAddressInfo `json:"sender"`
	// Success
	Success *bool `json:"success"`
	// Transaction receiver
	To *EthereumAddressInfo `json:"to"`
}

type EthereumTransferFilter struct {
	Date     *DateSelector               `json:"date"`
	Time     *DateTimeSelector           `json:"time"`
	Height   *BlockSelector              `json:"height"`
	TxHash   *HashSelector               `json:"txHash"`
	TxFrom   []*EthereumAddressSelector  `json:"txFrom"`
	EntityID *EntitySelector             `json:"entityId"`
	Sender   []*EthereumAddressSelector  `json:"sender"`
	Receiver []*EthereumAddressSelector  `json:"receiver"`
	Currency []*EthereumCurrencySelector `json:"currency"`
	External *bool                       `json:"external"`
	Success  *bool                       `json:"success"`
	Amount   []*AmountSelector           `json:"amount"`
}

// Currency transfers from/to addresses in crypto currencies
type EthereumTransfers struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Entity identifier ( for ERC-721 NFT tokens )
	EntityID *string `json:"entityId"`
	// External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
	External *bool    `json:"external"`
	GasValue *float64 `json:"gasValue"`
	Maximum  *string  `json:"maximum"`
	Minimum  *string  `json:"minimum"`
	// Transfer receiver
	Receiver *EthereumAddressInfo `json:"receiver"`
	// Transfer sender
	Sender *EthereumAddressInfo `json:"sender"`
	// Success flag
	Success *bool `json:"success"`
	// Transaction where transfer happened
	Transaction *EthereumTransactionInfo `json:"transaction"`
}

// Smart contract event
type Event struct {
	// Name
	Name *string `json:"name"`
	// Signature
	Signature *string `json:"signature"`
	// Signature Hash
	SignatureHash string `json:"signatureHash"`
}

func (Event) IsSignature() {}

// Smart contract event. In selector you can use the name, signature or hex hash
type EventSelector struct {
	// Event signature is
	Is *string `json:"is"`
	// Event signature not
	Not *string `json:"not"`
	// Event signature in the list
	In []string `json:"in"`
	// Event signature not in the list
	NotIn []string `json:"notIn"`
}

// Filecoin
type Filecoin struct {
	// Filecoin Network Blocks
	Blocks []*FilecoinBlock `json:"blocks"`
	// Filecoin Network Calls
	Calls []*FilecoinCalls `json:"calls"`
	// Money flow using Coinpath technology
	Coinpath []*FilecoinCoinpath `json:"coinpath"`
	// Filecoin Network Messages ( blocks, transfers, ... )
	Messages []*FilecoinMessages `json:"messages"`
	// Filecoin Network Currency Transfers
	Transfers []*FilecoinTransfers `json:"transfers"`
}

// Block
type FilecoinBlock struct {
	Any          *string     `json:"any"`
	BlockSig     *NameWithID `json:"blockSig"`
	BlsAggregate *NameWithID `json:"blsAggregate"`
	Count        *int        `json:"count"`
	CountBigInt  *string     `json:"countBigInt"`
	// Calendar date
	Date           *Date   `json:"date"`
	ElectionProof  *string `json:"electionProof"`
	ForkSignalling *string `json:"forkSignalling"`
	// Block hash
	Hash string `json:"hash"`
	// Block round in blockchain
	Height int `json:"height"`
	// Block index on height
	Index              *int    `json:"index"`
	Maximum            *string `json:"maximum"`
	MessageCount       *int    `json:"messageCount"`
	MessageCountBigInt *string `json:"messageCountBigInt"`
	Messages           *string `json:"messages"`
	// Miner
	Miner                 *Address `json:"miner"`
	MinerTips             *float64 `json:"minerTips"`
	Minimum               *string  `json:"minimum"`
	ParentMessageReceipts *string  `json:"parentMessageReceipts"`
	ParentStateRoot       *string  `json:"parentStateRoot"`
	ParentWeight          *string  `json:"parentWeight"`
	Reward                *float64 `json:"reward"`
	Ticket                *string  `json:"ticket"`
	// Block timestamp
	Timestamp      *DateTime `json:"timestamp"`
	TotalReward    *float64  `json:"totalReward"`
	WinCount       *int      `json:"winCount"`
	WinCountBigInt *string   `json:"winCountBigInt"`
	Wincount       *int      `json:"wincount"`
}

type FilecoinBlockFilter struct {
	Date       *DateSelector      `json:"date"`
	Time       *DateTimeSelector  `json:"time"`
	Height     *BlockSelector     `json:"height"`
	BlockHash  *HashSelector      `json:"blockHash"`
	Miner      []*AddressSelector `json:"miner"`
	BlockIndex *IntegerSelector   `json:"blockIndex"`
}

type FilecoinCallFilter struct {
	Date          *DateSelector     `json:"date"`
	Time          *DateTimeSelector `json:"time"`
	Height        *BlockSelector    `json:"height"`
	Hash          *HashSelector     `json:"hash"`
	Sender        *AddressSelector  `json:"sender"`
	Receiver      *AddressSelector  `json:"receiver"`
	Method        *IntegerSelector  `json:"method"`
	Amount        *AmountSelector   `json:"amount"`
	MessageMethod *IntegerSelector  `json:"messageMethod"`
}

// Calls in Filecoin blockchain
type FilecoinCalls struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer Message is included
	Block *Block `json:"block"`
	// Call hash
	CallHash *string `json:"callHash"`
	// Call hash
	CallPath    *string `json:"callPath"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date       *Date    `json:"date"`
	ExitCode   *string  `json:"exitCode"`
	Gas        *int     `json:"gas"`
	GasFeeCap  *string  `json:"gasFeeCap"`
	GasLimit   *string  `json:"gasLimit"`
	GasPremium *float64 `json:"gasPremium"`
	// Message hash
	Hash    *string `json:"hash"`
	Maximum *string `json:"maximum"`
	// Message Method
	MessageMethod *NameWithID `json:"messageMethod"`
	// Method
	Method     *NameWithID         `json:"method"`
	MinedBlock *FilecoinMinedBlock `json:"minedBlock"`
	Minimum    *string             `json:"minimum"`
	Nonce      *string             `json:"nonce"`
	// Message receiver
	Receiver    *AddressWithAccount `json:"receiver"`
	ReturnValue *string             `json:"returnValue"`
	// Message sender
	Sender *AddressWithAccount `json:"sender"`
	// Success
	Success *bool `json:"success"`
}

// Coinpath
type FilecoinCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	// Message of transfer happened
	Message *TransactionHashValue `json:"message"`
	Minimum *string               `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
}

type FilecoinMessageFilter struct {
	Date     *DateSelector     `json:"date"`
	Time     *DateTimeSelector `json:"time"`
	Height   *BlockSelector    `json:"height"`
	Hash     *HashSelector     `json:"hash"`
	Index    *IntegerSelector  `json:"index"`
	Sender   *AddressSelector  `json:"sender"`
	Receiver *AddressSelector  `json:"receiver"`
	Method   *IntegerSelector  `json:"method"`
	Success  *bool             `json:"success"`
	Amount   *AmountSelector   `json:"amount"`
}

// Messages in Filecoin blockchain
type FilecoinMessages struct {
	Amount      *float64 `json:"amount"`
	Any         *string  `json:"any"`
	BaseFeeBurn *float64 `json:"baseFeeBurn"`
	// Block where transfer Message is included
	Block       *Block   `json:"block"`
	Burned      *float64 `json:"burned"`
	Count       *int     `json:"count"`
	CountBigInt *string  `json:"countBigInt"`
	// Calendar date
	Date       *Date    `json:"date"`
	ExitCode   *string  `json:"exitCode"`
	Gas        *int     `json:"gas"`
	GasFeeCap  *string  `json:"gasFeeCap"`
	GasLimit   *string  `json:"gasLimit"`
	GasPremium *float64 `json:"gasPremium"`
	// Message hash
	Hash    *string `json:"hash"`
	Maximum *string `json:"maximum"`
	// Method
	Method             *NameWithID         `json:"method"`
	MinedBlock         *FilecoinMinedBlock `json:"minedBlock"`
	MinerPenalty       *float64            `json:"minerPenalty"`
	MinerTip           *float64            `json:"minerTip"`
	Minimum            *string             `json:"minimum"`
	Nonce              *string             `json:"nonce"`
	OverEstimationBurn *float64            `json:"overEstimationBurn"`
	// Message receiver
	Receiver    *AddressWithAccount `json:"receiver"`
	Refund      *float64            `json:"refund"`
	ReturnValue *string             `json:"returnValue"`
	// Message sender
	Sender        *AddressWithAccount `json:"sender"`
	Signature     *string             `json:"signature"`
	SignatureType *string             `json:"signatureType"`
	// Signed Message hash
	SignedHash *string `json:"signedHash"`
	// Success
	Success   *bool    `json:"success"`
	TotalCost *float64 `json:"totalCost"`
}

// Filecoin Mined Block
type FilecoinMinedBlock struct {
	// Hash
	Hash *string `json:"hash"`
	// Index on height
	Index *int `json:"index"`
	// Miner
	Miner *Address `json:"miner"`
}

type FilecoinTransferFilter struct {
	Date          *DateSelector         `json:"date"`
	Time          *DateTimeSelector     `json:"time"`
	Height        *BlockSelector        `json:"height"`
	Hash          *HashSelector         `json:"hash"`
	Sender        *AddressSelector      `json:"sender"`
	Receiver      *AddressSelector      `json:"receiver"`
	Method        *IntegerSelector      `json:"method"`
	Amount        *AmountSelector       `json:"amount"`
	TransferType  *TransferTypeSelector `json:"transferType"`
	MessageMethod *IntegerSelector      `json:"messageMethod"`
}

// Transfers in Filecoin blockchain
type FilecoinTransfers struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer Transfer is included
	Block *BlockExtended `json:"block"`
	// Call hash
	CallHash *string `json:"callHash"`
	// Call hash
	CallPath    *string `json:"callPath"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Message hash
	Hash    *string `json:"hash"`
	Maximum *string `json:"maximum"`
	// Message Method
	MessageMethod *NameWithID `json:"messageMethod"`
	// Method
	Method  *NameWithID `json:"method"`
	Minimum *string     `json:"minimum"`
	// Transfer receiver
	Receiver *Address `json:"receiver"`
	// Transfer sender
	Sender *Address `json:"sender"`
	// Transfer timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Type of transfer
	TransferType *FilecoinTransferType `json:"transferType"`
}

// Select by number
type FloatSelector struct {
	// is
	Is *float64 `json:"is"`
	// not
	Not *float64 `json:"not"`
	// in the list
	In []float64 `json:"in"`
	// not in the list
	NotIn []float64 `json:"notIn"`
	// greater than
	Gt *float64 `json:"gt"`
	// less than
	Lt *float64 `json:"lt"`
	// less or equal than
	Lteq *float64 `json:"lteq"`
	// greater or equal than
	Gteq *float64 `json:"gteq"`
	// in range
	Between []float64 `json:"between"`
}

// Harmony Chain
type Harmony struct {
	// Arguments of Smart Contract Calls and Events
	Arguments []*HarmonyArguments `json:"arguments"`
	// Harmony Blocks
	Blocks []*HarmonyBlocks `json:"blocks"`
	// Smart Contract Calls
	SmartContractCalls []*HarmonySmartContractCalls `json:"smartContractCalls"`
	// Smart Contract Events
	SmartContractEvents []*HarmonySmartContractEvents `json:"smartContractEvents"`
	// Harmony Staking Transactions
	StakingTransactions []*HarmonyStakingTransactions `json:"stakingTransactions"`
	// Harmony Transactions
	Transactions []*HarmonyTransactions `json:"transactions"`
	// Harmony Transfers
	Transfers []*HarmonyTransfers `json:"transfers"`
}

// Arguments of Smart Contract Calls and Events
type HarmonyArguments struct {
	// Value
	Address *string `json:"address"`
	Any     *string `json:"any"`
	// Argument Index
	ArgIndex *string `json:"argIndex"`
	// Argument Type
	ArgType *string `json:"argType"`
	// Argument
	Argument *string `json:"argument"`
	// Transaction hash
	BlockHash *string `json:"blockHash"`
	// Call Path
	CallPath *string `json:"callPath"`
	Count    *int    `json:"count"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Epoch
	Epoch *string `json:"epoch"`
	// Hash of the block where this transaction was in
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The number of transactions made by the sender prior to this one.
	Nonce *string `json:"nonce"`
	// Value
	Number *string `json:"number"`
	// Address of the receiver
	Receiver *string `json:"receiver"`
	// Address of the sender
	Sender *string `json:"sender"`
	// ShardID
	ShardID *string `json:"shardId"`
	// Signature ID
	SignatureID *string `json:"signatureId"`
	// Address of the smart contract
	SmartContractAddress *string `json:"smartContractAddress"`
	// Id of the smart contract
	SmartContractID *string `json:"smartContractId"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Value
	Value *string `json:"value"`
}

type HarmonyArgumentsFilter struct {
	Time                 *DateTimeSelector `json:"time"`
	Date                 *DateSelector     `json:"date"`
	Ledger               *BlockSelector    `json:"ledger"`
	BlockHash            *HashSelector     `json:"blockHash"`
	Sender               *HashSelector     `json:"sender"`
	Receiver             *HashSelector     `json:"receiver"`
	SmartContractAddress *HashSelector     `json:"smartContractAddress"`
	SmartContractID      *IntegerSelector  `json:"smartContractId"`
	Argument             *StringSelector   `json:"argument"`
}

// Blocks in Harmony blockchain
type HarmonyBlocks struct {
	Any *string `json:"any"`
	// Transaction hash
	BlockHash   *string `json:"blockHash"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Difficulty
	Difficulty *string `json:"difficulty"`
	// Epoch
	Epoch *string `json:"epoch"`
	// The extra data field of this block
	ExtraData *string `json:"extraData"`
	// Gas limit
	GasLimit *string `json:"gasLimit"`
	// Gas used
	GasUsed *string `json:"gasUsed"`
	// Hash of the block where this transaction was in
	Ledger *string `json:"ledger"`
	// The bloom filter for the logs of the block. null when its pending block
	LogsBloom *string `json:"logsBloom"`
	Maximum   *string `json:"maximum"`
	// Transaction hash
	Miner   *string `json:"miner"`
	Minimum *string `json:"minimum"`
	// Mix Hash
	MixHash *string `json:"mixHash"`
	// Nonce
	Nonce *string `json:"nonce"`
	// Parent hash
	ParentHash *string `json:"parentHash"`
	// Receipts Root
	ReceiptsRoot *string `json:"receiptsRoot"`
	// ShardID
	ShardID *string `json:"shardId"`
	// Integer the size of this block in bytes
	Size *string `json:"size"`
	// Staking Transaction Count
	StakingTransactionsCount *string `json:"stakingTransactionsCount"`
	// The root of the final state trie of the block
	StateRoot *string `json:"stateRoot"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Transaction Count
	TransactionCount *string `json:"transactionCount"`
	// The root of the transaction trie of the block
	TransactionsRoot *string `json:"transactionsRoot"`
	// Count of ucles hashes
	UnclesCount *string `json:"unclesCount"`
	// View ID
	ViewID *string `json:"viewId"`
}

type HarmonyBlocksFilter struct {
	Date                     *DateSelector  `json:"date"`
	Ledger                   *BlockSelector `json:"ledger"`
	BlockHash                *HashSelector  `json:"blockHash"`
	Miner                    *HashSelector  `json:"miner"`
	ViewID                   *HashSelector  `json:"viewId"`
	PerentHash               *HashSelector  `json:"perentHash"`
	TransactionCount         *HashSelector  `json:"transactionCount"`
	StakingTransactionsCount *HashSelector  `json:"stakingTransactionsCount"`
	UnclesCount              *HashSelector  `json:"unclesCount"`
}

// Smart Contract Calls
type HarmonySmartContractCalls struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
	CallPath *string `json:"callPath"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// External call executed explicitly by caller. Internal calls executed by smart contracts.
	External *bool `json:"external"`
	Gas      *int  `json:"gas"`
	// Gas unit price
	GasPrice float64  `json:"gasPrice"`
	GasValue *float64 `json:"gasValue"`
	Maximum  *string  `json:"maximum"`
	Minimum  *string  `json:"minimum"`
	// Nonce
	Nonce *string `json:"nonce"`
	// Contract method invoked
	SmartContractMethod *Method `json:"smartContractMethod"`
	// True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
	Success *bool `json:"success"`
	// Action from address
	TxFrom *Address `json:"txFrom"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Transaction Sender
	TxSender *Address `json:"txSender"`
	// Action to address
	TxTo *Address `json:"txTo"`
}

type HarmonySmartContractCallsFilter struct {
	Date                 *DateSelector     `json:"date"`
	Time                 *DateTimeSelector `json:"time"`
	Height               *BlockSelector    `json:"height"`
	TxHash               *HashSelector     `json:"txHash"`
	TxFrom               *AddressSelector  `json:"txFrom"`
	TxTo                 *AddressSelector  `json:"txTo"`
	SmartContractAddress *AddressSelector  `json:"smartContractAddress"`
	SmartContractMethod  *MethodSelector   `json:"smartContractMethod"`
	External             *bool             `json:"external"`
	Success              *bool             `json:"success"`
}

// Smart Contract Events
type HarmonySmartContractEvents struct {
	Any *string `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Transaction hash where transfer happened
	Epoch   *string `json:"epoch"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The number of transactions made by the sender prior to this one.
	Nonce *string `json:"nonce"`
	// Contract method invoked
	SmartContractEvent *Event `json:"smartContractEvent"`
	// Action from address
	TxFrom *Address `json:"txFrom"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Action to address
	TxTo *Address `json:"txTo"`
}

type HarmonySmartContractEventsFilter struct {
	Date                 *DateSelector     `json:"date"`
	Time                 *DateTimeSelector `json:"time"`
	Height               *BlockSelector    `json:"height"`
	TxHash               *HashSelector     `json:"txHash"`
	TxFrom               *AddressSelector  `json:"txFrom"`
	TxTo                 *AddressSelector  `json:"txTo"`
	SmartContractAddress *AddressSelector  `json:"smartContractAddress"`
	SmartContractEvent   *EventSelector    `json:"smartContractEvent"`
}

// StakingTransactions in Harmony blockchain
type HarmonyStakingTransactions struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Data
	Data *string `json:"data"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Delegator Address
	DelegatorAddress *string `json:"delegatorAddress"`
	// Epoch
	Epoch *string `json:"epoch"`
	// Gas provided by the sender
	Gas *string `json:"gas"`
	// Gas price provided by the sender
	GasPrice *string `json:"gasPrice"`
	// Hash of the block where this transaction was in
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The number of transactions made by the sender prior to this one
	Nonce *string `json:"nonce"`
	// ShardID
	ShardID *string `json:"shardId"`
	// Status
	Status *bool `json:"status"`
	// Successful of not
	Success *bool `json:"success"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Transaction hash
	TransactionHash *string `json:"transactionHash"`
	// Transaction type
	TransactionType *string `json:"transactionType"`
	// Validator Address
	ValidatorAddress *string `json:"validatorAddress"`
	// Value transferred in ATTO
	Value *string `json:"value"`
}

type HarmonyStakingTransactionsFilter struct {
	Date             *DateSelector                    `json:"date"`
	TransactionHash  *HashSelector                    `json:"transactionHash"`
	Ledger           *BlockSelector                   `json:"ledger"`
	TransactionType  *StakingTransactionsTypeSelector `json:"transactionType"`
	ValidatorAddress *HashSelector                    `json:"validatorAddress"`
	DelegatorAddress *HashSelector                    `json:"delegatorAddress"`
	Success          *bool                            `json:"success"`
	Status           *bool                            `json:"status"`
}

// Transactions in Harmony blockchain
type HarmonyTransactions struct {
	Any *string `json:"any"`
	// Hash of the block
	BlockHash   *string `json:"blockHash"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Transaction creates
	Creates *string `json:"creates"`
	// Data
	Data *string `json:"data"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Epoch
	Epoch *string `json:"epoch"`
	// Gas provided by the sender
	Gas *string `json:"gas"`
	// Gas price provided by the sender
	GasPrice *string `json:"gasPrice"`
	// Gas value provided by the sender
	GasValue *string `json:"gasValue"`
	// Hash of the block where this transaction was in
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The number of transactions made by the sender prior to this one
	Nonce *string `json:"nonce"`
	// Address of the reciever
	Reciever *string `json:"reciever"`
	// Address of the sender
	Sender *string `json:"sender"`
	// ShardID
	ShardID *string `json:"shardId"`
	// Status
	Status *bool `json:"status"`
	// Successful of not
	Success *bool `json:"success"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Integer of the transactions index position in the block. null when its pending.
	TransactionHash *string `json:"transactionHash"`
	// Index of the transaction
	TransactionIndex *int `json:"transactionIndex"`
	// Value transferred in ATTO
	Value *string `json:"value"`
}

type HarmonyTransactionsFilter struct {
	Date            *DateSelector  `json:"date"`
	TransactionHash *HashSelector  `json:"transactionHash"`
	Ledger          *BlockSelector `json:"ledger"`
	Sender          *HashSelector  `json:"sender"`
	Reciever        *HashSelector  `json:"reciever"`
	Success         *bool          `json:"success"`
	Status          *bool          `json:"status"`
}

// Transfers in Harmony blockchain
type HarmonyTransfers struct {
	Any *string `json:"any"`
	// Hash of the block
	BlockHash   *string `json:"blockHash"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Data
	Data *string `json:"data"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Epoch
	Epoch *string `json:"epoch"`
	// External
	External *bool `json:"external"`
	// Gas provided by the sender
	Gas *string `json:"gas"`
	// Gas price provided by the sender
	GasPrice *string `json:"gasPrice"`
	// Gas value provided by the sender
	GasValue *string `json:"gasValue"`
	// Hash of the block where this transaction was in
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The number of transactions made by the sender prior to this one
	Nonce *string `json:"nonce"`
	// Address of the sender
	Sender *string `json:"sender"`
	// ShardID
	ShardID *string `json:"shardId"`
	// Status
	Status *bool `json:"status"`
	// Successful of not
	Success *bool `json:"success"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Integer of the transactions index position in the block. null when its pending.
	TransactionHash *string `json:"transactionHash"`
	// Index of the transaction
	TransactionIndex *int `json:"transactionIndex"`
	// Address of the payer
	TransferFrom *string `json:"transferFrom"`
	// Address of the receiver
	TransferTo *string `json:"transferTo"`
	// Value transferred in ATTO
	Value *string `json:"value"`
}

type HarmonyTransfersFilter struct {
	Date            *DateSelector  `json:"date"`
	TransactionHash *HashSelector  `json:"transactionHash"`
	Ledger          *BlockSelector `json:"ledger"`
	Sender          *HashSelector  `json:"sender"`
	Success         *bool          `json:"success"`
	Status          *bool          `json:"status"`
}

// Select by hash
type HashSelector struct {
	// Hash is
	Is *string `json:"is"`
	// Hash not
	Not *string `json:"not"`
	// Hash in the list
	In []string `json:"in"`
	// Hash not in the list
	NotIn []string `json:"notIn"`
}

// Hedera Chain
type Hedera struct {
	// Blockchain Arguments
	Arguments []*HederaArgument `json:"arguments"`
	// Blockhain Calls
	Calls []*HederaCall `json:"calls"`
	// Money flow using Coinpath technology
	Coinpath []*HederaCoinpath `json:"coinpath"`
	// Blockhain Inputs
	Inputs []*HederaInput `json:"inputs"`
	// Blockhain Messages
	Messages []*HederaMessage `json:"messages"`
	// Blockchain Outputs
	Outputs []*HederaOutput `json:"outputs"`
	// Blockchain Transactions
	Transactions []*HederaTransaction `json:"transactions"`
}

// Arguments in Hedera blockchain
type HederaArgument struct {
	Any *string `json:"any"`
	// Argument type
	Argtype *string `json:"argtype"`
	// Argument
	Argument           *string    `json:"argument"`
	ChargedTxFee       *string    `json:"chargedTxFee"`
	ConsensusTimestamp *Timestamp `json:"consensusTimestamp"`
	Count              *int       `json:"count"`
	CountBigInt        *string    `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Currency of transfer
	FeeCurrency    *Currency `json:"feeCurrency"`
	InitialBalance *float64  `json:"initialBalance"`
	MaxFee         *float64  `json:"maxFee"`
	Maximum        *string   `json:"maximum"`
	Memo           *string   `json:"memo"`
	Minimum        *string   `json:"minimum"`
	// Used to reference a specific
	//       account of the node the transaction is being sent to
	NodeAccount *Account `json:"nodeAccount"`
	// Used to
	//       reference a specific account in transactions
	PayerAccount *Account `json:"payerAccount"`
	// Transaction result
	Result *TransactionResult `json:"result"`
	// Smart contract
	SmartContractEntity *Account `json:"smartContractEntity"`
	// Success
	Success          *bool    `json:"success"`
	TransactionBytes *string  `json:"transactionBytes"`
	TransactionFee   *float64 `json:"transactionFee"`
	// Transaction hash where transfer happened
	TransactionHash               *string    `json:"transactionHash"`
	TransactionValidDurationInSec *int       `json:"transactionValidDurationInSec"`
	ValidStart                    *Timestamp `json:"validStart"`
	// Value
	Value *string `json:"value"`
}

type HederaArgumentFilter struct {
	Date                *DateSelector   `json:"date"`
	NodeAccount         *StringSelector `json:"nodeAccount"`
	PayerAccount        *StringSelector `json:"payerAccount"`
	SmartContractEntity *StringSelector `json:"smartContractEntity"`
	TransactionHash     *HashSelector   `json:"transactionHash"`
	Result              *HashSelector   `json:"result"`
	Success             *bool           `json:"success"`
}

// Calls in Hedera blockchain
type HederaCall struct {
	Any *string `json:"any"`
	// Call input
	CallInput *string `json:"callInput"`
	// Call input
	CallResult         *string    `json:"callResult"`
	ChargedTxFee       *string    `json:"chargedTxFee"`
	ConsensusTimestamp *Timestamp `json:"consensusTimestamp"`
	Count              *int       `json:"count"`
	CountBigInt        *string    `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Currency of transfer
	FeeCurrency    *Currency `json:"feeCurrency"`
	Gas            *int      `json:"gas"`
	InitialBalance *float64  `json:"initialBalance"`
	MaxFee         *float64  `json:"maxFee"`
	Maximum        *string   `json:"maximum"`
	Memo           *string   `json:"memo"`
	Minimum        *string   `json:"minimum"`
	// Used to reference a specific
	//       account of the node the transaction is being sent to
	NodeAccount *Account `json:"nodeAccount"`
	// Used to
	//       reference a specific account in transactions
	PayerAccount *Account `json:"payerAccount"`
	// Transaction result
	Result *TransactionResult `json:"result"`
	// Smart contract
	SmartContractEntity *Account `json:"smartContractEntity"`
	// Success
	Success          *bool    `json:"success"`
	TransactionBytes *string  `json:"transactionBytes"`
	TransactionFee   *float64 `json:"transactionFee"`
	// Transaction hash where transfer happened
	TransactionHash               *string    `json:"transactionHash"`
	TransactionValidDurationInSec *int       `json:"transactionValidDurationInSec"`
	ValidStart                    *Timestamp `json:"validStart"`
}

type HederaCallFilter struct {
	Date                *DateSelector   `json:"date"`
	NodeAccount         *StringSelector `json:"nodeAccount"`
	PayerAccount        *StringSelector `json:"payerAccount"`
	SmartContractEntity *StringSelector `json:"smartContractEntity"`
	TransactionHash     *HashSelector   `json:"transactionHash"`
	Result              *HashSelector   `json:"result"`
	CallInput           *HashSelector   `json:"callInput"`
	CallResult          *HashSelector   `json:"callResult"`
	Success             *bool           `json:"success"`
}

// Coinpath
type HederaCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
	// Attributes of transaction included in Coinpath result
	Transactions []*CoinpathEntry `json:"transactions"`
}

// Currency selector in Hedera blockchain.
type HederaCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

// Inputs in Hedera blockchain
type HederaInput struct {
	Amount             *float64   `json:"amount"`
	Any                *string    `json:"any"`
	ConsensusTimestamp *Timestamp `json:"consensusTimestamp"`
	Count              *int       `json:"count"`
	CountBigInt        *string    `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Entity
	Entity *Entity `json:"entity"`
	// Currency of transfer
	FeeCurrency    *Currency `json:"feeCurrency"`
	InitialBalance *float64  `json:"initialBalance"`
	MaxFee         *float64  `json:"maxFee"`
	Maximum        *string   `json:"maximum"`
	Memo           *string   `json:"memo"`
	Minimum        *string   `json:"minimum"`
	// Used to reference a specific
	//       account of the node the transaction is being sent to
	NodeAccount *Account `json:"nodeAccount"`
	// Used to
	//       reference a specific account in transactions
	PayerAccount *Account `json:"payerAccount"`
	// Transaction result
	Result *TransactionResult `json:"result"`
	// Success
	Success *bool `json:"success"`
	// Calendar time
	Time           *DateTime `json:"time"`
	TransactionFee *float64  `json:"transactionFee"`
	// Transaction hash where transfer happened
	TransactionHash               *string `json:"transactionHash"`
	TransactionValidDurationInSec *int    `json:"transactionValidDurationInSec"`
	// Transfer Account
	TransferEntity *Account   `json:"transferEntity"`
	ValidStart     *Timestamp `json:"validStart"`
}

type HederaInputFilter struct {
	Date            *DateSelector       `json:"date"`
	TransferEntity  *StringSelector     `json:"transferEntity"`
	NodeAccount     *StringSelector     `json:"nodeAccount"`
	PayerAccount    *StringSelector     `json:"payerAccount"`
	TransactionHash *HashSelector       `json:"transactionHash"`
	Result          *HashSelector       `json:"result"`
	EntityType      *EntityTypeSelector `json:"entityType"`
	Success         *bool               `json:"success"`
	Amount          []*AmountSelector   `json:"amount"`
}

// Messages in Hedera blockchain
type HederaMessage struct {
	Any                *string    `json:"any"`
	ConsensusTimestamp *Timestamp `json:"consensusTimestamp"`
	Count              *int       `json:"count"`
	CountBigInt        *string    `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Entity
	Entity *Entity `json:"entity"`
	// Currency of transfer
	FeeCurrency    *Currency `json:"feeCurrency"`
	InitialBalance *float64  `json:"initialBalance"`
	MaxFee         *float64  `json:"maxFee"`
	Maximum        *string   `json:"maximum"`
	Memo           *string   `json:"memo"`
	Message        *string   `json:"message"`
	Minimum        *string   `json:"minimum"`
	// Used to reference a specific
	//       account of the node the transaction is being sent to
	NodeAccount *Account `json:"nodeAccount"`
	// Used to
	//       reference a specific account in transactions
	PayerAccount *Account `json:"payerAccount"`
	// Transaction result
	Result *TransactionResult `json:"result"`
	// Success
	Success *bool `json:"success"`
	// Calendar date time
	Time *DateTime `json:"time"`
	// Transaction running hash
	TopicRunningHash *string `json:"topicRunningHash"`
	// Transaction running hash
	TopicSequenceNumber *string  `json:"topicSequenceNumber"`
	TransactionFee      *float64 `json:"transactionFee"`
	// Transaction hash where transfer happened
	TransactionHash               *string    `json:"transactionHash"`
	TransactionValidDurationInSec *int       `json:"transactionValidDurationInSec"`
	ValidStart                    *Timestamp `json:"validStart"`
}

type HederaMessageFilter struct {
	Date                   *DateSelector       `json:"date"`
	NodeAccount            *StringSelector     `json:"nodeAccount"`
	PayerAccount           *StringSelector     `json:"payerAccount"`
	TransactionHash        *HashSelector       `json:"transactionHash"`
	TransactionRunningHash *HashSelector       `json:"transactionRunningHash"`
	Result                 *HashSelector       `json:"result"`
	EntityType             *EntityTypeSelector `json:"entityType"`
	Success                *bool               `json:"success"`
}

// Outputs in Hedera blockchain
type HederaOutput struct {
	Amount             *float64   `json:"amount"`
	Any                *string    `json:"any"`
	ConsensusTimestamp *Timestamp `json:"consensusTimestamp"`
	Count              *int       `json:"count"`
	CountBigInt        *string    `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Entity
	Entity *Entity `json:"entity"`
	// Currency of transfer
	FeeCurrency    *Currency `json:"feeCurrency"`
	InitialBalance *float64  `json:"initialBalance"`
	MaxFee         *float64  `json:"maxFee"`
	Maximum        *string   `json:"maximum"`
	Memo           *string   `json:"memo"`
	Minimum        *string   `json:"minimum"`
	// Used to reference a specific
	//       account of the node the transaction is being sent to
	NodeAccount *Account `json:"nodeAccount"`
	// Used to
	//       reference a specific account in transactions
	PayerAccount *Account `json:"payerAccount"`
	// Transaction result
	Result *TransactionResult `json:"result"`
	// Success
	Success *bool `json:"success"`
	// Calendar time
	Time           *DateTime `json:"time"`
	TransactionFee *float64  `json:"transactionFee"`
	// Transaction hash where transfer happened
	TransactionHash               *string `json:"transactionHash"`
	TransactionValidDurationInSec *int    `json:"transactionValidDurationInSec"`
	// Transfer Account
	TransferEntity *Account   `json:"transferEntity"`
	ValidStart     *Timestamp `json:"validStart"`
}

type HederaOutputFilter struct {
	Date            *DateSelector       `json:"date"`
	TransferEntity  *StringSelector     `json:"transferEntity"`
	NodeAccount     *StringSelector     `json:"nodeAccount"`
	PayerAccount    *StringSelector     `json:"payerAccount"`
	TransactionHash *HashSelector       `json:"transactionHash"`
	Result          *HashSelector       `json:"result"`
	EntityType      *EntityTypeSelector `json:"entityType"`
	Success         *bool               `json:"success"`
}

// Transactions in Hedera blockchain
type HederaTransaction struct {
	Any                *string    `json:"any"`
	ConsensusTimestamp *Timestamp `json:"consensusTimestamp"`
	Count              *int       `json:"count"`
	CountBigInt        *string    `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Entity
	Entity *Entity `json:"entity"`
	// Currency of transfer
	FeeCurrency    *Currency `json:"feeCurrency"`
	InitialBalance *float64  `json:"initialBalance"`
	MaxFee         *float64  `json:"maxFee"`
	Maximum        *string   `json:"maximum"`
	Memo           *string   `json:"memo"`
	Minimum        *string   `json:"minimum"`
	// Used to reference a specific
	//       account of the node the transaction is being sent to
	NodeAccount *Account `json:"nodeAccount"`
	// Used to
	//       reference a specific account in transactions
	PayerAccount *Account `json:"payerAccount"`
	// Transaction result
	Result *TransactionResult `json:"result"`
	// Success
	Success *bool `json:"success"`
	// Calendar time
	Time             *DateTime `json:"time"`
	TransactionBytes *string   `json:"transactionBytes"`
	TransactionFee   *float64  `json:"transactionFee"`
	// Transaction hash where transfer happened
	TransactionHash *string `json:"transactionHash"`
	// Transaction Type
	TransactionType               *string    `json:"transactionType"`
	TransactionValidDurationInSec *int       `json:"transactionValidDurationInSec"`
	ValidStart                    *Timestamp `json:"validStart"`
}

type HederaTransactionFilter struct {
	Date            *DateSelector       `json:"date"`
	NodeAccount     *StringSelector     `json:"nodeAccount"`
	PayerAccount    *StringSelector     `json:"payerAccount"`
	TransactionHash *HashSelector       `json:"transactionHash"`
	Result          *HashSelector       `json:"result"`
	EntityType      *EntityTypeSelector `json:"entityType"`
	Success         *bool               `json:"success"`
}

// Input Script Type of UTXO transaction input
type InputScript struct {
	// Script annotation
	Annotation *string `json:"annotation"`
	// Long script pattern
	Pattern string `json:"pattern"`
	// Short script pattern
	ShortPattern string `json:"shortPattern"`
	// Simple script pattern
	SimplePattern string `json:"simplePattern"`
	// Script type
	Type *BitcoinInputScriptType `json:"type"`
}

// Solana Instruction
type Instruction struct {
	Action   *Action  `json:"action"`
	CallPath *string  `json:"callPath"`
	External *bool    `json:"external"`
	Program  *Program `json:"program"`
}

// Solana Instruction
type InstructionWithExternals struct {
	Action          *Action  `json:"action"`
	CallPath        *string  `json:"callPath"`
	External        *bool    `json:"external"`
	ExternalAction  *Action  `json:"externalAction"`
	ExternalProgram *Program `json:"externalProgram"`
	Program         *Program `json:"program"`
}

// Select by ID
type IntIDSelector struct {
	// ID is
	Is *int `json:"is"`
	// ID not
	Not *int `json:"not"`
	// ID in the list
	In []int `json:"in"`
	// ID not in the list
	NotIn []int `json:"notIn"`
	// ID greater than
	Gt *int `json:"gt"`
	// ID less than
	Lt *int `json:"lt"`
	// ID less or equal than
	Lteq *int `json:"lteq"`
	// ID greater or equal than
	Gteq *int `json:"gteq"`
	// ID in range
	Between []int `json:"between"`
}

// Select limited upper number
type IntegerLimitedSelector struct {
	// is
	Is *int `json:"is"`
	// in the list
	In []int `json:"in"`
	// less than
	Lt *int `json:"lt"`
	// less or equal than
	Lteq *int `json:"lteq"`
	// in range
	Between []int `json:"between"`
}

// Select by number
type IntegerSelector struct {
	// is
	Is *int `json:"is"`
	// not
	Not *int `json:"not"`
	// in the list
	In []int `json:"in"`
	// not in the list
	NotIn []int `json:"notIn"`
	// greater than
	Gt *int `json:"gt"`
	// less than
	Lt *int `json:"lt"`
	// less or equal than
	Lteq *int `json:"lteq"`
	// greater or equal than
	Gteq *int `json:"gteq"`
	// in range
	Between []int `json:"between"`
}

// Libra
type Libra struct {
	// Libra Network Blocks
	Blocks []*LibraBlock `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*LibraCoinpath `json:"coinpath"`
	// Libra Network Currency Minting
	Mints []*LibraMints `json:"mints"`
	// Libra Network Transactions
	Transactions []*LibraTransactions `json:"transactions"`
	// Libra Network Currency Transfers
	Transfers []*LibraTransfers `json:"transfers"`
}

// Block
type LibraBlock struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date    *Date    `json:"date"`
	GasUsed *float64 `json:"gasUsed"`
	// Block round in blockchain
	Height int `json:"height"`
	// Key
	Key     *string `json:"key"`
	Maximum *string `json:"maximum"`
	// Metadata
	Metadata *string `json:"metadata"`
	Minimum  *string `json:"minimum"`
	// Proposer
	Proposer *Address `json:"proposer"`
	// Sequence number
	SequenceNumber *int `json:"sequenceNumber"`
	// Status Name
	StatusName *string `json:"statusName"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Version of transaction for this block
	Version int `json:"version"`
	// Version hash of transaction for this block
	VersionHash string `json:"versionHash"`
	// VM Status
	VMStatus *int `json:"vmStatus"`
}

type LibraBlockFilter struct {
	Date     *DateSelector      `json:"date"`
	Time     *DateTimeSelector  `json:"time"`
	Height   *BlockSelector     `json:"height"`
	Version  *IntegerSelector   `json:"version"`
	Proposer []*AddressSelector `json:"proposer"`
	Metadata *StringSelector    `json:"metadata"`
}

// Coinpath
type LibraCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *Address `json:"receiver"`
	// Sender address
	Sender *Address `json:"sender"`
	// Transaction of transfer happened
	Transaction *LibraTransactionValue `json:"transaction"`
}

// Currency selector in Libra blockchain.
// Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
// Use name of currency for selection
type LibraCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

type LibraMintFilter struct {
	Date     *DateSelector            `json:"date"`
	Time     *DateTimeSelector        `json:"time"`
	Block    *BlockSelector           `json:"block"`
	Version  *IntegerSelector         `json:"version"`
	Minter   *AddressSelector         `json:"minter"`
	Currency []*LibraCurrencySelector `json:"currency"`
	Amount   []*AmountSelector        `json:"amount"`
}

// Mints in Libra blockchain
type LibraMints struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Minter
	Minter *Address `json:"minter"`
	// Sequence number
	SequenceNumber *int `json:"sequenceNumber"`
	// Status Name
	StatusName *string `json:"statusName"`
	// Success
	Success *bool `json:"success"`
	// Mint timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Version of blockchain for this transaction
	Version int `json:"version"`
	// Version hash of blockchain for this transaction
	VersionHash string `json:"versionHash"`
	// VM Status
	VMStatus *int `json:"vmStatus"`
}

type LibraTransactionFilter struct {
	Date        *DateSelector               `json:"date"`
	Time        *DateTimeSelector           `json:"time"`
	Height      *BlockSelector              `json:"height"`
	Version     *IntegerSelector            `json:"version"`
	TxSender    *AddressSelector            `json:"txSender"`
	ScriptType  *ScriptTypeSelectorSelector `json:"scriptType"`
	Success     *bool                       `json:"success"`
	GasCurrency []*LibraCurrencySelector    `json:"gasCurrency"`
	ScriptHash  *StringSelector             `json:"scriptHash"`
}

// Blockchain transaction with value
type LibraTransactionValue struct {
	// Transaction value
	Value float64 `json:"value"`
	// Transaction version
	Version int `json:"version"`
}

// Transactions in Libra blockchain
type LibraTransactions struct {
	Any *string `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Expiration Time
	ExpirationTime *DateTime `json:"expirationTime"`
	Gas            *int      `json:"gas"`
	// Currency of gas
	GasCurrency *Currency `json:"gasCurrency"`
	// Gas unit price
	GasPrice float64  `json:"gasPrice"`
	GasValue *float64 `json:"gasValue"`
	// Max gas amount
	MaxGasAmount *int    `json:"maxGasAmount"`
	Maximum      *string `json:"maximum"`
	Minimum      *string `json:"minimum"`
	// Public key
	PublicKey *string `json:"publicKey"`
	// Script Hash
	ScriptHash *string `json:"scriptHash"`
	// Script Type
	ScriptType *ScriptTypeSelectorSelector `json:"scriptType"`
	// Transaction sender
	Sender *Address `json:"sender"`
	// Sequence number
	SequenceNumber *int `json:"sequenceNumber"`
	// Signature
	Signature *string `json:"signature"`
	// Signature scheme
	SignatureScheme *string `json:"signatureScheme"`
	// Status Name
	StatusName *string `json:"statusName"`
	// Success
	Success *bool `json:"success"`
	// Transaction timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Version of blockchain for this transaction
	Version int `json:"version"`
	// Version hash of blockchain for this transaction
	VersionHash string `json:"versionHash"`
	// VM Status
	VMStatus *int `json:"vmStatus"`
}

type LibraTransferFilter struct {
	Date        *DateSelector               `json:"date"`
	Time        *DateTimeSelector           `json:"time"`
	Height      *BlockSelector              `json:"height"`
	Version     *IntegerSelector            `json:"version"`
	TxSender    *AddressSelector            `json:"txSender"`
	Sender      *AddressSelector            `json:"sender"`
	Receiver    *AddressSelector            `json:"receiver"`
	Currency    []*LibraCurrencySelector    `json:"currency"`
	GasCurrency []*LibraCurrencySelector    `json:"gasCurrency"`
	Amount      []*AmountSelector           `json:"amount"`
	ScriptType  *ScriptTypeSelectorSelector `json:"scriptType"`
	ScriptHash  *StringSelector             `json:"scriptHash"`
}

// Transfers in Libra blockchain
type LibraTransfers struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *Block  `json:"block"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date *Date `json:"date"`
	// Expiration Time
	ExpirationTime *DateTime `json:"expirationTime"`
	Gas            *int      `json:"gas"`
	// Currency of gas
	GasCurrency *Currency `json:"gasCurrency"`
	// Gas price
	GasPrice float64  `json:"gasPrice"`
	GasValue *float64 `json:"gasValue"`
	// Max gas amount
	MaxGasAmount *int    `json:"maxGasAmount"`
	Maximum      *string `json:"maximum"`
	Minimum      *string `json:"minimum"`
	// Public key
	PublicKey *string `json:"publicKey"`
	// Transfer receiver
	Receiver *Address `json:"receiver"`
	// Script Hash
	ScriptHash *string `json:"scriptHash"`
	// Script Type
	ScriptType *ScriptTypeSelectorSelector `json:"scriptType"`
	// Transfer sender
	Sender *Address `json:"sender"`
	// Sequence number
	SequenceNumber *int `json:"sequenceNumber"`
	// Signature
	Signature *string `json:"signature"`
	// Signature scheme
	SignatureScheme *string `json:"signatureScheme"`
	// Status Name
	StatusName *string `json:"statusName"`
	// Success
	Success *bool `json:"success"`
	// Transfer timestamp
	Timestamp *DateTime `json:"timestamp"`
	// Transaction sender
	TxSender *Address `json:"txSender"`
	// Version of blockchain for this transaction
	Version int `json:"version"`
	// Version hash of blockchain for this transaction
	VersionHash string `json:"versionHash"`
	// VM Status
	VMStatus *int `json:"vmStatus"`
}

// Limit by definition
type LimitByOption struct {
	// Take limit for each combination of the field
	Each string `json:"each"`
	// Limit number of results
	Limit *int `json:"limit"`
	// Offset of results, starting from 0
	Offset *int `json:"offset"`
}

// Solana Log
type Log struct {
	Consumed    string `json:"consumed"`
	Instruction string `json:"instruction"`
	Logs        string `json:"logs"`
	Result      string `json:"result"`
	TotalGas    string `json:"totalGas"`
}

// Smart contract method
type Method struct {
	// Name
	Name *string `json:"name"`
	// Signature
	Signature *string `json:"signature"`
	// Signature Hash
	SignatureHash string `json:"signatureHash"`
}

func (Method) IsSignature() {}

// Smart contract method. In selector you can use the name, signature or hex hash
type MethodSelector struct {
	// Method signature is
	Is *string `json:"is"`
	// Method signature not
	Not *string `json:"not"`
	// Method signature in the list
	In []string `json:"in"`
	// Method signature not in the list
	NotIn []string `json:"notIn"`
}

// Information about miniblock
type MiniblockElrond struct {
	// Miniblock hash
	Hash *string `json:"hash"`
	// Hash of the receiver block
	ReceiverBlockHash *string `json:"receiverBlockHash"`
	// Number of the receiver shard
	ReceiverShard *string `json:"receiverShard"`
	// Miniblock type
	Type *string `json:"type"`
}

// Name with an identifier
type NameWithID struct {
	// ID
	ID *int `json:"id"`
	// Name
	Name *string `json:"name"`
}

// Offchain Data
type Offchain struct {
	// Historical COVID data
	Covid *CovidHistory `json:"covid"`
}

// Select order by ID
type OrderIDSelector struct {
	// Order ID is
	Is *string `json:"is"`
	// Order ID not
	Not *string `json:"not"`
	// Order ID in the list
	In []string `json:"in"`
	// Order ID not in the list
	NotIn []string `json:"notIn"`
}

// Select by order side
type OrderSideSelector struct {
	// Order Side is
	Is *BinanceOrderSide `json:"is"`
	// Order Side not
	Not *BinanceOrderSide `json:"not"`
	// Order Side in the list
	In []BinanceOrderSide `json:"in"`
	// Order Side not in the list
	NotIn []BinanceOrderSide `json:"notIn"`
}

// Select by order status
type OrderStatusSelector struct {
	// Order Status is
	Is *BinanceOrderStatus `json:"is"`
	// Order Status not
	Not *BinanceOrderStatus `json:"not"`
	// Order Status in the list
	In []BinanceOrderStatus `json:"in"`
	// Order Status not in the list
	NotIn []BinanceOrderStatus `json:"notIn"`
}

// Select by order time in force
type OrderTimeInForceSelector struct {
	// Order TimeInForce is
	Is *BinanceOrderTimeInForce `json:"is"`
	// Order TimeInForce not
	Not *BinanceOrderTimeInForce `json:"not"`
	// Order TimeInForce in the list
	In []BinanceOrderTimeInForce `json:"in"`
	// Order TimeInForce not in the list
	NotIn []BinanceOrderTimeInForce `json:"notIn"`
}

// Select by order type
type OrderTypeSelector struct {
	// Order Type is
	Is *BinanceOrderType `json:"is"`
	// Order Type not
	Not *BinanceOrderType `json:"not"`
	// Order Type in the list
	In []BinanceOrderType `json:"in"`
	// Order Type not in the list
	NotIn []BinanceOrderType `json:"notIn"`
}

// Select by output index ( o based )
type OutputIndexSelector struct {
	// Output index is
	Is *int `json:"is"`
	// Output index not
	Not *int `json:"not"`
	// Output index in the list
	In []int `json:"in"`
	// Output index not in the list
	NotIn []int `json:"notIn"`
	// Output index greater than
	Gt *int `json:"gt"`
	// Output index less than
	Lt *int `json:"lt"`
	// Output index less or equal than
	Lteq *int `json:"lteq"`
	// Output index greater or equal than
	Gteq *int `json:"gteq"`
	// Output index in range
	Between []int `json:"between"`
}

// Output Script Type of UTXO transaction output
type OutputScript struct {
	// Script annotation
	Annotation *string `json:"annotation"`
	// Long script pattern
	Pattern string `json:"pattern"`
	// Short script pattern
	Short string `json:"short"`
	// Simple script pattern
	SimplePattern string `json:"simplePattern"`
	// Script type
	Type *BitcoinOutputScriptType `json:"type"`
}

// Solana Program
type Program struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	Parsed     bool   `json:"parsed"`
	ParsedName string `json:"parsedName"`
}

// Limits, Ordering, Constraints
type QueryOptions struct {
	// Limit number of results
	Limit *int `json:"limit"`
	// Limit number of results by specific field
	LimitBy *LimitByOption `json:"limitBy"`
	// Offset of results, starting from 0
	Offset *int `json:"offset"`
	// Ordering field(s) for ascending
	Asc []string `json:"asc"`
	// Ordering field(s) for descending
	Desc []string `json:"desc"`
}

// Solana Receiver
type Receiver struct {
	Address     string `json:"address"`
	MintAccount string `json:"mintAccount"`
	Type        string `json:"type"`
}

// Search result item
type Result struct {
	// Blockchain where result is found
	Network *BlockchainNetwork `json:"network"`
	// Subject in blockchain
	Subject Subject `json:"subject"`
}

// Select by reward type
type RewardTypeSelector struct {
	// Type is
	Is *SolanaRewardType `json:"is"`
	// Type not
	Not *SolanaRewardType `json:"not"`
	// Type in the list
	In []SolanaRewardType `json:"in"`
	// Type not in the list
	NotIn []SolanaRewardType `json:"notIn"`
}

// Ripple Chain
type Ripple struct {
	// The Escrow object type represents a held payment of XRP waiting to be executed or canceled
	AccountRoots []*RippleAccountRoots `json:"accountRoots"`
	// Ripple Balances
	Balances []*RippleBalances `json:"balances"`
	// Ripple Blocks
	Blocks []*RippleBlocks `json:"blocks"`
	// A check that can be redeemed for money by its destination.
	Checks []*RippleChecks `json:"checks"`
	// The Escrow object type represents a held payment of XRP waiting to be executed or canceled
	Escrows []*RippleEscrows `json:"escrows"`
	// An order to make a currency trade.
	Offers []*RippleOffers `json:"offers"`
	// Ripple Payments
	Payments []*RipplePayments `json:"payments"`
	// The RippleState object type connects two accounts in a single currency
	RippleStates []*RippleRippleStates `json:"rippleStates"`
	// Ripple Transactions
	Transactions []*RippleTransactions `json:"transactions"`
	// Ripple Transfers
	Transfers []*RippleTransfers `json:"transfers"`
}

// The AccountRoot object type describes a single account, its settings, and XRP balance.
type RippleAccountRoots struct {
	// The identifying (classic) address of this account.
	Account *string `json:"account"`
	Any     *string `json:"any"`
	// The account`s current XRP balance in drops, represented as a string.
	Balance *string `json:"balance"`
	// Number of block in the blockchains
	BlockHeight *string `json:"blockHeight"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// domain associated with this account. In JSON, this is the hexadecimal for the ASCII representation of the domain
	Domain *string `json:"domain"`
	// 	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
	Flags   *string `json:"flags"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Operation
	Operation *string `json:"operation"`
	// The number of objects this account owns in the ledger, which contributes to its owner reserve.
	OwnerCount *int `json:"ownerCount"`
	// Previous Balance
	PrevBalance *string `json:"prevBalance"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnID *string `json:"previousTxnId"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnLedgerSeq *string `json:"previousTxnLedgerSeq"`
	// The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.)
	Sequence *string `json:"sequence"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Type of transaction
	TransactionType *string `json:"transactionType"`
	// A transfer fee  to charge other users for sending currency issued by this account to each other.
	TransferRate *string `json:"transferRate"`
}

type RippleAccountRootsFilter struct {
	Date                 *DateSelector    `json:"date"`
	BlockHeight          *BlockSelector   `json:"blockHeight"`
	Account              *HashSelector    `json:"account"`
	TransactionType      *TypeSelector    `json:"transactionType"`
	Operation            *HashSelector    `json:"operation"`
	PrevBalance          *IntegerSelector `json:"prevBalance"`
	Balance              *IntegerSelector `json:"balance"`
	Domain               *StringSelector  `json:"domain"`
	OwnerCount           *IntegerSelector `json:"ownerCount"`
	TransferRate         *IntegerSelector `json:"transferRate"`
	Sequence             *IntegerSelector `json:"sequence"`
	PreviousTxnID        *HashSelector    `json:"previousTxnId"`
	PreviousTxnLedgerSeq *IntegerSelector `json:"previousTxnLedgerSeq"`
	Flags                *IntegerSelector `json:"flags"`
}

// Balances in Ripple blockchain
type RippleBalances struct {
	// Account
	Account     *string  `json:"account"`
	Any         *string  `json:"any"`
	Balance     *float64 `json:"balance"`
	Count       *int     `json:"count"`
	CountBigInt *string  `json:"countBigInt"`
	// Currency
	Currency *Currency `json:"currency"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Previous Ledge Seq
	Flags *string `json:"flags"`
	// Issuer
	Issuer *string `json:"issuer"`
	// Block number
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Previous Balance
	PrevBalance *float64 `json:"prevBalance"`
	// Previous Ledger Seq
	PrevLedgerSeq *string `json:"prevLedgerSeq"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Transaction hash
	TransactionHash *string `json:"transactionHash"`
	// Transaction Sender
	TransactionSender *string `json:"transactionSender"`
	// Transaction type
	TransactionType *string `json:"transactionType"`
}

type RippleBalancesFilter struct {
	Date              *DateSelector  `json:"date"`
	TransactionHash   *HashSelector  `json:"transactionHash"`
	Ledger            *BlockSelector `json:"ledger"`
	TransactionSender *HashSelector  `json:"transactionSender"`
	Account           *HashSelector  `json:"account"`
	Issuer            *HashSelector  `json:"issuer"`
	PrevBalance       *HashSelector  `json:"prevBalance"`
	PrevLedgerSeq     *HashSelector  `json:"prevLedgerSeq"`
	Flags             *HashSelector  `json:"flags"`
}

// Blocks in Ripple blockchain
type RippleBlocks struct {
	// Hash of this ledger`s state tree information.
	AccountHash *string `json:"accountHash"`
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Block number
	Ledger *string `json:"ledger"`
	// This serves as a unique identifier for this ledger and all its contents.
	LedgerHash *string `json:"ledgerHash"`
	Maximum    *string `json:"maximum"`
	Minimum    *string `json:"minimum"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// The total number of drops of XRP owned by accounts in the ledger.
	TotalCoins *string `json:"totalCoins"`
	// Transaction hash
	TransactionHash *string `json:"transactionHash"`
}

type RippleBlocksFilter struct {
	Date            *DateSelector  `json:"date"`
	TransactionHash *HashSelector  `json:"transactionHash"`
	LedgerHash      *HashSelector  `json:"ledgerHash"`
	Ledger          *BlockSelector `json:"ledger"`
	AccountHash     *HashSelector  `json:"accountHash"`
}

// Checks in Ripple blockchain
type RippleChecks struct {
	Any *string `json:"any"`
	// Number of block in the blockchains
	BlockHeight *string `json:"blockHeight"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// The destination address where the XRP is paid if the held payment is successful.
	Destination *string `json:"destination"`
	// An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address.
	DestinationTag *string `json:"destinationTag"`
	// Indicates the time after which this Check is considered expired.
	Expiration *string `json:"expiration"`
	// A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
	Flags *string `json:"flags"`
	// The time after which this held payment can be finished
	InvoiceID *string `json:"invoiceId"`
	Maximum   *string `json:"maximum"`
	Minimum   *string `json:"minimum"`
	// Operation
	Operation *string `json:"operation"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnID *string `json:"previousTxnId"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnLedgerSeq *string `json:"previousTxnLedgerSeq"`
	// The maximum amount of currency this Check can debit the sender.
	SendMax *string `json:"sendMax"`
	// The sender of the Check. Cashing the Check debits this address`s balance.
	Sender *string `json:"sender"`
	// The sequence number of the CheckCreate transaction that created this check.
	Sequence *string `json:"sequence"`
	// An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address.
	SourceTag *string `json:"sourceTag"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Type of transaction
	TransactionType *string `json:"transactionType"`
}

type RippleChecksFilter struct {
	Date                 *DateSelector    `json:"date"`
	BlockHeight          *BlockSelector   `json:"blockHeight"`
	Sender               *HashSelector    `json:"sender"`
	TransactionType      *HashSelector    `json:"transactionType"`
	Operation            *StringSelector  `json:"operation"`
	Destination          *HashSelector    `json:"destination"`
	SendMax              *IntegerSelector `json:"sendMax"`
	Expiration           *IntegerSelector `json:"expiration"`
	InvoiceID            *IntegerSelector `json:"invoiceId"`
	SourceTag            *IntegerSelector `json:"sourceTag"`
	DestinationTag       *IntegerSelector `json:"destinationTag"`
	Sequence             *IntegerSelector `json:"sequence"`
	PreviousTxnID        *IntegerSelector `json:"previousTxnId"`
	PreviousTxnLedgerSeq *IntegerSelector `json:"previousTxnLedgerSeq"`
	Flags                *IntegerSelector `json:"flags"`
}

// Escrows in Ripple blockchain
type RippleEscrows struct {
	// The amount of XRP, in drops, to be delivered by the held payment.
	Amount *string `json:"amount"`
	Any    *string `json:"any"`
	// Number of block in the blockchains
	BlockHeight *string `json:"blockHeight"`
	// The held payment can be canceled if and only if this field is present and the time it specifies has passed
	CancelAfter *string `json:"cancelAfter"`
	// Crypto condition as hexadecimal. If present, the EscrowFinish transaction must contain a fulfillment that satisfies this condition.
	Condition   *string `json:"condition"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// The destination address where the XRP is paid if the held payment is successful.
	Destination *string `json:"destination"`
	// An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address.
	DestinationTag *string `json:"destinationTag"`
	// The time after which this held payment can be finished
	FinishedAfter *string `json:"finishedAfter"`
	// 	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
	Flags   *string `json:"flags"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Operation
	Operation *string `json:"operation"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnID *string `json:"previousTxnId"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnLedgerSeq *string `json:"previousTxnLedgerSeq"`
	// The address of the owner (sender) of this held payment
	Sender *string `json:"sender"`
	// An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address.
	SourceTag *string `json:"sourceTag"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Type of transaction
	TransactionType *string `json:"transactionType"`
}

type RippleEscrowsFilter struct {
	Date                 *DateSelector    `json:"date"`
	BlockHeight          *BlockSelector   `json:"blockHeight"`
	Sender               *HashSelector    `json:"sender"`
	TransactionType      *TypeSelector    `json:"transactionType"`
	Operation            *HashSelector    `json:"operation"`
	Destination          *HashSelector    `json:"destination"`
	Amount               *IntegerSelector `json:"amount"`
	Condition            *HashSelector    `json:"condition"`
	CancelAfter          *IntegerSelector `json:"cancelAfter"`
	FinishedAfter        *IntegerSelector `json:"finishedAfter"`
	SourceTag            *IntegerSelector `json:"sourceTag"`
	DestinationTag       *IntegerSelector `json:"destinationTag"`
	PreviousTxnID        *IntegerSelector `json:"previousTxnId"`
	PreviousTxnLedgerSeq *IntegerSelector `json:"previousTxnLedgerSeq"`
	Flags                *IntegerSelector `json:"flags"`
}

// Offers in Ripple blockchain
type RippleOffers struct {
	Any *string `json:"any"`
	// Book Directory
	BookDirectory *string `json:"bookDirectory"`
	Count         *int    `json:"count"`
	CountBigInt   *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Expiration
	Expiration *string `json:"expiration"`
	// Flags
	Flags *string `json:"flags"`
	// Block number
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Operation
	Operation *string `json:"operation"`
	// Sequence
	Sequence  *float64 `json:"sequence"`
	TakerGets *string  `json:"takerGets"`
	// Taker Gets Currency
	TakerGetsCurrency *Currency `json:"takerGetsCurrency"`
	TakerPays         *string   `json:"takerPays"`
	// Taker Pays Currency
	TakerPaysCurrency *Currency `json:"takerPaysCurrency"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Transaction hash
	TransactionHash *string `json:"transactionHash"`
	// Transaction Sender
	TransactionSender *string `json:"transactionSender"`
	// Transaction type
	TransactionType *string `json:"transactionType"`
}

type RippleOffersFilter struct {
	Date              *DateSelector  `json:"date"`
	Ledger            *BlockSelector `json:"ledger"`
	TransactionHash   *HashSelector  `json:"transactionHash"`
	TransactionSender *HashSelector  `json:"transactionSender"`
	TransactionType   *HashSelector  `json:"transactionType"`
	Sequence          *HashSelector  `json:"sequence"`
	BookDirectory     *HashSelector  `json:"bookDirectory"`
	Account           *HashSelector  `json:"account"`
}

// Payments in Ripple blockchain
type RipplePayments struct {
	// Amount Currency
	AmountCurrency *Currency `json:"amountCurrency"`
	// Amount Issuer
	AmountIssuer *string  `json:"amountIssuer"`
	AmountValue  *float64 `json:"amountValue"`
	Any          *string  `json:"any"`
	Count        *int     `json:"count"`
	CountBigInt  *string  `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Delivered min currency
	DeliverMinCurrency *Currency `json:"deliverMinCurrency"`
	// Delivered Min Issuer
	DeliverMinIssuer *string  `json:"deliverMinIssuer"`
	DeliverMinValue  *float64 `json:"deliverMinValue"`
	// Currency of the money sender's transfer
	DeliveredCurrency *Currency `json:"deliveredCurrency"`
	// Delivered Value
	DeliveredIssuer *string  `json:"deliveredIssuer"`
	DeliveredValue  *float64 `json:"deliveredValue"`
	// Flags
	Flags *string `json:"flags"`
	// Invoice
	Invoice *string `json:"invoice"`
	// Block number
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Partial
	Partial *string `json:"partial"`
	// Currency of the money sender's transfer
	SendMaxCurrency *Currency `json:"sendMaxCurrency"`
	// Send Max Issuer
	SendMaxIssuer *string  `json:"sendMaxIssuer"`
	SendMaxValue  *float64 `json:"sendMaxValue"`
	// Tag
	Tag *string `json:"tag"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Transaction hash
	TransactionHash *string `json:"transactionHash"`
	// Transfer from
	TransferFrom *string `json:"transferFrom"`
	// Transfer to
	TransferTo *string `json:"transferTo"`
}

type RipplePaymentsFilter struct {
	Date             *DateSelector  `json:"date"`
	Ledger           *BlockSelector `json:"ledger"`
	TransferTo       *HashSelector  `json:"transferTo"`
	TransferFrom     *HashSelector  `json:"transferFrom"`
	AmountIssuer     *HashSelector  `json:"amountIssuer"`
	DeliverIssuer    *HashSelector  `json:"deliverIssuer"`
	SendMaxIssuer    *HashSelector  `json:"sendMaxIssuer"`
	DeliverMinIssuer *HashSelector  `json:"deliverMinIssuer"`
	Tag              *HashSelector  `json:"tag"`
	TransactionHash  *HashSelector  `json:"transactionHash"`
}

// The RippleState object type connects two accounts in a single currency
type RippleRippleStates struct {
	Any     *string  `json:"any"`
	Balance *float64 `json:"balance"`
	// Number of block in the blockchains
	BlockHeight *string `json:"blockHeight"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// 	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
	Flags *string `json:"flags"`
	// High Account
	HighAccount *string `json:"highAccount"`
	// Low Account
	LowAccount *string `json:"lowAccount"`
	Maximum    *string `json:"maximum"`
	Minimum    *string `json:"minimum"`
	// Operation
	Operation *string `json:"operation"`
	// Previous Balance
	PreBalance *string `json:"preBalance"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnID *string `json:"previousTxnId"`
	// The identifying hash of the transaction that most recently modified this object.
	PreviousTxnLedgerSeq *string `json:"previousTxnLedgerSeq"`
	// The address of the owner (sender) of this held payment
	Sender *string `json:"sender"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Type of transaction
	TransactionType *string `json:"transactionType"`
}

type RippleStatesFilter struct {
	Date                 *DateSelector    `json:"date"`
	BlockHeight          *BlockSelector   `json:"blockHeight"`
	Sender               *HashSelector    `json:"sender"`
	TransactionType      *HashSelector    `json:"transactionType"`
	Operation            *StringSelector  `json:"operation"`
	LowAccount           *HashSelector    `json:"lowAccount"`
	HighAccount          *HashSelector    `json:"highAccount"`
	Balance              *IntegerSelector `json:"balance"`
	PreBalance           *IntegerSelector `json:"preBalance"`
	PreviousTxnID        *IntegerSelector `json:"previousTxnId"`
	PreviousTxnLedgerSeq *IntegerSelector `json:"previousTxnLedgerSeq"`
	Flags                *IntegerSelector `json:"flags"`
}

// Transactions in Ripple blockchain
type RippleTransactions struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// A transactions Flags field can contain flags that apply at different levels or contexts.
	Flags *string `json:"flags"`
	// Index in ledger
	IndexInLedger *string `json:"indexInLedger"`
	// Highest ledger index this transaction can appear in.
	LastLedgerSequence *float64 `json:"lastLedgerSequence"`
	// Block number
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	// Additional arbitrary information used to identify this transaction.
	Memos   *string `json:"memos"`
	Minimum *string `json:"minimum"`
	// Result
	Result *string `json:"result"`
	// Transaction Sender
	Sender *string `json:"sender"`
	// The sequence number of the account sending the transaction.
	Sequence *float64 `json:"sequence"`
	// Successful of not
	Status *bool `json:"status"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Transaction fee
	TransactionFee *float64 `json:"transactionFee"`
	// Transaction hash
	TransactionHash *string `json:"transactionHash"`
	// Transaction type
	TransactionType *string `json:"transactionType"`
}

type RippleTransactionsFilter struct {
	Date               *DateSelector            `json:"date"`
	TransactionHash    *HashSelector            `json:"transactionHash"`
	TransactionType    *TransactionTypeSelector `json:"transactionType"`
	TransactionFee     *TransactionTypeSelector `json:"transactionFee"`
	Ledger             *BlockSelector           `json:"ledger"`
	Sender             *HashSelector            `json:"sender"`
	Sequence           *HashSelector            `json:"sequence"`
	Result             *HashSelector            `json:"result"`
	LastLedgerSequence *HashSelector            `json:"lastLedgerSequence"`
	Status             *bool                    `json:"status"`
}

// Transfers in Ripple blockchain
type RippleTransfers struct {
	Any *string `json:"any"`
	// Number of block in the blockchains
	BlockHeight *string `json:"blockHeight"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Currency of the money sender's transfer
	CurrencyFrom *Currency `json:"currencyFrom"`
	// Currency of the money receiver's transfer
	CurrencyTo *Currency `json:"currencyTo"`
	// The date this transaction was created
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The sender of the Check. Cashing the Check debits this address`s balance.
	Sender *string `json:"sender"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Transaction Hash
	TransactionHash *string `json:"transactionHash"`
	// Transfer From
	TransferFrom *string `json:"transferFrom"`
	// Transfer To
	TransferTo *string  `json:"transferTo"`
	ValueFrom  *float64 `json:"valueFrom"`
	ValueTo    *float64 `json:"valueTo"`
}

type RippleTransfersFilter struct {
	Date            *DateSelector   `json:"date"`
	BlockHeight     *BlockSelector  `json:"blockHeight"`
	Sender          *HashSelector   `json:"sender"`
	TransactionType *StringSelector `json:"transactionType"`
	TransactionHash *HashSelector   `json:"transactionHash"`
	TransferFrom    *HashSelector   `json:"transferFrom"`
	TransferTo      *HashSelector   `json:"transferTo"`
}

// Solana Sender
type Sender struct {
	Address     string `json:"address"`
	MintAccount string `json:"mintAccount"`
	Type        string `json:"type"`
}

// Blockchain smart contract
type SmartContract struct {
	// String address representation
	Address *string `json:"address"`
	// Annotations ( tags ), if exists
	Annotation *string `json:"annotation"`
	// Smart Contract Type
	ContractType SmartContractType `json:"contractType"`
	// Smart Contract Protocol Type
	Protocol *string `json:"protocol"`
}

func (SmartContract) IsSubject() {}

type SmartContractReadonlyAttribute struct {
	// Value as address if applicable
	Address *EthereumAddressInfo `json:"address"`
	// Method name
	Name string `json:"name"`
	// Method return type
	Type string `json:"type"`
	// Method return value
	Value string `json:"value"`
}

// Selector of smart contract type
type SmartContractTypeSelector struct {
	// Smart Contract type is
	Is *SmartContractType `json:"is"`
	// Smart Contract type not
	Not *SmartContractType `json:"not"`
	// Smart Contract type in the list
	In []SmartContractType `json:"in"`
	// Smart Contract type not in the list
	NotIn []SmartContractType `json:"notIn"`
}

// Solana Chain
type Solana struct {
	// BlockRewards of Smart Contract Calls and Events
	BlockRewards []*SolanaBlockReward `json:"blockRewards"`
	// Solana Blocks
	Blocks []*SolanaBlock `json:"blocks"`
	// Each instruction specifies a single program, a subset of the transaction`s accounts
	//         that should be passed to the program.
	InstructionAccounts []*SolanaInstructionAccount `json:"instructionAccounts"`
	// Each instruction specifies a single program, a subset of the transaction`s accounts
	//         that should be passed to the program.
	Instructions []*SolanaInstruction `json:"instructions"`
	// Solana Transaction
	Transactions []*SolanaTransaction `json:"transactions"`
	// Currency transfers from/to addresses in crypto currencies
	Transfers []*SolanaTransfer `json:"transfers"`
}

// Solana Account
type SolanaAccount struct {
	Index int    `json:"index"`
	Name  string `json:"name"`
	Owner string `json:"owner"`
	Type  string `json:"type"`
}

// Block in Solana  blockchain
type SolanaBlock struct {
	Any *string `json:"any"`
	// Hash of the the block
	BlockHash   *string `json:"blockHash"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Number of block in the blockchains
	Height  *string `json:"height"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// The slot index of this block`s parent
	ParentSlot *string `json:"parentSlot"`
	// The block hash of this block`s parent
	PreviousBlockHash *string  `json:"previousBlockHash"`
	Rewards           *float64 `json:"rewards"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Count of transactions in this block
	TransactionCount *int `json:"transactionCount"`
}

type SolanaBlockFilter struct {
	Date              *DateSelector    `json:"date"`
	BlockHash         *HashSelector    `json:"blockHash"`
	Height            *BlockSelector   `json:"height"`
	PreviousBlockHash *HashSelector    `json:"previousBlockHash"`
	ParentSlot        *IntegerSelector `json:"parentSlot"`
	TransactionCount  *IntegerSelector `json:"transactionCount"`
	Rewards           *AmountSelector  `json:"rewards"`
}

// Solana Block Info
type SolanaBlockInfo struct {
	// Hash hex representation
	Hash string `json:"hash"`
	// Block number (height) in blockchain
	Height            int     `json:"height"`
	ParentSlot        *string `json:"parentSlot"`
	PreviousBlockHash *string `json:"previousBlockHash"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
}

// BlockReward in Solana  blockchain
type SolanaBlockReward struct {
	// Account
	Account *string  `json:"account"`
	Amount  *float64 `json:"amount"`
	Any     *string  `json:"any"`
	// Block where  transaction is included
	Block       *SolanaBlockInfo `json:"block"`
	Count       *int             `json:"count"`
	CountBigInt *string          `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// The date this transaction was created
	Date        *Date    `json:"date"`
	Maximum     *string  `json:"maximum"`
	Minimum     *string  `json:"minimum"`
	PostBalance *float64 `json:"postBalance"`
	// Type of reward
	RewardType *string `json:"rewardType"`
}

type SolanaBlockRewardFilter struct {
	Date              *DateSelector       `json:"date"`
	BlockHash         *HashSelector       `json:"blockHash"`
	Height            *BlockSelector      `json:"height"`
	PreviousBlockHash *HashSelector       `json:"previousBlockHash"`
	Reward            *AmountSelector     `json:"reward"`
	ParentSlot        *IntegerSelector    `json:"parentSlot"`
	PostBalance       *AmountSelector     `json:"postBalance"`
	Account           *StringSelector     `json:"account"`
	RewardType        *RewardTypeSelector `json:"rewardType"`
}

// Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol
type SolanaCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

// Instruction in Solana  blockchain
type SolanaInstruction struct {
	// Accounts count
	AccountsCount *int `json:"accountsCount"`
	// Action
	Action *Action `json:"action"`
	Any    *string `json:"any"`
	// Block where  transaction is included
	Block *SolanaBlockInfo `json:"block"`
	// Call Path
	CallPath    *string `json:"callPath"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Instruction Data
	Data *Data `json:"data"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// External
	External *bool `json:"external"`
	// External Action
	ExternalAction *Action `json:"externalAction"`
	// External Program
	ExternalProgram *Program `json:"externalProgram"`
	Log             *Log     `json:"log"`
	Maximum         *string  `json:"maximum"`
	Minimum         *string  `json:"minimum"`
	// Program
	Program *Program `json:"program"`
	// Transaction where instruction is included
	Transaction *SolanaTransactionInfo `json:"transaction"`
}

// InstructionAccount in Solana  blockchain
type SolanaInstructionAccount struct {
	// Information about account
	Account *SolanaAccount `json:"account"`
	Any     *string        `json:"any"`
	// Block where transfer transaction is included
	Block       *SolanaBlockInfo `json:"block"`
	Count       *int             `json:"count"`
	CountBigInt *string          `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Instruction
	Instruction *Instruction `json:"instruction"`
	Maximum     *string      `json:"maximum"`
	Minimum     *string      `json:"minimum"`
	// Transaction
	Transaction *SolanaTransactionInfo `json:"transaction"`
}

type SolanaInstructionAccountFilter struct {
	Date              *DateSelector     `json:"date"`
	Time              *DateTimeSelector `json:"time"`
	BlockHash         *HashSelector     `json:"blockHash"`
	Height            *BlockSelector    `json:"height"`
	PreviousBlockHash *HashSelector     `json:"previousBlockHash"`
	TransactionIndex  *IntegerSelector  `json:"transactionIndex"`
	Signature         *StringSelector   `json:"signature"`
	FeePayer          *HashSelector     `json:"feePayer"`
	Success           *BooleanSelector  `json:"success"`
	ProgramID         *StringSelector   `json:"programId"`
	ParsedProgramName *StringSelector   `json:"parsedProgramName"`
	Parsed            *IntegerSelector  `json:"parsed"`
	ParsedActionName  *StringSelector   `json:"parsedActionName"`
	ParsedType        *StringSelector   `json:"parsedType"`
	External          *IntegerSelector  `json:"external"`
	CallPath          *StringSelector   `json:"callPath"`
	Fee               *IntegerSelector  `json:"fee"`
	Account           *StringSelector   `json:"account"`
	AccountType       *StringSelector   `json:"accountType"`
	AccountOwner      *StringSelector   `json:"accountOwner"`
	AccountIndex      *IntegerSelector  `json:"accountIndex"`
}

type SolanaInstructionFilter struct {
	Date                      *DateSelector     `json:"date"`
	Time                      *DateTimeSelector `json:"time"`
	BlockHash                 *HashSelector     `json:"blockHash"`
	Height                    *BlockSelector    `json:"height"`
	PreviousBlockHash         *HashSelector     `json:"previousBlockHash"`
	TransactionIndex          *IntegerSelector  `json:"transactionIndex"`
	Signature                 *StringSelector   `json:"signature"`
	FeePayer                  *HashSelector     `json:"feePayer"`
	Success                   *BooleanSelector  `json:"success"`
	ProgramID                 *StringSelector   `json:"programId"`
	ParsedProgramName         *StringSelector   `json:"parsedProgramName"`
	Parsed                    *IntegerSelector  `json:"parsed"`
	ExternalParsed            *IntegerSelector  `json:"externalParsed"`
	ExternalProgramID         *StringSelector   `json:"externalProgramId"`
	ExternalParsedProgramName *StringSelector   `json:"externalParsedProgramName"`
	ParsedActionName          *StringSelector   `json:"parsedActionName"`
	ExternalParsedActionName  *StringSelector   `json:"externalParsedActionName"`
	ParsedType                *StringSelector   `json:"parsedType"`
	ExternalParsedType        *StringSelector   `json:"externalParsedType"`
	External                  *IntegerSelector  `json:"external"`
	CallPath                  *StringSelector   `json:"callPath"`
	Fee                       *IntegerSelector  `json:"fee"`
}

// Transaction in Solana  blockchain
type SolanaTransaction struct {
	// Count of inner instructions
	AccountsCount *int    `json:"accountsCount"`
	Any           *string `json:"any"`
	// Block where  transaction is included
	Block       *SolanaBlockInfo `json:"block"`
	Count       *int             `json:"count"`
	CountBigInt *string          `json:"countBigInt"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Error
	Error *string `json:"error"`
	// Fee Payer
	FeePayer *string `json:"feePayer"`
	// Count of inner instructions
	InnerInstructionsCount *int `json:"innerInstructionsCount"`
	// Count of instructions
	InstructionsCount *int    `json:"instructionsCount"`
	Maximum           *string `json:"maximum"`
	Minimum           *string `json:"minimum"`
	// Recent blockhash prevents duplication and to give transactions lifetimes
	RecentBlockHash *string `json:"recentBlockHash"`
	// Transaction Hash
	Signature *string `json:"signature"`
	// Accounts` public keys
	Signer *string `json:"signer"`
	// Successed or failed
	Success        *bool    `json:"success"`
	TransactionFee *float64 `json:"transactionFee"`
	// Transaction Index
	TransactionIndex *int `json:"transactionIndex"`
}

type SolanaTransactionFilter struct {
	Date                   *DateSelector    `json:"date"`
	BlockHash              *HashSelector    `json:"blockHash"`
	Height                 *BlockSelector   `json:"height"`
	PreviousBlockHash      *HashSelector    `json:"previousBlockHash"`
	RecentBlockHash        *HashSelector    `json:"recentBlockHash"`
	ParentSlot             *BlockSelector   `json:"parentSlot"`
	InstructionsCount      *IntegerSelector `json:"instructionsCount"`
	InnerInstructionsCount *IntegerSelector `json:"innerInstructionsCount"`
	AccountsCount          *IntegerSelector `json:"accountsCount"`
	TransactionIndex       *IntegerSelector `json:"transactionIndex"`
	Signature              *HashSelector    `json:"signature"`
	FeePayer               *HashSelector    `json:"feePayer"`
	Success                *BooleanSelector `json:"success"`
	Fee                    *IntegerSelector `json:"fee"`
	Signer                 *HashSelector    `json:"signer"`
	TransactionFee         *AmountSelector  `json:"transactionFee"`
}

// Solana Transaction Info
type SolanaTransactionInfo struct {
	FeePayer         *string `json:"feePayer"`
	Signature        *string `json:"signature"`
	Success          *bool   `json:"success"`
	TransactionIndex *string `json:"transactionIndex"`
}

// Solana Transaction Info Extended
type SolanaTransactionInfoExt struct {
	AccountsCount          *int     `json:"accountsCount"`
	Error                  *string  `json:"error"`
	Fee                    *float64 `json:"fee"`
	FeePayer               *string  `json:"feePayer"`
	InnerInstructionsCount *int     `json:"innerInstructionsCount"`
	InstructionsCount      *int     `json:"instructionsCount"`
	RecentBlockHash        *string  `json:"recentBlockHash"`
	Signature              *string  `json:"signature"`
	Signer                 *string  `json:"signer"`
	Success                *bool    `json:"success"`
	TransactionIndex       *string  `json:"transactionIndex"`
}

// Currency transfers from/to addresses in crypto currencies
type SolanaTransfer struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block       *SolanaBlockInfo `json:"block"`
	Count       *int             `json:"count"`
	CountBigInt *string          `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Instruction where transfer is included
	Instruction *InstructionWithExternals `json:"instruction"`
	Maximum     *string                   `json:"maximum"`
	Minimum     *string                   `json:"minimum"`
	// Receiver
	Receiver *Receiver `json:"receiver"`
	// Sender
	Sender *Sender `json:"sender"`
	// Transaction where transfer is included
	Transaction *SolanaTransactionInfoExt `json:"transaction"`
	// Transfer Type
	TransferType *string `json:"transferType"`
}

type SolanaTransferFilter struct {
	Date                      *DateSelector               `json:"date"`
	Time                      *DateTimeSelector           `json:"time"`
	BlockHash                 *HashSelector               `json:"blockHash"`
	Height                    *BlockSelector              `json:"height"`
	PreviousBlockHash         *HashSelector               `json:"previousBlockHash"`
	RecentBlockHash           *HashSelector               `json:"recentBlockHash"`
	TransactionIndex          *IntegerSelector            `json:"transactionIndex"`
	Signature                 *HashSelector               `json:"signature"`
	FeePayer                  *HashSelector               `json:"feePayer"`
	Success                   *BooleanSelector            `json:"success"`
	ProgramID                 *StringSelector             `json:"programId"`
	ParsedProgramName         *StringSelector             `json:"parsedProgramName"`
	ExternalProgramID         *StringSelector             `json:"externalProgramId"`
	ExternalParsedProgramName *StringSelector             `json:"externalParsedProgramName"`
	Parsed                    *IntegerSelector            `json:"parsed"`
	ExternalParsed            *IntegerSelector            `json:"externalParsed"`
	ParsedActionName          *StringSelector             `json:"parsedActionName"`
	ExternalParsedActionName  *StringSelector             `json:"externalParsedActionName"`
	ParsedType                *StringSelector             `json:"parsedType"`
	ExternalParsedType        *StringSelector             `json:"externalParsedType"`
	External                  *StringSelector             `json:"external"`
	CallPath                  *StringSelector             `json:"callPath"`
	SenderAddress             *StringSelector             `json:"senderAddress"`
	SenderType                *StringSelector             `json:"senderType"`
	ReceiverAddress           *StringSelector             `json:"receiverAddress"`
	ReceiverType              *StringSelector             `json:"receiverType"`
	TransferType              *SolanaTransferTypeSelector `json:"transferType"`
	Currency                  []*SolanaCurrencySelector   `json:"currency"`
}

// Select by transfer type
type SolanaTransferTypeSelector struct {
	// Type is
	Is *SolanaTransferType `json:"is"`
	// Type not
	Not *SolanaTransferType `json:"not"`
	// Type in the list
	In []SolanaTransferType `json:"in"`
	// Type not in the list
	NotIn []SolanaTransferType `json:"notIn"`
}

// Indicates what type of operation the transaction is supposed to do.
type StakingTransactionsTypeSelector struct {
	// Type is
	Is *StakingTransactionsTypeEnum `json:"is"`
	// Type not
	Not *StakingTransactionsTypeEnum `json:"not"`
	// Type in the list
	In []StakingTransactionsTypeEnum `json:"in"`
	// Type not in the list
	NotIn []StakingTransactionsTypeEnum `json:"notIn"`
}

// Stellar Chain
type Stellar struct {
	// Stellar Transfers
	Transfers []*StellarTransfers `json:"transfers"`
}

// Transfers in Stellar blockchain
type StellarTransfers struct {
	AmountFrom  *float64 `json:"amountFrom"`
	AmountTo    *float64 `json:"amountTo"`
	Any         *string  `json:"any"`
	Count       *int     `json:"count"`
	CountBigInt *string  `json:"countBigInt"`
	// Currency from of transfer
	CurrencyFrom *Currency `json:"currencyFrom"`
	// Currency to of transfer
	CurrencyTo *Currency `json:"currencyTo"`
	// The date this transaction was created
	Date *Date `json:"date"`
	// Direction
	Direction *string `json:"direction"`
	// The sequence number of the ledger that this transaction was included in
	Ledger  *string `json:"ledger"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Operation
	Operation *string `json:"operation"`
	// The number of operations contained within this transaction
	OperationCount *string `json:"operationCount"`
	// The account this transaction is been sent to
	Receiver *string `json:"receiver"`
	// Sender
	Sender *string `json:"sender"`
	// The time this transaction was created
	Time *DateTime `json:"time"`
	// Hash of this transaction
	TransactionHash *string `json:"transactionHash"`
}

type StellarTransfersFilter struct {
	Date            *DateSelector `json:"date"`
	TransactionHash *HashSelector `json:"transactionHash"`
	Receiver        *HashSelector `json:"receiver"`
	Sender          *HashSelector `json:"sender"`
	Direction       *HashSelector `json:"direction"`
}

// Select by ID
type StringIDSelector struct {
	// ID is
	Is *string `json:"is"`
	// ID not
	Not *string `json:"not"`
	// ID in the list
	In []string `json:"in"`
	// ID not in the list
	NotIn []string `json:"notIn"`
}

// Select by string
type StringSelector struct {
	// String is
	Is *string `json:"is"`
	// String not
	Not *string `json:"not"`
	// String in the list
	In []string `json:"in"`
	// String not in the list
	NotIn []string `json:"notIn"`
}

// Time Interval
type TimeInterval struct {
	Day    string `json:"day"`
	Hour   string `json:"hour"`
	Minute string `json:"minute"`
	Month  string `json:"month"`
	Second string `json:"second"`
	Year   string `json:"year"`
}

// Timestamp
type Timestamp struct {
	// Nanoseconds
	Nanoseconds string `json:"nanoseconds"`
	Time        string `json:"time"`
}

// Select trade by ID
type TradeIDSelector struct {
	// Trade ID is
	Is *string `json:"is"`
	// Trade ID not
	Not *string `json:"not"`
	// Trade ID in the list
	In []string `json:"in"`
	// Trade ID not in the list
	NotIn []string `json:"notIn"`
}

// Information about transaction
type TransactionElrond struct {
	// Shard number of sender
	Data *string `json:"data"`
	// Shard number of sender
	DataOperation *string  `json:"dataOperation"`
	Fee           *float64 `json:"fee"`
	// Transaction hash
	Hash *string `json:"hash"`
	// Transaction index
	Index *int `json:"index"`
	// Transaction nonce
	Nonce *int `json:"nonce"`
	// Hash of the receiver
	Receiver *Address `json:"receiver"`
	// Shard number of receiver
	ReceiverShard *string `json:"receiverShard"`
	// Hash of the sender
	Sender *Address `json:"sender"`
	// Shard number of sender
	SenderShard *string `json:"senderShard"`
	// Shard number of sender
	Signature *string `json:"signature"`
	// Shard number of sender
	Status *string `json:"status"`
}

// Blockchain transaction
type TransactionHash struct {
	// Hash hex representation
	Hash string `json:"hash"`
}

func (TransactionHash) IsSubject() {}

// Blockchain transaction
type TransactionHashIndex struct {
	// Block of the Output Transaction for this input
	Block *int `json:"block"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0-based
	Index string `json:"index"`
}

// Blockchain transaction with value
type TransactionHashValue struct {
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction value
	Value float64 `json:"value"`
}

// Transaction result
type TransactionResult struct {
	// Result ID
	ID int `json:"id"`
	// Result name
	Name string `json:"name"`
}

// Identification of transaction source as client application
type TransactionSource struct {
	// ID numeric
	Code int `json:"code"`
	// Name
	Name string `json:"name"`
}

// Indicates what type of operation the transaction is supposed to do.
type TransactionTypeSelector struct {
	// Type is
	Is *TransactionTypeEnum `json:"is"`
	// Type not
	Not *TransactionTypeEnum `json:"not"`
	// Type in the list
	In []TransactionTypeEnum `json:"in"`
	// Type not in the list
	NotIn []TransactionTypeEnum `json:"notIn"`
}

// Select by transfer reason
type TransferReasonSelector struct {
	// Reason is
	Is *TransferReasonEnum `json:"is"`
	// Reason not
	Not *TransferReasonEnum `json:"not"`
	// Reason in the list
	In []TransferReasonEnum `json:"in"`
	// Reason not in the list
	NotIn []TransferReasonEnum `json:"notIn"`
}

// Select by type of transfer
type TransferTypeSelector struct {
	// Transfer Type is
	Is *FilecoinTransferType `json:"is"`
	// Transfer Type not
	Not *FilecoinTransferType `json:"not"`
	// Transfer Type in the list
	In []FilecoinTransferType `json:"in"`
	// Transfer Type not in the list
	NotIn []FilecoinTransferType `json:"notIn"`
}

// Tron Chain
type Tron struct {
	// Basic information about address ( or smart contract )
	Address []*TronAddressInfo `json:"address"`
	// Blockchain Blocks
	Blocks []*TronBlocks `json:"blocks"`
	// Money flow using Coinpath technology
	Coinpath []*TronCoinpath `json:"coinpath"`
	// Blockchain Embedded Contracts
	Contracts []*TronSmartContracts `json:"contracts"`
	// Trades on Ethereum DEX Smart Contracts
	DexTrades []*TronDexTrades `json:"dexTrades"`
	// Smart Contract Calls
	SmartContractCalls []*TronSmartContractCalls `json:"smartContractCalls"`
	// Smart Contract Events
	SmartContractEvents []*TronSmartContractEvents `json:"smartContractEvents"`
	// Blockchain Embedded Contracts
	Trades []*TronTrades `json:"trades"`
	// Blockchain Transactions
	Transactions []*TronTransactions `json:"transactions"`
	// Currency Transfers
	Transfers []*TronTransfers `json:"transfers"`
}

// Address detailed information for Tron network
type TronAddressInfo struct {
	// Address
	Address *string `json:"address"`
	// Annotations ( tags ), if exists
	Annotation *string `json:"annotation"`
	// Smart Contract if exists on the address
	SmartContract *TronSmartContractInfo `json:"smartContract"`
}

type TronBlockFilter struct {
	Date            *DateSelector     `json:"date"`
	Time            *DateTimeSelector `json:"time"`
	Height          *BlockSelector    `json:"height"`
	BlockHash       *HashSelector     `json:"blockHash"`
	Witness         *AddressSelector  `json:"witness"`
	Version         *IntegerSelector  `json:"version"`
	ParentBlockHash []*HashSelector   `json:"parentBlockHash"`
}

// Blocks in Tron blockchain
type TronBlocks struct {
	Any         *string `json:"any"`
	Count       *int    `json:"count"`
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date *Date `json:"date"`
	// Block hash
	Hash string `json:"hash"`
	// Block number (height) in blockchain
	Height  int     `json:"height"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Parent block hash
	ParentBlockHash string `json:"parentBlockHash"`
	// Block timestamp
	Timestamp *DateTime `json:"timestamp"`
	// TX Trie Root Hash
	TxTrieRoot string `json:"txTrieRoot"`
	// Block version
	Version *int `json:"version"`
	// Block witness
	Witness *Address `json:"witness"`
	// Witness signature
	WitnessSignature string `json:"witnessSignature"`
}

// Coinpath
type TronCoinpath struct {
	// Summary of transfered value
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transaction is included
	Block *Block `json:"block"`
	// Count of transfers
	Count *int `json:"count"`
	// Count of transfers
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// 1-based hop depth of the graph
	Depth   *int    `json:"depth"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Receiver address
	Receiver *TronAddressInfo `json:"receiver"`
	// Sender address
	Sender *TronAddressInfo `json:"sender"`
	// Transaction of transfer happened
	Transaction *TransactionHashValue `json:"transaction"`
}

type TronContractFilter struct {
	Date         *DateSelector             `json:"date"`
	Time         *DateTimeSelector         `json:"time"`
	Height       *BlockSelector            `json:"height"`
	TxHash       *HashSelector             `json:"txHash"`
	TxOwner      *AddressSelector          `json:"txOwner"`
	ContractType *TronContractTypeSelector `json:"contractType"`
	Currency     *TronCurrencySelector     `json:"currency"`
	Success      *bool                     `json:"success"`
}

// Select contract type(s)
type TronContractTypeSelector struct {
	// Contract type is
	Is *TronContractType `json:"is"`
	// Contract type not
	Not *TronContractType `json:"not"`
	// Contract type in the list
	In []TronContractType `json:"in"`
	// Contract type not in the list
	NotIn []TronContractType `json:"notIn"`
}

// Currency selector in Tron blockchain.
// Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
type TronCurrencySelector struct {
	// Currency is
	Is *string `json:"is"`
	// Currency not
	Not *string `json:"not"`
	// Currency in the list
	In []string `json:"in"`
	// Currency not in the list
	NotIn []string `json:"notIn"`
}

// Tron DEX attributes
type TronDex struct {
	// Address for DEX exchange identification
	Address *Address `json:"address"`
	// Full name ( name for known, Protocol for unknown )
	FullName string `json:"fullName"`
	// Full name ( name for known, Protocol / address for unknown )
	FullNameWithID string `json:"fullNameWithId"`
	// Name for known exchanges
	Name *string `json:"name"`
}

type TronDexTradeFilter struct {
	Date                 *DateSelector           `json:"date"`
	Time                 *DateTimeSelector       `json:"time"`
	Height               *BlockSelector          `json:"height"`
	TxHash               *HashSelector           `json:"txHash"`
	Protocol             []*StringSelector       `json:"protocol"`
	SmartContractAddress []*AddressSelector      `json:"smartContractAddress"`
	ExchangeAddress      []*AddressSelector      `json:"exchangeAddress"`
	ExchangeName         []*StringSelector       `json:"exchangeName"`
	SellCurrency         []*TronCurrencySelector `json:"sellCurrency"`
	BuyCurrency          []*TronCurrencySelector `json:"buyCurrency"`
	BaseCurrency         []*TronCurrencySelector `json:"baseCurrency"`
	QuoteCurrency        []*TronCurrencySelector `json:"quoteCurrency"`
	Maker                []*AddressSelector      `json:"maker"`
	Taker                []*AddressSelector      `json:"taker"`
	MakerOrTaker         []*AddressSelector      `json:"makerOrTaker"`
	TradeIndex           []*StringSelector       `json:"tradeIndex"`
	BuyAmount            []*AmountSelector       `json:"buyAmount"`
	SellAmount           []*AmountSelector       `json:"sellAmount"`
	Price                []*AmountSelector       `json:"price"`
	PriceAsymmetry       []*FloatSelector        `json:"priceAsymmetry"`
	TradeAmountUsd       []*FloatSelector        `json:"tradeAmountUsd"`
}

// Trades on DEX smart contracts
type TronDexTrades struct {
	// Trader (maker or taker)
	Address    *TronAddressInfo `json:"address"`
	Any        *string          `json:"any"`
	BaseAmount *float64         `json:"baseAmount"`
	// Base currency
	BaseCurrency *Currency `json:"baseCurrency"`
	// Block in the blockchain
	Block     *BlockExtended `json:"block"`
	BuyAmount *float64       `json:"buyAmount"`
	// Maker buys this currency
	BuyCurrency *Currency `json:"buyCurrency"`
	Count       *int      `json:"count"`
	CountBigInt *string   `json:"countBigInt"`
	// Calendar date
	Date             *Date    `json:"date"`
	EnergyFee        *float64 `json:"energyFee"`
	EnergyUsageTotal *float64 `json:"energyUsageTotal"`
	// Identification of admin / manager / factory of smart contract, executing trades
	Exchange                        *TronDex `json:"exchange"`
	Fee                             *float64 `json:"fee"`
	InternalTransactionsCount       *int     `json:"internalTransactionsCount"`
	InternalTransactionsCountBigInt *string  `json:"internalTransactionsCountBigInt"`
	LogsCount                       *int     `json:"logsCount"`
	LogsCountBigInt                 *string  `json:"logsCountBigInt"`
	// Trade 'maker' side
	Maker    *TronAddressInfo `json:"maker"`
	Maximum  *string          `json:"maximum"`
	Minimum  *string          `json:"minimum"`
	NetFee   *float64         `json:"netFee"`
	NetUsage *float64         `json:"netUsage"`
	Price    *float64         `json:"price"`
	// Protocol name of the smart contract
	Protocol    *string  `json:"protocol"`
	QuoteAmount *float64 `json:"quoteAmount"`
	// Quote currency
	QuoteCurrency *Currency `json:"quoteCurrency"`
	QuotePrice    *float64  `json:"quotePrice"`
	SellAmount    *float64  `json:"sellAmount"`
	// Maker sells this currency
	SellCurrency *Currency `json:"sellCurrency"`
	// Side of trade ( SELL / BUY )
	Side *TradeSide `json:"side"`
	// Smart contract being called
	SmartContract *TronSmartContract `json:"smartContract"`
	// Trade 'taker' side
	Taker *TronAddressInfo `json:"taker"`
	// Time interval
	TimeInterval *TimeInterval `json:"timeInterval"`
	TradeAmount  *float64      `json:"tradeAmount"`
	// Index of trade in transaction, used to separate trades in transaction
	TradeIndex *string `json:"tradeIndex"`
	// Transaction of DexTrade
	Transaction *TronTransactionInfoExtended `json:"transaction"`
}

// Tron smart contract
type TronSmartContract struct {
	// Smart Contract Address
	Address *Address `json:"address"`
	// Smart Contract Type
	ContractType *SmartContractType `json:"contractType"`
	// Token implemented in this smart contract
	Currency *Currency `json:"currency"`
	// Smart Contract Protocol Type
	ProtocolType *string `json:"protocolType"`
}

type TronSmartContractCallFilter struct {
	Date                 *DateSelector     `json:"date"`
	Time                 *DateTimeSelector `json:"time"`
	Height               *BlockSelector    `json:"height"`
	TxHash               *HashSelector     `json:"txHash"`
	TxFrom               *AddressSelector  `json:"txFrom"`
	TxTo                 *AddressSelector  `json:"txTo"`
	SmartContractAddress *AddressSelector  `json:"smartContractAddress"`
	SmartContractMethod  *MethodSelector   `json:"smartContractMethod"`
	External             *bool             `json:"external"`
	Success              *bool             `json:"success"`
}

// Smart Contract Calls
type TronSmartContractCalls struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
	CallDepth *string `json:"callDepth"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date             *Date    `json:"date"`
	EnergyUsageTotal *float64 `json:"energyUsageTotal"`
	// External call executed explicitly by caller. Internal calls executed by smart contracts.
	External *bool    `json:"external"`
	Fee      *float64 `json:"fee"`
	Maximum  *string  `json:"maximum"`
	Minimum  *string  `json:"minimum"`
	NetUsage *float64 `json:"netUsage"`
	// Smart contract being called
	SmartContract *TronSmartContract `json:"smartContract"`
	// Contract method invoked
	SmartContractMethod *Method `json:"smartContractMethod"`
	// True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
	Success *bool `json:"success"`
	// Action from address
	TxFrom *Address `json:"txFrom"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Action to address
	TxTo *Address `json:"txTo"`
}

type TronSmartContractEventFilter struct {
	Date                 *DateSelector     `json:"date"`
	Time                 *DateTimeSelector `json:"time"`
	Height               *BlockSelector    `json:"height"`
	TxHash               *HashSelector     `json:"txHash"`
	TxFrom               *AddressSelector  `json:"txFrom"`
	TxTo                 *AddressSelector  `json:"txTo"`
	SmartContractAddress *AddressSelector  `json:"smartContractAddress"`
	SmartContractEvent   *EventSelector    `json:"smartContractEvent"`
}

// Smart Contract Events
type TronSmartContractEvents struct {
	Any *string `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Calendar date
	Date    *Date   `json:"date"`
	Maximum *string `json:"maximum"`
	Minimum *string `json:"minimum"`
	// Smart contract being Evented
	SmartContract *TronSmartContract `json:"smartContract"`
	// Contract method invoked
	SmartContractEvent *Event `json:"smartContractEvent"`
	// Action from address
	TxFrom *Address `json:"txFrom"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Action to address
	TxTo *Address `json:"txTo"`
}

// Blockchain smart contract
type TronSmartContractInfo struct {
	// Smart Contract Type
	ContractType *SmartContractType `json:"contractType"`
	// Token implemented in this smart contract
	Currency *Currency `json:"currency"`
	// Smart Contract Protocol Type
	ProtocolType *string `json:"protocolType"`
}

// Contracts
type TronSmartContracts struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block in the blockchain
	Block *Block `json:"block"`
	// Contract type
	ContractType *TronContractType `json:"contractType"`
	// Counts and other metrics
	Count *int `json:"count"`
	// Counts and other metrics
	CountBigInt *string `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date             *Date    `json:"date"`
	EnergyUsageTotal *float64 `json:"energyUsageTotal"`
	Fee              *float64 `json:"fee"`
	Maximum          *string  `json:"maximum"`
	Minimum          *string  `json:"minimum"`
	NetUsage         *float64 `json:"netUsage"`
	// True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
	Success *bool `json:"success"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Transactio owner from address
	TxOwner *Address `json:"txOwner"`
}

type TronTradeFilter struct {
	Date         *DateSelector             `json:"date"`
	Time         *DateTimeSelector         `json:"time"`
	Height       *BlockSelector            `json:"height"`
	TxHash       *HashSelector             `json:"txHash"`
	Buyer        *AddressSelector          `json:"buyer"`
	Seller       *AddressSelector          `json:"seller"`
	BuyCurrency  *TronCurrencySelector     `json:"buyCurrency"`
	SellCurrency *TronCurrencySelector     `json:"sellCurrency"`
	ContractType *TronContractTypeSelector `json:"contractType"`
	AmountSell   []*AmountSelector         `json:"amountSell"`
	AmountBuy    []*AmountSelector         `json:"amountBuy"`
	ExchangeID   *IntIDSelector            `json:"exchangeId"`
	Success      *bool                     `json:"success"`
}

// Currency Trades from/to addresses in crypto currencies
type TronTrades struct {
	AmountBuy  *float64 `json:"amountBuy"`
	AmountSell *float64 `json:"amountSell"`
	Any        *string  `json:"any"`
	// Block where Trade transaction is included
	Block *Block `json:"block"`
	// Buy Currency of Trade
	BuyCurrency *Currency `json:"buyCurrency"`
	// Trade buyer
	Buyer *Address `json:"buyer"`
	// Contract type
	ContractType *TronContractType `json:"contractType"`
	Count        *int              `json:"count"`
	CountBigInt  *string           `json:"countBigInt"`
	// Calendar date
	Date             *Date    `json:"date"`
	EnergyUsageTotal *float64 `json:"energyUsageTotal"`
	// exchange_id
	ExchangeID *int     `json:"exchangeId"`
	Fee        *float64 `json:"fee"`
	Maximum    *string  `json:"maximum"`
	Minimum    *string  `json:"minimum"`
	NetUsage   *float64 `json:"netUsage"`
	// Sell Currency of Trade
	SellCurrency *Currency `json:"sellCurrency"`
	// Trade seller
	Seller *Address `json:"seller"`
	// Transfer succeeded
	Success *bool `json:"success"`
	// Transaction hash where Trade happened
	TxHash *string `json:"txHash"`
}

type TronTransactionFilter struct {
	Date            *DateSelector     `json:"date"`
	Time            *DateTimeSelector `json:"time"`
	Height          *BlockSelector    `json:"height"`
	TxHash          *HashSelector     `json:"txHash"`
	TxIndex         *TxIndexSelector  `json:"txIndex"`
	Success         *bool             `json:"success"`
	RefBlockHash    []*HashSelector   `json:"refBlockHash"`
	ContractAddress *AddressSelector  `json:"contractAddress"`
}

// Blockchain Transaction Extended info
type TronTransactionInfoExtended struct {
	// Contract Address
	ContractAddress *Address `json:"contractAddress"`
	// Expiration
	Expiration int `json:"expiration"`
	// Fee Limit
	FeeLimit int `json:"feeLimit"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0 based
	Index *int `json:"index"`
	// Ref block Hash hex representation
	RefBlockHash string `json:"refBlockHash"`
	// Result message
	Result *string `json:"result"`
	// Signatures
	Signatures string `json:"signatures"`
	// Success
	Success *bool `json:"success"`
}

// Transactions in Tron blockchain
type TronTransactions struct {
	Any *string `json:"any"`
	// Block where transfer transaction is included
	Block *Block `json:"block"`
	// Contract Address
	ContractAddress *Address `json:"contractAddress"`
	Count           *int     `json:"count"`
	CountBigInt     *string  `json:"countBigInt"`
	// Calendar date
	Date             *Date    `json:"date"`
	EnergyFee        *float64 `json:"energyFee"`
	EnergyUsageTotal *float64 `json:"energyUsageTotal"`
	// Expiration
	Expiration int      `json:"expiration"`
	Fee        *float64 `json:"fee"`
	// Fee Limit
	FeeLimit int `json:"feeLimit"`
	// Hash hex representation
	Hash string `json:"hash"`
	// Transaction index in block, 0 based
	Index                           *int     `json:"index"`
	InternalTransactionsCount       *int     `json:"internalTransactionsCount"`
	InternalTransactionsCountBigInt *string  `json:"internalTransactionsCountBigInt"`
	LogsCount                       *int     `json:"logsCount"`
	LogsCountBigInt                 *string  `json:"logsCountBigInt"`
	Maximum                         *string  `json:"maximum"`
	Minimum                         *string  `json:"minimum"`
	NetFee                          *float64 `json:"netFee"`
	NetUsage                        *float64 `json:"netUsage"`
	// Ref block Hash hex representation
	RefBlockHash string `json:"refBlockHash"`
	// Result message
	Result *string `json:"result"`
	// Signatures
	Signatures string `json:"signatures"`
	// Success
	Success *bool `json:"success"`
}

type TronTransferFilter struct {
	Date         *DateSelector             `json:"date"`
	Time         *DateTimeSelector         `json:"time"`
	Height       *BlockSelector            `json:"height"`
	TxHash       *HashSelector             `json:"txHash"`
	TxFrom       *AddressSelector          `json:"txFrom"`
	TxTo         *AddressSelector          `json:"txTo"`
	Sender       *AddressSelector          `json:"sender"`
	Receiver     *AddressSelector          `json:"receiver"`
	Currency     *TronCurrencySelector     `json:"currency"`
	ContractType *TronContractTypeSelector `json:"contractType"`
	EntityID     *EntitySelector           `json:"entityId"`
	External     *bool                     `json:"external"`
	Success      *bool                     `json:"success"`
	Amount       []*AmountSelector         `json:"amount"`
}

// Currency transfers from/to addresses in crypto currencies
type TronTransfers struct {
	Amount *float64 `json:"amount"`
	Any    *string  `json:"any"`
	// Block where transfer transaction is included
	Block *Block `json:"block"`
	// Contract type
	ContractType *TronContractType `json:"contractType"`
	Count        *int              `json:"count"`
	CountBigInt  *string           `json:"countBigInt"`
	// Currency of transfer
	Currency *Currency `json:"currency"`
	// Calendar date
	Date             *Date    `json:"date"`
	EnergyUsageTotal *float64 `json:"energyUsageTotal"`
	// Entity identifier ( for ERC-721 NFT tokens )
	EntityID *string `json:"entityId"`
	// External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
	External *bool    `json:"external"`
	Fee      *float64 `json:"fee"`
	Maximum  *string  `json:"maximum"`
	Minimum  *string  `json:"minimum"`
	NetUsage *float64 `json:"netUsage"`
	// Transfer receiver
	Receiver *Address `json:"receiver"`
	// Transfer sender
	Sender *Address `json:"sender"`
	// Transfer succeeded
	Success *bool `json:"success"`
	// Action from address
	TxFrom *Address `json:"txFrom"`
	// Transaction hash where transfer happened
	TxHash *string `json:"txHash"`
	// Action to address
	TxTo *Address `json:"txTo"`
}

// Selector of index of transaction in block
type TxIndexSelector struct {
	// Tx index is
	Is *int `json:"is"`
	// Tx index not
	Not *int `json:"not"`
	// Tx index in the list
	In []int `json:"in"`
	// Tx index not in the list
	NotIn []int `json:"notIn"`
}

// Select transactions by subtype
type TxSubtypeSelector struct {
	// Transaction SubType is
	Is *AlgorandTxSubType `json:"is"`
	// Transaction SubType not
	Not *AlgorandTxSubType `json:"not"`
	// Transaction SubType in the list
	In []AlgorandTxSubType `json:"in"`
	// Transaction SubType not in the list
	NotIn []AlgorandTxSubType `json:"notIn"`
}

// Select transactions by type
type TxTypeSelector struct {
	// Transaction Type is
	Is *AlgorandTxType `json:"is"`
	// Transaction Type not
	Not *AlgorandTxType `json:"not"`
	// Transaction Type in the list
	In []AlgorandTxType `json:"in"`
	// Transaction Type not in the list
	NotIn []AlgorandTxType `json:"notIn"`
}

// Select by type
type TypeSelector struct {
	// Type is
	Is *string `json:"is"`
	// Type not
	Not *string `json:"not"`
	// Type in the list
	In []string `json:"in"`
	// Type not in the list
	NotIn []string `json:"notIn"`
}

type AlgorandArgumentsMeasureable string

const (
	// Date
	AlgorandArgumentsMeasureableDate AlgorandArgumentsMeasureable = "date"
	// Time
	AlgorandArgumentsMeasureableTime AlgorandArgumentsMeasureable = "time"
	// Block
	AlgorandArgumentsMeasureableBlock AlgorandArgumentsMeasureable = "block"
	// Transaction hash
	AlgorandArgumentsMeasureableTxHash AlgorandArgumentsMeasureable = "tx_hash"
	// Transaction type
	AlgorandArgumentsMeasureableTxType AlgorandArgumentsMeasureable = "tx_type"
	// Transaction Sender
	AlgorandArgumentsMeasureableTxSender AlgorandArgumentsMeasureable = "tx_sender"
	// Smart Contract
	AlgorandArgumentsMeasureableSmartContract AlgorandArgumentsMeasureable = "smart_contract"
	// Argument value
	AlgorandArgumentsMeasureableArgumentValue AlgorandArgumentsMeasureable = "argument_value"
	// Argument index
	AlgorandArgumentsMeasureableArgumentIndex AlgorandArgumentsMeasureable = "argument_index"
)

var AllAlgorandArgumentsMeasureable = []AlgorandArgumentsMeasureable{
	AlgorandArgumentsMeasureableDate,
	AlgorandArgumentsMeasureableTime,
	AlgorandArgumentsMeasureableBlock,
	AlgorandArgumentsMeasureableTxHash,
	AlgorandArgumentsMeasureableTxType,
	AlgorandArgumentsMeasureableTxSender,
	AlgorandArgumentsMeasureableSmartContract,
	AlgorandArgumentsMeasureableArgumentValue,
	AlgorandArgumentsMeasureableArgumentIndex,
}

func (e AlgorandArgumentsMeasureable) IsValid() bool {
	switch e {
	case AlgorandArgumentsMeasureableDate, AlgorandArgumentsMeasureableTime, AlgorandArgumentsMeasureableBlock, AlgorandArgumentsMeasureableTxHash, AlgorandArgumentsMeasureableTxType, AlgorandArgumentsMeasureableTxSender, AlgorandArgumentsMeasureableSmartContract, AlgorandArgumentsMeasureableArgumentValue, AlgorandArgumentsMeasureableArgumentIndex:
		return true
	}
	return false
}

func (e AlgorandArgumentsMeasureable) String() string {
	return string(e)
}

func (e *AlgorandArgumentsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandArgumentsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandArgumentsMeasureable", str)
	}
	return nil
}

func (e AlgorandArgumentsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandBlocksMeasureable string

const (
	// Date
	AlgorandBlocksMeasureableDate AlgorandBlocksMeasureable = "date"
	// Time
	AlgorandBlocksMeasureableTime AlgorandBlocksMeasureable = "time"
	// Block
	AlgorandBlocksMeasureableBlock AlgorandBlocksMeasureable = "block"
	// Block hash
	AlgorandBlocksMeasureableBlockHash AlgorandBlocksMeasureable = "block_hash"
	// Block Reward
	AlgorandBlocksMeasureableBlockReward AlgorandBlocksMeasureable = "block_reward"
	// Block Proposer
	AlgorandBlocksMeasureableProposer AlgorandBlocksMeasureable = "proposer"
	// Next protocol approvals
	AlgorandBlocksMeasureableNextProtocolApprovals AlgorandBlocksMeasureable = "next_protocol_approvals"
)

var AllAlgorandBlocksMeasureable = []AlgorandBlocksMeasureable{
	AlgorandBlocksMeasureableDate,
	AlgorandBlocksMeasureableTime,
	AlgorandBlocksMeasureableBlock,
	AlgorandBlocksMeasureableBlockHash,
	AlgorandBlocksMeasureableBlockReward,
	AlgorandBlocksMeasureableProposer,
	AlgorandBlocksMeasureableNextProtocolApprovals,
}

func (e AlgorandBlocksMeasureable) IsValid() bool {
	switch e {
	case AlgorandBlocksMeasureableDate, AlgorandBlocksMeasureableTime, AlgorandBlocksMeasureableBlock, AlgorandBlocksMeasureableBlockHash, AlgorandBlocksMeasureableBlockReward, AlgorandBlocksMeasureableProposer, AlgorandBlocksMeasureableNextProtocolApprovals:
		return true
	}
	return false
}

func (e AlgorandBlocksMeasureable) String() string {
	return string(e)
}

func (e *AlgorandBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandBlocksMeasureable", str)
	}
	return nil
}

func (e AlgorandBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandBlocksUniq string

const (
	// Unique proposer count
	AlgorandBlocksUniqProposers AlgorandBlocksUniq = "proposers"
	// Unique date count
	AlgorandBlocksUniqDates AlgorandBlocksUniq = "dates"
)

var AllAlgorandBlocksUniq = []AlgorandBlocksUniq{
	AlgorandBlocksUniqProposers,
	AlgorandBlocksUniqDates,
}

func (e AlgorandBlocksUniq) IsValid() bool {
	switch e {
	case AlgorandBlocksUniqProposers, AlgorandBlocksUniqDates:
		return true
	}
	return false
}

func (e AlgorandBlocksUniq) String() string {
	return string(e)
}

func (e *AlgorandBlocksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandBlocksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandBlocksUniq", str)
	}
	return nil
}

func (e AlgorandBlocksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandCallsMeasureable string

const (
	// Date
	AlgorandCallsMeasureableDate AlgorandCallsMeasureable = "date"
	// Time
	AlgorandCallsMeasureableTime AlgorandCallsMeasureable = "time"
	// Block
	AlgorandCallsMeasureableBlock AlgorandCallsMeasureable = "block"
	// Transaction hash
	AlgorandCallsMeasureableTxHash AlgorandCallsMeasureable = "tx_hash"
	// Transaction type
	AlgorandCallsMeasureableTxType AlgorandCallsMeasureable = "tx_type"
	// Transaction Sender
	AlgorandCallsMeasureableTxSender AlgorandCallsMeasureable = "tx_sender"
	// Smart Contract
	AlgorandCallsMeasureableSmartContract AlgorandCallsMeasureable = "smart_contract"
)

var AllAlgorandCallsMeasureable = []AlgorandCallsMeasureable{
	AlgorandCallsMeasureableDate,
	AlgorandCallsMeasureableTime,
	AlgorandCallsMeasureableBlock,
	AlgorandCallsMeasureableTxHash,
	AlgorandCallsMeasureableTxType,
	AlgorandCallsMeasureableTxSender,
	AlgorandCallsMeasureableSmartContract,
}

func (e AlgorandCallsMeasureable) IsValid() bool {
	switch e {
	case AlgorandCallsMeasureableDate, AlgorandCallsMeasureableTime, AlgorandCallsMeasureableBlock, AlgorandCallsMeasureableTxHash, AlgorandCallsMeasureableTxType, AlgorandCallsMeasureableTxSender, AlgorandCallsMeasureableSmartContract:
		return true
	}
	return false
}

func (e AlgorandCallsMeasureable) String() string {
	return string(e)
}

func (e *AlgorandCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandCallsMeasureable", str)
	}
	return nil
}

func (e AlgorandCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandNetwork string

const (
	// Algorand Mainnet (ALGO)
	AlgorandNetworkAlgorand AlgorandNetwork = "algorand"
	// Algorand Testnet
	AlgorandNetworkAlgorandTestnet AlgorandNetwork = "algorand_testnet"
	// Algorand Betanet
	AlgorandNetworkAlgorandBetanet AlgorandNetwork = "algorand_betanet"
)

var AllAlgorandNetwork = []AlgorandNetwork{
	AlgorandNetworkAlgorand,
	AlgorandNetworkAlgorandTestnet,
	AlgorandNetworkAlgorandBetanet,
}

func (e AlgorandNetwork) IsValid() bool {
	switch e {
	case AlgorandNetworkAlgorand, AlgorandNetworkAlgorandTestnet, AlgorandNetworkAlgorandBetanet:
		return true
	}
	return false
}

func (e AlgorandNetwork) String() string {
	return string(e)
}

func (e *AlgorandNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandNetwork", str)
	}
	return nil
}

func (e AlgorandNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandTransactionsMeasureable string

const (
	// Date
	AlgorandTransactionsMeasureableDate AlgorandTransactionsMeasureable = "date"
	// Time
	AlgorandTransactionsMeasureableTime AlgorandTransactionsMeasureable = "time"
	// Block
	AlgorandTransactionsMeasureableBlock AlgorandTransactionsMeasureable = "block"
	// Fee value
	AlgorandTransactionsMeasureableFee AlgorandTransactionsMeasureable = "fee"
	// Transaction hash
	AlgorandTransactionsMeasureableTxHash AlgorandTransactionsMeasureable = "tx_hash"
	// Transaction Sender
	AlgorandTransactionsMeasureableTxSender AlgorandTransactionsMeasureable = "tx_sender"
)

var AllAlgorandTransactionsMeasureable = []AlgorandTransactionsMeasureable{
	AlgorandTransactionsMeasureableDate,
	AlgorandTransactionsMeasureableTime,
	AlgorandTransactionsMeasureableBlock,
	AlgorandTransactionsMeasureableFee,
	AlgorandTransactionsMeasureableTxHash,
	AlgorandTransactionsMeasureableTxSender,
}

func (e AlgorandTransactionsMeasureable) IsValid() bool {
	switch e {
	case AlgorandTransactionsMeasureableDate, AlgorandTransactionsMeasureableTime, AlgorandTransactionsMeasureableBlock, AlgorandTransactionsMeasureableFee, AlgorandTransactionsMeasureableTxHash, AlgorandTransactionsMeasureableTxSender:
		return true
	}
	return false
}

func (e AlgorandTransactionsMeasureable) String() string {
	return string(e)
}

func (e *AlgorandTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandTransactionsMeasureable", str)
	}
	return nil
}

func (e AlgorandTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandTransactionsUniq string

const (
	// Unique TX senders count
	AlgorandTransactionsUniqSenders AlgorandTransactionsUniq = "senders"
	// Unique blocks
	AlgorandTransactionsUniqBlocks AlgorandTransactionsUniq = "blocks"
	// Unique date count
	AlgorandTransactionsUniqDates AlgorandTransactionsUniq = "dates"
	// Unique currencies
	AlgorandTransactionsUniqCurrencies AlgorandTransactionsUniq = "currencies"
)

var AllAlgorandTransactionsUniq = []AlgorandTransactionsUniq{
	AlgorandTransactionsUniqSenders,
	AlgorandTransactionsUniqBlocks,
	AlgorandTransactionsUniqDates,
	AlgorandTransactionsUniqCurrencies,
}

func (e AlgorandTransactionsUniq) IsValid() bool {
	switch e {
	case AlgorandTransactionsUniqSenders, AlgorandTransactionsUniqBlocks, AlgorandTransactionsUniqDates, AlgorandTransactionsUniqCurrencies:
		return true
	}
	return false
}

func (e AlgorandTransactionsUniq) String() string {
	return string(e)
}

func (e *AlgorandTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandTransactionsUniq", str)
	}
	return nil
}

func (e AlgorandTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandTransferType string

const (
	// Genesis Block
	AlgorandTransferTypeGenesis AlgorandTransferType = "genesis"
	// Create Asset
	AlgorandTransferTypeCreate AlgorandTransferType = "create"
	// Send
	AlgorandTransferTypeSend AlgorandTransferType = "send"
	// Close
	AlgorandTransferTypeClose AlgorandTransferType = "close"
	// Reward
	AlgorandTransferTypeReward AlgorandTransferType = "reward"
	// Asset Freeze
	AlgorandTransferTypeFreeze AlgorandTransferType = "freeze"
	// Asset Unfreeze
	AlgorandTransferTypeUnfreeze AlgorandTransferType = "unfreeze"
)

var AllAlgorandTransferType = []AlgorandTransferType{
	AlgorandTransferTypeGenesis,
	AlgorandTransferTypeCreate,
	AlgorandTransferTypeSend,
	AlgorandTransferTypeClose,
	AlgorandTransferTypeReward,
	AlgorandTransferTypeFreeze,
	AlgorandTransferTypeUnfreeze,
}

func (e AlgorandTransferType) IsValid() bool {
	switch e {
	case AlgorandTransferTypeGenesis, AlgorandTransferTypeCreate, AlgorandTransferTypeSend, AlgorandTransferTypeClose, AlgorandTransferTypeReward, AlgorandTransferTypeFreeze, AlgorandTransferTypeUnfreeze:
		return true
	}
	return false
}

func (e AlgorandTransferType) String() string {
	return string(e)
}

func (e *AlgorandTransferType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandTransferType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandTransferType", str)
	}
	return nil
}

func (e AlgorandTransferType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandTransfersMeasureable string

const (
	// Date
	AlgorandTransfersMeasureableDate AlgorandTransfersMeasureable = "date"
	// Time
	AlgorandTransfersMeasureableTime AlgorandTransfersMeasureable = "time"
	// Block
	AlgorandTransfersMeasureableBlock AlgorandTransfersMeasureable = "block"
	// Transaction hash
	AlgorandTransfersMeasureableTxHash AlgorandTransfersMeasureable = "tx_hash"
	// Amount
	AlgorandTransfersMeasureableAmount AlgorandTransfersMeasureable = "amount"
	// TX Sender
	AlgorandTransfersMeasureableTxSender AlgorandTransfersMeasureable = "tx_sender"
	// Sender
	AlgorandTransfersMeasureableSender AlgorandTransfersMeasureable = "sender"
	// Receiver
	AlgorandTransfersMeasureableReceiver AlgorandTransfersMeasureable = "receiver"
	// Currency symbol
	AlgorandTransfersMeasureableCurrencySymbol AlgorandTransfersMeasureable = "currency_symbol"
	// Currency Asset ID
	AlgorandTransfersMeasureableAssetID AlgorandTransfersMeasureable = "asset_id"
	// Transaction type
	AlgorandTransfersMeasureableTxType AlgorandTransfersMeasureable = "tx_type"
	// Transfer type
	AlgorandTransfersMeasureableTransferType AlgorandTransfersMeasureable = "transfer_type"
)

var AllAlgorandTransfersMeasureable = []AlgorandTransfersMeasureable{
	AlgorandTransfersMeasureableDate,
	AlgorandTransfersMeasureableTime,
	AlgorandTransfersMeasureableBlock,
	AlgorandTransfersMeasureableTxHash,
	AlgorandTransfersMeasureableAmount,
	AlgorandTransfersMeasureableTxSender,
	AlgorandTransfersMeasureableSender,
	AlgorandTransfersMeasureableReceiver,
	AlgorandTransfersMeasureableCurrencySymbol,
	AlgorandTransfersMeasureableAssetID,
	AlgorandTransfersMeasureableTxType,
	AlgorandTransfersMeasureableTransferType,
}

func (e AlgorandTransfersMeasureable) IsValid() bool {
	switch e {
	case AlgorandTransfersMeasureableDate, AlgorandTransfersMeasureableTime, AlgorandTransfersMeasureableBlock, AlgorandTransfersMeasureableTxHash, AlgorandTransfersMeasureableAmount, AlgorandTransfersMeasureableTxSender, AlgorandTransfersMeasureableSender, AlgorandTransfersMeasureableReceiver, AlgorandTransfersMeasureableCurrencySymbol, AlgorandTransfersMeasureableAssetID, AlgorandTransfersMeasureableTxType, AlgorandTransfersMeasureableTransferType:
		return true
	}
	return false
}

func (e AlgorandTransfersMeasureable) String() string {
	return string(e)
}

func (e *AlgorandTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandTransfersMeasureable", str)
	}
	return nil
}

func (e AlgorandTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandTxSubType string

const (
	// Send
	AlgorandTxSubTypeSend AlgorandTxSubType = "send"
	// Close
	AlgorandTxSubTypeClose AlgorandTxSubType = "close"
	// Create
	AlgorandTxSubTypeCreate AlgorandTxSubType = "create"
	// Asset Configuration
	AlgorandTxSubTypeConfigure AlgorandTxSubType = "configure"
	// Asset Freeze
	AlgorandTxSubTypeFreeze AlgorandTxSubType = "freeze"
	// Asset Unfreeze
	AlgorandTxSubTypeUnfreeze AlgorandTxSubType = "unfreeze"
	// Key Reg
	AlgorandTxSubTypeKeyreg AlgorandTxSubType = "keyreg"
	// None
	AlgorandTxSubTypeNone AlgorandTxSubType = "none"
)

var AllAlgorandTxSubType = []AlgorandTxSubType{
	AlgorandTxSubTypeSend,
	AlgorandTxSubTypeClose,
	AlgorandTxSubTypeCreate,
	AlgorandTxSubTypeConfigure,
	AlgorandTxSubTypeFreeze,
	AlgorandTxSubTypeUnfreeze,
	AlgorandTxSubTypeKeyreg,
	AlgorandTxSubTypeNone,
}

func (e AlgorandTxSubType) IsValid() bool {
	switch e {
	case AlgorandTxSubTypeSend, AlgorandTxSubTypeClose, AlgorandTxSubTypeCreate, AlgorandTxSubTypeConfigure, AlgorandTxSubTypeFreeze, AlgorandTxSubTypeUnfreeze, AlgorandTxSubTypeKeyreg, AlgorandTxSubTypeNone:
		return true
	}
	return false
}

func (e AlgorandTxSubType) String() string {
	return string(e)
}

func (e *AlgorandTxSubType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandTxSubType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandTxSubType", str)
	}
	return nil
}

func (e AlgorandTxSubType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlgorandTxType string

const (
	// Genesis Block
	AlgorandTxTypeGenesis AlgorandTxType = "genesis"
	// Pay
	AlgorandTxTypePay AlgorandTxType = "pay"
	// Key Reg
	AlgorandTxTypeKeyreg AlgorandTxType = "keyreg"
	// Asset Configuration
	AlgorandTxTypeAcfg AlgorandTxType = "acfg"
	// Asset Transfer
	AlgorandTxTypeAxfer AlgorandTxType = "axfer"
	// Asset Freeze or Unfreeze
	AlgorandTxTypeAfrz AlgorandTxType = "afrz"
	// Application Call
	AlgorandTxTypeAppl AlgorandTxType = "appl"
)

var AllAlgorandTxType = []AlgorandTxType{
	AlgorandTxTypeGenesis,
	AlgorandTxTypePay,
	AlgorandTxTypeKeyreg,
	AlgorandTxTypeAcfg,
	AlgorandTxTypeAxfer,
	AlgorandTxTypeAfrz,
	AlgorandTxTypeAppl,
}

func (e AlgorandTxType) IsValid() bool {
	switch e {
	case AlgorandTxTypeGenesis, AlgorandTxTypePay, AlgorandTxTypeKeyreg, AlgorandTxTypeAcfg, AlgorandTxTypeAxfer, AlgorandTxTypeAfrz, AlgorandTxTypeAppl:
		return true
	}
	return false
}

func (e AlgorandTxType) String() string {
	return string(e)
}

func (e *AlgorandTxType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlgorandTxType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlgorandTxType", str)
	}
	return nil
}

func (e AlgorandTxType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AmountAggregateFunction string

const (
	// Maximum
	AmountAggregateFunctionMaximum AmountAggregateFunction = "maximum"
	// Minimum
	AmountAggregateFunctionMinimum AmountAggregateFunction = "minimum"
	// Sum (total)
	AmountAggregateFunctionSum AmountAggregateFunction = "sum"
	// Average
	AmountAggregateFunctionAverage AmountAggregateFunction = "average"
	// Median
	AmountAggregateFunctionMedian AmountAggregateFunction = "median"
	// Unique estimate fast
	AmountAggregateFunctionUnique AmountAggregateFunction = "unique"
	// Unique exact
	AmountAggregateFunctionUniqueExact AmountAggregateFunction = "uniqueExact"
	// Any value
	AmountAggregateFunctionAny AmountAggregateFunction = "any"
	// Last value
	AmountAggregateFunctionAnyLast AmountAggregateFunction = "anyLast"
)

var AllAmountAggregateFunction = []AmountAggregateFunction{
	AmountAggregateFunctionMaximum,
	AmountAggregateFunctionMinimum,
	AmountAggregateFunctionSum,
	AmountAggregateFunctionAverage,
	AmountAggregateFunctionMedian,
	AmountAggregateFunctionUnique,
	AmountAggregateFunctionUniqueExact,
	AmountAggregateFunctionAny,
	AmountAggregateFunctionAnyLast,
}

func (e AmountAggregateFunction) IsValid() bool {
	switch e {
	case AmountAggregateFunctionMaximum, AmountAggregateFunctionMinimum, AmountAggregateFunctionSum, AmountAggregateFunctionAverage, AmountAggregateFunctionMedian, AmountAggregateFunctionUnique, AmountAggregateFunctionUniqueExact, AmountAggregateFunctionAny, AmountAggregateFunctionAnyLast:
		return true
	}
	return false
}

func (e AmountAggregateFunction) String() string {
	return string(e)
}

func (e *AmountAggregateFunction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AmountAggregateFunction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AmountAggregateFunction", str)
	}
	return nil
}

func (e AmountAggregateFunction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BaseCurrencyEnum string

const (
	// Dollar
	BaseCurrencyEnumUsd BaseCurrencyEnum = "USD"
	// Ethereum
	BaseCurrencyEnumEth BaseCurrencyEnum = "ETH"
	// Tether USDT
	BaseCurrencyEnumUsdt BaseCurrencyEnum = "USDT"
	// Bitcoin
	BaseCurrencyEnumBtc BaseCurrencyEnum = "BTC"
)

var AllBaseCurrencyEnum = []BaseCurrencyEnum{
	BaseCurrencyEnumUsd,
	BaseCurrencyEnumEth,
	BaseCurrencyEnumUsdt,
	BaseCurrencyEnumBtc,
}

func (e BaseCurrencyEnum) IsValid() bool {
	switch e {
	case BaseCurrencyEnumUsd, BaseCurrencyEnumEth, BaseCurrencyEnumUsdt, BaseCurrencyEnumBtc:
		return true
	}
	return false
}

func (e BaseCurrencyEnum) String() string {
	return string(e)
}

func (e *BaseCurrencyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BaseCurrencyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BaseCurrencyEnum", str)
	}
	return nil
}

func (e BaseCurrencyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceBlockUniq string

const (
	// Validator operators
	BinanceBlockUniqValidatorOperatorAddresses BinanceBlockUniq = "validator_operator_addresses"
	// Validator fee addresses
	BinanceBlockUniqValidatorFeeAddresses BinanceBlockUniq = "validator_fee_addresses"
	// Unique date count
	BinanceBlockUniqDates BinanceBlockUniq = "dates"
)

var AllBinanceBlockUniq = []BinanceBlockUniq{
	BinanceBlockUniqValidatorOperatorAddresses,
	BinanceBlockUniqValidatorFeeAddresses,
	BinanceBlockUniqDates,
}

func (e BinanceBlockUniq) IsValid() bool {
	switch e {
	case BinanceBlockUniqValidatorOperatorAddresses, BinanceBlockUniqValidatorFeeAddresses, BinanceBlockUniqDates:
		return true
	}
	return false
}

func (e BinanceBlockUniq) String() string {
	return string(e)
}

func (e *BinanceBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceBlockUniq", str)
	}
	return nil
}

func (e BinanceBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceBlocksMeasureable string

const (
	// Date
	BinanceBlocksMeasureableDate BinanceBlocksMeasureable = "date"
	// Time
	BinanceBlocksMeasureableTime BinanceBlocksMeasureable = "time"
	// Block
	BinanceBlocksMeasureableBlock BinanceBlocksMeasureable = "block"
	// Block hash
	BinanceBlocksMeasureableBlockHash BinanceBlocksMeasureable = "block_hash"
	// Validator moniker
	BinanceBlocksMeasureableValidatorMoniker BinanceBlocksMeasureable = "validator_moniker"
)

var AllBinanceBlocksMeasureable = []BinanceBlocksMeasureable{
	BinanceBlocksMeasureableDate,
	BinanceBlocksMeasureableTime,
	BinanceBlocksMeasureableBlock,
	BinanceBlocksMeasureableBlockHash,
	BinanceBlocksMeasureableValidatorMoniker,
}

func (e BinanceBlocksMeasureable) IsValid() bool {
	switch e {
	case BinanceBlocksMeasureableDate, BinanceBlocksMeasureableTime, BinanceBlocksMeasureableBlock, BinanceBlocksMeasureableBlockHash, BinanceBlocksMeasureableValidatorMoniker:
		return true
	}
	return false
}

func (e BinanceBlocksMeasureable) String() string {
	return string(e)
}

func (e *BinanceBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceBlocksMeasureable", str)
	}
	return nil
}

func (e BinanceBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceOrderSide string

const (
	// Sell Side
	BinanceOrderSideSell BinanceOrderSide = "sell"
	// Buy Side
	BinanceOrderSideBuy BinanceOrderSide = "buy"
)

var AllBinanceOrderSide = []BinanceOrderSide{
	BinanceOrderSideSell,
	BinanceOrderSideBuy,
}

func (e BinanceOrderSide) IsValid() bool {
	switch e {
	case BinanceOrderSideSell, BinanceOrderSideBuy:
		return true
	}
	return false
}

func (e BinanceOrderSide) String() string {
	return string(e)
}

func (e *BinanceOrderSide) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceOrderSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceOrderSide", str)
	}
	return nil
}

func (e BinanceOrderSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceOrderStatus string

const (
	// Ack
	BinanceOrderStatusAck BinanceOrderStatus = "Ack"
	// Canceled
	BinanceOrderStatusCanceled BinanceOrderStatus = "Canceled"
	// Fully Fill
	BinanceOrderStatusFullyFill BinanceOrderStatus = "FullyFill"
	// Partial Fill
	BinanceOrderStatusPartialFill BinanceOrderStatus = "PartialFill"
	// Expired
	BinanceOrderStatusExpired BinanceOrderStatus = "Expired"
	// Failed Blocking
	BinanceOrderStatusFailedBlocking BinanceOrderStatus = "FailedBlocking"
	// Ioc No Fill
	BinanceOrderStatusIocNoFill BinanceOrderStatus = "IocNoFill"
	// Ioc Expire
	BinanceOrderStatusIocExpire BinanceOrderStatus = "IocExpire"
)

var AllBinanceOrderStatus = []BinanceOrderStatus{
	BinanceOrderStatusAck,
	BinanceOrderStatusCanceled,
	BinanceOrderStatusFullyFill,
	BinanceOrderStatusPartialFill,
	BinanceOrderStatusExpired,
	BinanceOrderStatusFailedBlocking,
	BinanceOrderStatusIocNoFill,
	BinanceOrderStatusIocExpire,
}

func (e BinanceOrderStatus) IsValid() bool {
	switch e {
	case BinanceOrderStatusAck, BinanceOrderStatusCanceled, BinanceOrderStatusFullyFill, BinanceOrderStatusPartialFill, BinanceOrderStatusExpired, BinanceOrderStatusFailedBlocking, BinanceOrderStatusIocNoFill, BinanceOrderStatusIocExpire:
		return true
	}
	return false
}

func (e BinanceOrderStatus) String() string {
	return string(e)
}

func (e *BinanceOrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceOrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceOrderStatus", str)
	}
	return nil
}

func (e BinanceOrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceOrderTimeInForce string

const (
	// Good Till Expiry
	BinanceOrderTimeInForceGte BinanceOrderTimeInForce = "GTE"
	// Immediate Or Cancel
	BinanceOrderTimeInForceIoc BinanceOrderTimeInForce = "IOC"
)

var AllBinanceOrderTimeInForce = []BinanceOrderTimeInForce{
	BinanceOrderTimeInForceGte,
	BinanceOrderTimeInForceIoc,
}

func (e BinanceOrderTimeInForce) IsValid() bool {
	switch e {
	case BinanceOrderTimeInForceGte, BinanceOrderTimeInForceIoc:
		return true
	}
	return false
}

func (e BinanceOrderTimeInForce) String() string {
	return string(e)
}

func (e *BinanceOrderTimeInForce) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceOrderTimeInForce(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceOrderTimeInForce", str)
	}
	return nil
}

func (e BinanceOrderTimeInForce) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceOrderType string

const (
	// Limit Order
	BinanceOrderTypeLimitOrder BinanceOrderType = "LimitOrder"
)

var AllBinanceOrderType = []BinanceOrderType{
	BinanceOrderTypeLimitOrder,
}

func (e BinanceOrderType) IsValid() bool {
	switch e {
	case BinanceOrderTypeLimitOrder:
		return true
	}
	return false
}

func (e BinanceOrderType) String() string {
	return string(e)
}

func (e *BinanceOrderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceOrderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceOrderType", str)
	}
	return nil
}

func (e BinanceOrderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceOrdersMeasureable string

const (
	// Date
	BinanceOrdersMeasureableDate BinanceOrdersMeasureable = "date"
	// Time
	BinanceOrdersMeasureableTime BinanceOrdersMeasureable = "time"
	// Block
	BinanceOrdersMeasureableBlock BinanceOrdersMeasureable = "block"
	// Transaction hash
	BinanceOrdersMeasureableTxHash BinanceOrdersMeasureable = "tx_hash"
	// Order owner
	BinanceOrdersMeasureableOrderOwner BinanceOrdersMeasureable = "order_owner"
	// Order status
	BinanceOrdersMeasureableOrderStatus BinanceOrdersMeasureable = "order_status"
	// Order ID
	BinanceOrdersMeasureableOrderID BinanceOrdersMeasureable = "order_id"
	// Order side
	BinanceOrdersMeasureableOrderSide BinanceOrdersMeasureable = "order_side"
	// Base currency
	BinanceOrdersMeasureableBaseCurrency BinanceOrdersMeasureable = "base_currency"
	// Quote currency
	BinanceOrdersMeasureableQuoteCurrency BinanceOrdersMeasureable = "quote_currency"
	// Quote Amount
	BinanceOrdersMeasureableQuoteAmount BinanceOrdersMeasureable = "quote_amount"
	// Base Amount
	BinanceOrdersMeasureableBaseAmount BinanceOrdersMeasureable = "base_amount"
	// Price
	BinanceOrdersMeasureablePrice BinanceOrdersMeasureable = "price"
)

var AllBinanceOrdersMeasureable = []BinanceOrdersMeasureable{
	BinanceOrdersMeasureableDate,
	BinanceOrdersMeasureableTime,
	BinanceOrdersMeasureableBlock,
	BinanceOrdersMeasureableTxHash,
	BinanceOrdersMeasureableOrderOwner,
	BinanceOrdersMeasureableOrderStatus,
	BinanceOrdersMeasureableOrderID,
	BinanceOrdersMeasureableOrderSide,
	BinanceOrdersMeasureableBaseCurrency,
	BinanceOrdersMeasureableQuoteCurrency,
	BinanceOrdersMeasureableQuoteAmount,
	BinanceOrdersMeasureableBaseAmount,
	BinanceOrdersMeasureablePrice,
}

func (e BinanceOrdersMeasureable) IsValid() bool {
	switch e {
	case BinanceOrdersMeasureableDate, BinanceOrdersMeasureableTime, BinanceOrdersMeasureableBlock, BinanceOrdersMeasureableTxHash, BinanceOrdersMeasureableOrderOwner, BinanceOrdersMeasureableOrderStatus, BinanceOrdersMeasureableOrderID, BinanceOrdersMeasureableOrderSide, BinanceOrdersMeasureableBaseCurrency, BinanceOrdersMeasureableQuoteCurrency, BinanceOrdersMeasureableQuoteAmount, BinanceOrdersMeasureableBaseAmount, BinanceOrdersMeasureablePrice:
		return true
	}
	return false
}

func (e BinanceOrdersMeasureable) String() string {
	return string(e)
}

func (e *BinanceOrdersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceOrdersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceOrdersMeasureable", str)
	}
	return nil
}

func (e BinanceOrdersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceOrdersUniq string

const (
	// Unique Transactions
	BinanceOrdersUniqTxs BinanceOrdersUniq = "txs"
	// Unique order owners
	BinanceOrdersUniqOwners BinanceOrdersUniq = "owners"
	// Unique base currencies
	BinanceOrdersUniqBaseCurrencies BinanceOrdersUniq = "base_currencies"
	// Unique quote currencies
	BinanceOrdersUniqQuoteCurrencies BinanceOrdersUniq = "quote_currencies"
	// Unique blocks
	BinanceOrdersUniqBlocks BinanceOrdersUniq = "blocks"
	// Unique date count
	BinanceOrdersUniqDates BinanceOrdersUniq = "dates"
	// Unique order ID count
	BinanceOrdersUniqOrders BinanceOrdersUniq = "orders"
)

var AllBinanceOrdersUniq = []BinanceOrdersUniq{
	BinanceOrdersUniqTxs,
	BinanceOrdersUniqOwners,
	BinanceOrdersUniqBaseCurrencies,
	BinanceOrdersUniqQuoteCurrencies,
	BinanceOrdersUniqBlocks,
	BinanceOrdersUniqDates,
	BinanceOrdersUniqOrders,
}

func (e BinanceOrdersUniq) IsValid() bool {
	switch e {
	case BinanceOrdersUniqTxs, BinanceOrdersUniqOwners, BinanceOrdersUniqBaseCurrencies, BinanceOrdersUniqQuoteCurrencies, BinanceOrdersUniqBlocks, BinanceOrdersUniqDates, BinanceOrdersUniqOrders:
		return true
	}
	return false
}

func (e BinanceOrdersUniq) String() string {
	return string(e)
}

func (e *BinanceOrdersUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceOrdersUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceOrdersUniq", str)
	}
	return nil
}

func (e BinanceOrdersUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceTradesMeasureable string

const (
	// Date
	BinanceTradesMeasureableDate BinanceTradesMeasureable = "date"
	// Time
	BinanceTradesMeasureableTime BinanceTradesMeasureable = "time"
	// Block
	BinanceTradesMeasureableBlock BinanceTradesMeasureable = "block"
	// Transaction hash
	BinanceTradesMeasureableTxHash BinanceTradesMeasureable = "tx_hash"
	// Buyer
	BinanceTradesMeasureableBuyer BinanceTradesMeasureable = "buyer"
	// Seller
	BinanceTradesMeasureableSeller BinanceTradesMeasureable = "seller"
	// Trade ID
	BinanceTradesMeasureableTradeID BinanceTradesMeasureable = "trade_id"
	// Buy Order ID
	BinanceTradesMeasureableBuyOrderID BinanceTradesMeasureable = "buy_order_id"
	// Sell Order ID
	BinanceTradesMeasureableSellOrderID BinanceTradesMeasureable = "sell_order_id"
	// Base currency
	BinanceTradesMeasureableBaseCurrency BinanceTradesMeasureable = "base_currency"
	// Quote currency
	BinanceTradesMeasureableQuoteCurrency BinanceTradesMeasureable = "quote_currency"
	// Quote Amount
	BinanceTradesMeasureableQuoteAmount BinanceTradesMeasureable = "quote_amount"
	// Base Amount
	BinanceTradesMeasureableBaseAmount BinanceTradesMeasureable = "base_amount"
	// Price
	BinanceTradesMeasureablePrice BinanceTradesMeasureable = "price"
)

var AllBinanceTradesMeasureable = []BinanceTradesMeasureable{
	BinanceTradesMeasureableDate,
	BinanceTradesMeasureableTime,
	BinanceTradesMeasureableBlock,
	BinanceTradesMeasureableTxHash,
	BinanceTradesMeasureableBuyer,
	BinanceTradesMeasureableSeller,
	BinanceTradesMeasureableTradeID,
	BinanceTradesMeasureableBuyOrderID,
	BinanceTradesMeasureableSellOrderID,
	BinanceTradesMeasureableBaseCurrency,
	BinanceTradesMeasureableQuoteCurrency,
	BinanceTradesMeasureableQuoteAmount,
	BinanceTradesMeasureableBaseAmount,
	BinanceTradesMeasureablePrice,
}

func (e BinanceTradesMeasureable) IsValid() bool {
	switch e {
	case BinanceTradesMeasureableDate, BinanceTradesMeasureableTime, BinanceTradesMeasureableBlock, BinanceTradesMeasureableTxHash, BinanceTradesMeasureableBuyer, BinanceTradesMeasureableSeller, BinanceTradesMeasureableTradeID, BinanceTradesMeasureableBuyOrderID, BinanceTradesMeasureableSellOrderID, BinanceTradesMeasureableBaseCurrency, BinanceTradesMeasureableQuoteCurrency, BinanceTradesMeasureableQuoteAmount, BinanceTradesMeasureableBaseAmount, BinanceTradesMeasureablePrice:
		return true
	}
	return false
}

func (e BinanceTradesMeasureable) String() string {
	return string(e)
}

func (e *BinanceTradesMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceTradesMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceTradesMeasureable", str)
	}
	return nil
}

func (e BinanceTradesMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceTradesUniq string

const (
	// Trades
	BinanceTradesUniqTrades BinanceTradesUniq = "trades"
	// Sell Orders
	BinanceTradesUniqSellOrders BinanceTradesUniq = "sell_orders"
	// Buy Orders
	BinanceTradesUniqBuyOrders BinanceTradesUniq = "buy_orders"
	// Unique Transactions
	BinanceTradesUniqTxs BinanceTradesUniq = "txs"
	// Unique buyers count
	BinanceTradesUniqBuyers BinanceTradesUniq = "buyers"
	// Unique sellers count
	BinanceTradesUniqSellers BinanceTradesUniq = "sellers"
	// Unique base currencies
	BinanceTradesUniqBaseCurrencies BinanceTradesUniq = "base_currencies"
	// Unique quote currencies
	BinanceTradesUniqQuoteCurrencies BinanceTradesUniq = "quote_currencies"
	// Unique blocks
	BinanceTradesUniqBlocks BinanceTradesUniq = "blocks"
	// Unique date count
	BinanceTradesUniqDates BinanceTradesUniq = "dates"
)

var AllBinanceTradesUniq = []BinanceTradesUniq{
	BinanceTradesUniqTrades,
	BinanceTradesUniqSellOrders,
	BinanceTradesUniqBuyOrders,
	BinanceTradesUniqTxs,
	BinanceTradesUniqBuyers,
	BinanceTradesUniqSellers,
	BinanceTradesUniqBaseCurrencies,
	BinanceTradesUniqQuoteCurrencies,
	BinanceTradesUniqBlocks,
	BinanceTradesUniqDates,
}

func (e BinanceTradesUniq) IsValid() bool {
	switch e {
	case BinanceTradesUniqTrades, BinanceTradesUniqSellOrders, BinanceTradesUniqBuyOrders, BinanceTradesUniqTxs, BinanceTradesUniqBuyers, BinanceTradesUniqSellers, BinanceTradesUniqBaseCurrencies, BinanceTradesUniqQuoteCurrencies, BinanceTradesUniqBlocks, BinanceTradesUniqDates:
		return true
	}
	return false
}

func (e BinanceTradesUniq) String() string {
	return string(e)
}

func (e *BinanceTradesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceTradesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceTradesUniq", str)
	}
	return nil
}

func (e BinanceTradesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceTransactionType string

const (
	// New Order
	BinanceTransactionTypeNewOrder BinanceTransactionType = "NEW_ORDER"
	// Cancel Order
	BinanceTransactionTypeCancelOrder BinanceTransactionType = "CANCEL_ORDER"
	// Transfer
	BinanceTransactionTypeTransfer BinanceTransactionType = "TRANSFER"
	// Vote
	BinanceTransactionTypeVote BinanceTransactionType = "VOTE"
	// Unfreeze Token
	BinanceTransactionTypeUnfreezeToken BinanceTransactionType = "UNFREEZE_TOKEN"
	// Burn
	BinanceTransactionTypeBurn BinanceTransactionType = "BURN"
	// Freeze Token
	BinanceTransactionTypeFreezeToken BinanceTransactionType = "FREEZE_TOKEN"
	// Submit Proposal
	BinanceTransactionTypeSubmitProposal BinanceTransactionType = "SUBMIT_PROPOSAL"
	// Listing
	BinanceTransactionTypeListing BinanceTransactionType = "LISTING"
	// Issue
	BinanceTransactionTypeIssue BinanceTransactionType = "ISSUE"
	// Deposit
	BinanceTransactionTypeDeposit BinanceTransactionType = "DEPOSIT"
	// Mint
	BinanceTransactionTypeMint BinanceTransactionType = "MINT"
	// Time Lock
	BinanceTransactionTypeTimeLock BinanceTransactionType = "TimeLock"
	// Time Unlock
	BinanceTransactionTypeTimeUnlock BinanceTransactionType = "TimeUnlock"
	// Time Relock
	BinanceTransactionTypeTimeRelock BinanceTransactionType = "TimeRelock"
	// Set Account Flag
	BinanceTransactionTypeSetAccountFlag BinanceTransactionType = "SetAccountFlag"
	// Hash Timer Locked Transfer
	BinanceTransactionTypeHtlTransfer BinanceTransactionType = "HTL_TRANSFER"
	// Hash Timer Locked Deposit
	BinanceTransactionTypeDepositHtl BinanceTransactionType = "DEPOSIT_HTL"
	// Hash Timer Locked Claim
	BinanceTransactionTypeClaimHtl BinanceTransactionType = "CLAIM_HTL"
	// Hash Timer Locked  Refund
	BinanceTransactionTypeRefundHtl BinanceTransactionType = "REFUND_HTL"
	// Tiny Token Issue
	BinanceTransactionTypeTinyTokenIssue BinanceTransactionType = "TINY_TOKEN_ISSUE"
	// Mini Token Issue
	BinanceTransactionTypeMiniTokenIssue BinanceTransactionType = "MINI_TOKEN_ISSUE"
	// Tiny Token Listing
	BinanceTransactionTypeTinyTokenList BinanceTransactionType = "TINY_TOKEN_LIST"
	// Mini Token Listing
	BinanceTransactionTypeMiniTokenList BinanceTransactionType = "MINI_TOKEN_LIST"
	// Tiny Token Set URI
	BinanceTransactionTypeTinyTokenSetURI BinanceTransactionType = "TINY_TOKEN_SET_URI"
	// Mini Token Set URI
	BinanceTransactionTypeMiniTokenSetURI BinanceTransactionType = "MINI_TOKEN_SET_URI"
	// Create sidechain validator
	BinanceTransactionTypeCreateSidechainValidator BinanceTransactionType = "CREATE_SIDECHAIN_VALIDATOR"
	// Edit sidechain validator
	BinanceTransactionTypeEditSidechainValidator BinanceTransactionType = "EDIT_SIDECHAIN_VALIDATOR"
	// Delegate for sidechain
	BinanceTransactionTypeSidechainDelegate BinanceTransactionType = "SIDECHAIN_DELEGATE"
	// ReDelegate for sidechain
	BinanceTransactionTypeSidechainRedelegate BinanceTransactionType = "SIDECHAIN_REDELEGATE"
	// Unbond from sidechain
	BinanceTransactionTypeSidechainUnbond BinanceTransactionType = "SIDECHAIN_UNBOND"
	// Unjail from sidechain
	BinanceTransactionTypeSidechainUnjail BinanceTransactionType = "SIDECHAIN_UNJAIL"
	// Side chain submit poroposal
	BinanceTransactionTypeSideSubmitProposal BinanceTransactionType = "SIDE_SUBMIT_PROPOSAL"
	// Side chain deposit
	BinanceTransactionTypeSideDeposit BinanceTransactionType = "SIDE_DEPOSIT"
	// Side chain vote
	BinanceTransactionTypeSideVote BinanceTransactionType = "SIDE_VOTE"
	// Cross chain transfer
	BinanceTransactionTypeTransferOut BinanceTransactionType = "TRANSFER_OUT"
	// Submit evidence
	BinanceTransactionTypeBscSubmitEvidence BinanceTransactionType = "BSC_SUBMIT_EVIDENCE"
	// Cross chain claim
	BinanceTransactionTypeClaim BinanceTransactionType = "CLAIM"
	// Bind
	BinanceTransactionTypeBind BinanceTransactionType = "BIND"
	// UnBind
	BinanceTransactionTypeUnbind BinanceTransactionType = "UNBIND"
)

var AllBinanceTransactionType = []BinanceTransactionType{
	BinanceTransactionTypeNewOrder,
	BinanceTransactionTypeCancelOrder,
	BinanceTransactionTypeTransfer,
	BinanceTransactionTypeVote,
	BinanceTransactionTypeUnfreezeToken,
	BinanceTransactionTypeBurn,
	BinanceTransactionTypeFreezeToken,
	BinanceTransactionTypeSubmitProposal,
	BinanceTransactionTypeListing,
	BinanceTransactionTypeIssue,
	BinanceTransactionTypeDeposit,
	BinanceTransactionTypeMint,
	BinanceTransactionTypeTimeLock,
	BinanceTransactionTypeTimeUnlock,
	BinanceTransactionTypeTimeRelock,
	BinanceTransactionTypeSetAccountFlag,
	BinanceTransactionTypeHtlTransfer,
	BinanceTransactionTypeDepositHtl,
	BinanceTransactionTypeClaimHtl,
	BinanceTransactionTypeRefundHtl,
	BinanceTransactionTypeTinyTokenIssue,
	BinanceTransactionTypeMiniTokenIssue,
	BinanceTransactionTypeTinyTokenList,
	BinanceTransactionTypeMiniTokenList,
	BinanceTransactionTypeTinyTokenSetURI,
	BinanceTransactionTypeMiniTokenSetURI,
	BinanceTransactionTypeCreateSidechainValidator,
	BinanceTransactionTypeEditSidechainValidator,
	BinanceTransactionTypeSidechainDelegate,
	BinanceTransactionTypeSidechainRedelegate,
	BinanceTransactionTypeSidechainUnbond,
	BinanceTransactionTypeSidechainUnjail,
	BinanceTransactionTypeSideSubmitProposal,
	BinanceTransactionTypeSideDeposit,
	BinanceTransactionTypeSideVote,
	BinanceTransactionTypeTransferOut,
	BinanceTransactionTypeBscSubmitEvidence,
	BinanceTransactionTypeClaim,
	BinanceTransactionTypeBind,
	BinanceTransactionTypeUnbind,
}

func (e BinanceTransactionType) IsValid() bool {
	switch e {
	case BinanceTransactionTypeNewOrder, BinanceTransactionTypeCancelOrder, BinanceTransactionTypeTransfer, BinanceTransactionTypeVote, BinanceTransactionTypeUnfreezeToken, BinanceTransactionTypeBurn, BinanceTransactionTypeFreezeToken, BinanceTransactionTypeSubmitProposal, BinanceTransactionTypeListing, BinanceTransactionTypeIssue, BinanceTransactionTypeDeposit, BinanceTransactionTypeMint, BinanceTransactionTypeTimeLock, BinanceTransactionTypeTimeUnlock, BinanceTransactionTypeTimeRelock, BinanceTransactionTypeSetAccountFlag, BinanceTransactionTypeHtlTransfer, BinanceTransactionTypeDepositHtl, BinanceTransactionTypeClaimHtl, BinanceTransactionTypeRefundHtl, BinanceTransactionTypeTinyTokenIssue, BinanceTransactionTypeMiniTokenIssue, BinanceTransactionTypeTinyTokenList, BinanceTransactionTypeMiniTokenList, BinanceTransactionTypeTinyTokenSetURI, BinanceTransactionTypeMiniTokenSetURI, BinanceTransactionTypeCreateSidechainValidator, BinanceTransactionTypeEditSidechainValidator, BinanceTransactionTypeSidechainDelegate, BinanceTransactionTypeSidechainRedelegate, BinanceTransactionTypeSidechainUnbond, BinanceTransactionTypeSidechainUnjail, BinanceTransactionTypeSideSubmitProposal, BinanceTransactionTypeSideDeposit, BinanceTransactionTypeSideVote, BinanceTransactionTypeTransferOut, BinanceTransactionTypeBscSubmitEvidence, BinanceTransactionTypeClaim, BinanceTransactionTypeBind, BinanceTransactionTypeUnbind:
		return true
	}
	return false
}

func (e BinanceTransactionType) String() string {
	return string(e)
}

func (e *BinanceTransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceTransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceTransactionType", str)
	}
	return nil
}

func (e BinanceTransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceTransactionsMeasureable string

const (
	// Date
	BinanceTransactionsMeasureableDate BinanceTransactionsMeasureable = "date"
	// Time
	BinanceTransactionsMeasureableTime BinanceTransactionsMeasureable = "time"
	// Block
	BinanceTransactionsMeasureableBlock BinanceTransactionsMeasureable = "block"
	// Transaction hash
	BinanceTransactionsMeasureableTxHash BinanceTransactionsMeasureable = "tx_hash"
	// Transaction Source Name
	BinanceTransactionsMeasureableTransactionSourceName BinanceTransactionsMeasureable = "transaction_source_name"
	// Transaction Source Code
	BinanceTransactionsMeasureableTransactionSourceCode BinanceTransactionsMeasureable = "transaction_source_code"
	// Transaction Code
	BinanceTransactionsMeasureableTransactionCode BinanceTransactionsMeasureable = "transaction_code"
	// Transaction Type
	BinanceTransactionsMeasureableTransactionType BinanceTransactionsMeasureable = "transaction_type"
	// Transaction Memo
	BinanceTransactionsMeasureableTransactionMemo BinanceTransactionsMeasureable = "transaction_memo"
	// Currency
	BinanceTransactionsMeasureableCurrencySymbol BinanceTransactionsMeasureable = "currency_symbol"
)

var AllBinanceTransactionsMeasureable = []BinanceTransactionsMeasureable{
	BinanceTransactionsMeasureableDate,
	BinanceTransactionsMeasureableTime,
	BinanceTransactionsMeasureableBlock,
	BinanceTransactionsMeasureableTxHash,
	BinanceTransactionsMeasureableTransactionSourceName,
	BinanceTransactionsMeasureableTransactionSourceCode,
	BinanceTransactionsMeasureableTransactionCode,
	BinanceTransactionsMeasureableTransactionType,
	BinanceTransactionsMeasureableTransactionMemo,
	BinanceTransactionsMeasureableCurrencySymbol,
}

func (e BinanceTransactionsMeasureable) IsValid() bool {
	switch e {
	case BinanceTransactionsMeasureableDate, BinanceTransactionsMeasureableTime, BinanceTransactionsMeasureableBlock, BinanceTransactionsMeasureableTxHash, BinanceTransactionsMeasureableTransactionSourceName, BinanceTransactionsMeasureableTransactionSourceCode, BinanceTransactionsMeasureableTransactionCode, BinanceTransactionsMeasureableTransactionType, BinanceTransactionsMeasureableTransactionMemo, BinanceTransactionsMeasureableCurrencySymbol:
		return true
	}
	return false
}

func (e BinanceTransactionsMeasureable) String() string {
	return string(e)
}

func (e *BinanceTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceTransactionsMeasureable", str)
	}
	return nil
}

func (e BinanceTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceTransactionsUniq string

const (
	// Unique blocks
	BinanceTransactionsUniqBlocks BinanceTransactionsUniq = "blocks"
	// Unique date count
	BinanceTransactionsUniqDates BinanceTransactionsUniq = "dates"
	// Unique transaction source count
	BinanceTransactionsUniqTransactionSources BinanceTransactionsUniq = "transaction_sources"
)

var AllBinanceTransactionsUniq = []BinanceTransactionsUniq{
	BinanceTransactionsUniqBlocks,
	BinanceTransactionsUniqDates,
	BinanceTransactionsUniqTransactionSources,
}

func (e BinanceTransactionsUniq) IsValid() bool {
	switch e {
	case BinanceTransactionsUniqBlocks, BinanceTransactionsUniqDates, BinanceTransactionsUniqTransactionSources:
		return true
	}
	return false
}

func (e BinanceTransactionsUniq) String() string {
	return string(e)
}

func (e *BinanceTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceTransactionsUniq", str)
	}
	return nil
}

func (e BinanceTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceTransferType string

const (
	// Reward for block
	BinanceTransferTypeBlockReward BinanceTransferType = "BLOCK_REWARD"
	// Burning amount
	BinanceTransferTypeBurn BinanceTransferType = "BURN"
	// Claiming Hash Timer Locked Transfer
	BinanceTransferTypeClaimHtl BinanceTransferType = "CLAIM_HTL"
	// Deposit for Hash Timer Locked Transfer
	BinanceTransferTypeDepositHtl BinanceTransferType = "DEPOSIT_HTL"
	// Fee for DEX orders
	BinanceTransferTypeDexFee BinanceTransferType = "DEX_FEE"
	// Genesis declaration
	BinanceTransferTypeGenesisDelegation BinanceTransferType = "GENESIS_DELEGATION"
	// Genesis supply declaration
	BinanceTransferTypeGenesisSupply BinanceTransferType = "GENESIS_SUPPLY"
	// Tiny Token Issue
	BinanceTransferTypeTinyTokenIssue BinanceTransferType = "TINY_TOKEN_ISSUE"
	// Mini Token Issue
	BinanceTransferTypeMiniTokenIssue BinanceTransferType = "MINI_TOKEN_ISSUE"
	// Hash Timer Locked Transfer
	BinanceTransferTypeHtlTransfer BinanceTransferType = "HTL_TRANSFER"
	// Issue token
	BinanceTransferTypeIssue BinanceTransferType = "ISSUE"
	// Mint token
	BinanceTransferTypeMint BinanceTransferType = "MINT"
	// Trade buy side
	BinanceTransferTypeTradeBuy BinanceTransferType = "TRADE_BUY"
	// Trade sell side
	BinanceTransferTypeTradeSell BinanceTransferType = "TRADE_SELL"
	// Transfer
	BinanceTransferTypeTransfer BinanceTransferType = "TRANSFER"
	// Transaction fee
	BinanceTransferTypeTxFee BinanceTransferType = "TX_FEE"
	// Create sidechain validator
	BinanceTransferTypeCreateSidechainValidator BinanceTransferType = "CREATE_SIDECHAIN_VALIDATOR"
	// Edit sidechain validator
	BinanceTransferTypeEditSidechainValidator BinanceTransferType = "EDIT_SIDECHAIN_VALIDATOR"
	// Delegate for sidechain
	BinanceTransferTypeSidechainDelegate BinanceTransferType = "SIDECHAIN_DELEGATE"
	// ReDelegate for sidechain
	BinanceTransferTypeSidechainRedelegate BinanceTransferType = "SIDECHAIN_REDELEGATE"
	// Unbond from sidechain
	BinanceTransferTypeSidechainUnbond BinanceTransferType = "SIDECHAIN_UNBOND"
	// Side chain submit poroposal
	BinanceTransferTypeSideSubmitProposal BinanceTransferType = "SIDE_SUBMIT_PROPOSAL"
	// Side chain deposit
	BinanceTransferTypeSideDeposit BinanceTransferType = "SIDE_DEPOSIT"
	// Side chain vote
	BinanceTransferTypeSideVote BinanceTransferType = "SIDE_VOTE"
	// Cross chain transfer
	BinanceTransferTypeTransferOut BinanceTransferType = "TRANSFER_OUT"
	// Submit evidence
	BinanceTransferTypeBscSubmitEvidence BinanceTransferType = "BSC_SUBMIT_EVIDENCE"
	// Cross chain claim
	BinanceTransferTypeClaim BinanceTransferType = "CLAIM"
	// Bind
	BinanceTransferTypeBind BinanceTransferType = "BIND"
	// UnBind
	BinanceTransferTypeUnbind BinanceTransferType = "UNBIND"
)

var AllBinanceTransferType = []BinanceTransferType{
	BinanceTransferTypeBlockReward,
	BinanceTransferTypeBurn,
	BinanceTransferTypeClaimHtl,
	BinanceTransferTypeDepositHtl,
	BinanceTransferTypeDexFee,
	BinanceTransferTypeGenesisDelegation,
	BinanceTransferTypeGenesisSupply,
	BinanceTransferTypeTinyTokenIssue,
	BinanceTransferTypeMiniTokenIssue,
	BinanceTransferTypeHtlTransfer,
	BinanceTransferTypeIssue,
	BinanceTransferTypeMint,
	BinanceTransferTypeTradeBuy,
	BinanceTransferTypeTradeSell,
	BinanceTransferTypeTransfer,
	BinanceTransferTypeTxFee,
	BinanceTransferTypeCreateSidechainValidator,
	BinanceTransferTypeEditSidechainValidator,
	BinanceTransferTypeSidechainDelegate,
	BinanceTransferTypeSidechainRedelegate,
	BinanceTransferTypeSidechainUnbond,
	BinanceTransferTypeSideSubmitProposal,
	BinanceTransferTypeSideDeposit,
	BinanceTransferTypeSideVote,
	BinanceTransferTypeTransferOut,
	BinanceTransferTypeBscSubmitEvidence,
	BinanceTransferTypeClaim,
	BinanceTransferTypeBind,
	BinanceTransferTypeUnbind,
}

func (e BinanceTransferType) IsValid() bool {
	switch e {
	case BinanceTransferTypeBlockReward, BinanceTransferTypeBurn, BinanceTransferTypeClaimHtl, BinanceTransferTypeDepositHtl, BinanceTransferTypeDexFee, BinanceTransferTypeGenesisDelegation, BinanceTransferTypeGenesisSupply, BinanceTransferTypeTinyTokenIssue, BinanceTransferTypeMiniTokenIssue, BinanceTransferTypeHtlTransfer, BinanceTransferTypeIssue, BinanceTransferTypeMint, BinanceTransferTypeTradeBuy, BinanceTransferTypeTradeSell, BinanceTransferTypeTransfer, BinanceTransferTypeTxFee, BinanceTransferTypeCreateSidechainValidator, BinanceTransferTypeEditSidechainValidator, BinanceTransferTypeSidechainDelegate, BinanceTransferTypeSidechainRedelegate, BinanceTransferTypeSidechainUnbond, BinanceTransferTypeSideSubmitProposal, BinanceTransferTypeSideDeposit, BinanceTransferTypeSideVote, BinanceTransferTypeTransferOut, BinanceTransferTypeBscSubmitEvidence, BinanceTransferTypeClaim, BinanceTransferTypeBind, BinanceTransferTypeUnbind:
		return true
	}
	return false
}

func (e BinanceTransferType) String() string {
	return string(e)
}

func (e *BinanceTransferType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceTransferType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceTransferType", str)
	}
	return nil
}

func (e BinanceTransferType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BinanceTransfersMeasureable string

const (
	// Date
	BinanceTransfersMeasureableDate BinanceTransfersMeasureable = "date"
	// Time
	BinanceTransfersMeasureableTime BinanceTransfersMeasureable = "time"
	// Block
	BinanceTransfersMeasureableBlock BinanceTransfersMeasureable = "block"
	// Transaction hash
	BinanceTransfersMeasureableTxHash BinanceTransfersMeasureable = "tx_hash"
	// Amount
	BinanceTransfersMeasureableAmount BinanceTransfersMeasureable = "amount"
	// Sender
	BinanceTransfersMeasureableSender BinanceTransfersMeasureable = "sender"
	// Receiver
	BinanceTransfersMeasureableReceiver BinanceTransfersMeasureable = "receiver"
	// Currency symbol
	BinanceTransfersMeasureableCurrencySymbol BinanceTransfersMeasureable = "currency_symbol"
)

var AllBinanceTransfersMeasureable = []BinanceTransfersMeasureable{
	BinanceTransfersMeasureableDate,
	BinanceTransfersMeasureableTime,
	BinanceTransfersMeasureableBlock,
	BinanceTransfersMeasureableTxHash,
	BinanceTransfersMeasureableAmount,
	BinanceTransfersMeasureableSender,
	BinanceTransfersMeasureableReceiver,
	BinanceTransfersMeasureableCurrencySymbol,
}

func (e BinanceTransfersMeasureable) IsValid() bool {
	switch e {
	case BinanceTransfersMeasureableDate, BinanceTransfersMeasureableTime, BinanceTransfersMeasureableBlock, BinanceTransfersMeasureableTxHash, BinanceTransfersMeasureableAmount, BinanceTransfersMeasureableSender, BinanceTransfersMeasureableReceiver, BinanceTransfersMeasureableCurrencySymbol:
		return true
	}
	return false
}

func (e BinanceTransfersMeasureable) String() string {
	return string(e)
}

func (e *BinanceTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BinanceTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BinanceTransfersMeasureable", str)
	}
	return nil
}

func (e BinanceTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinBlockUniq string

const (
	// Unique date count
	BitcoinBlockUniqDates BitcoinBlockUniq = "dates"
)

var AllBitcoinBlockUniq = []BitcoinBlockUniq{
	BitcoinBlockUniqDates,
}

func (e BitcoinBlockUniq) IsValid() bool {
	switch e {
	case BitcoinBlockUniqDates:
		return true
	}
	return false
}

func (e BitcoinBlockUniq) String() string {
	return string(e)
}

func (e *BitcoinBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinBlockUniq", str)
	}
	return nil
}

func (e BitcoinBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinBlocksMeasureable string

const (
	// Date
	BitcoinBlocksMeasureableDate BitcoinBlocksMeasureable = "date"
	// Time
	BitcoinBlocksMeasureableTime BitcoinBlocksMeasureable = "time"
	// Block
	BitcoinBlocksMeasureableBlock BitcoinBlocksMeasureable = "block"
	// Block hash
	BitcoinBlocksMeasureableBlockHash BitcoinBlocksMeasureable = "block_hash"
	// Tx Count
	BitcoinBlocksMeasureableTransactionCount BitcoinBlocksMeasureable = "transaction_count"
)

var AllBitcoinBlocksMeasureable = []BitcoinBlocksMeasureable{
	BitcoinBlocksMeasureableDate,
	BitcoinBlocksMeasureableTime,
	BitcoinBlocksMeasureableBlock,
	BitcoinBlocksMeasureableBlockHash,
	BitcoinBlocksMeasureableTransactionCount,
}

func (e BitcoinBlocksMeasureable) IsValid() bool {
	switch e {
	case BitcoinBlocksMeasureableDate, BitcoinBlocksMeasureableTime, BitcoinBlocksMeasureableBlock, BitcoinBlocksMeasureableBlockHash, BitcoinBlocksMeasureableTransactionCount:
		return true
	}
	return false
}

func (e BitcoinBlocksMeasureable) String() string {
	return string(e)
}

func (e *BitcoinBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinBlocksMeasureable", str)
	}
	return nil
}

func (e BitcoinBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinCoinpathMethod string

const (
	// Tracking money flow by amounts, ignoring coins (default)
	BitcoinCoinpathMethodMoneyflow BitcoinCoinpathMethod = "moneyflow"
	// Tracking coins by UTXO transactions
	BitcoinCoinpathMethodUtxo BitcoinCoinpathMethod = "utxo"
)

var AllBitcoinCoinpathMethod = []BitcoinCoinpathMethod{
	BitcoinCoinpathMethodMoneyflow,
	BitcoinCoinpathMethodUtxo,
}

func (e BitcoinCoinpathMethod) IsValid() bool {
	switch e {
	case BitcoinCoinpathMethodMoneyflow, BitcoinCoinpathMethodUtxo:
		return true
	}
	return false
}

func (e BitcoinCoinpathMethod) String() string {
	return string(e)
}

func (e *BitcoinCoinpathMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinCoinpathMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinCoinpathMethod", str)
	}
	return nil
}

func (e BitcoinCoinpathMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinInputScriptType string

const (
	// Input Script Signature
	BitcoinInputScriptTypeScriptSig BitcoinInputScriptType = "scriptSig"
	// Input Script TX Witness Script
	BitcoinInputScriptTypeTxinwitness BitcoinInputScriptType = "txinwitness"
	// Input Script Coinbase Script
	BitcoinInputScriptTypeCoinbase BitcoinInputScriptType = "coinbase"
)

var AllBitcoinInputScriptType = []BitcoinInputScriptType{
	BitcoinInputScriptTypeScriptSig,
	BitcoinInputScriptTypeTxinwitness,
	BitcoinInputScriptTypeCoinbase,
}

func (e BitcoinInputScriptType) IsValid() bool {
	switch e {
	case BitcoinInputScriptTypeScriptSig, BitcoinInputScriptTypeTxinwitness, BitcoinInputScriptTypeCoinbase:
		return true
	}
	return false
}

func (e BitcoinInputScriptType) String() string {
	return string(e)
}

func (e *BitcoinInputScriptType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinInputScriptType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinInputScriptType", str)
	}
	return nil
}

func (e BitcoinInputScriptType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinInputUniq string

const (
	// Unique transactions count
	BitcoinInputUniqTransactions BitcoinInputUniq = "transactions"
	// Unique block count
	BitcoinInputUniqBlocks BitcoinInputUniq = "blocks"
	// Unique date count
	BitcoinInputUniqDates BitcoinInputUniq = "dates"
	// Unique addresses count
	BitcoinInputUniqAddresses BitcoinInputUniq = "addresses"
)

var AllBitcoinInputUniq = []BitcoinInputUniq{
	BitcoinInputUniqTransactions,
	BitcoinInputUniqBlocks,
	BitcoinInputUniqDates,
	BitcoinInputUniqAddresses,
}

func (e BitcoinInputUniq) IsValid() bool {
	switch e {
	case BitcoinInputUniqTransactions, BitcoinInputUniqBlocks, BitcoinInputUniqDates, BitcoinInputUniqAddresses:
		return true
	}
	return false
}

func (e BitcoinInputUniq) String() string {
	return string(e)
}

func (e *BitcoinInputUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinInputUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinInputUniq", str)
	}
	return nil
}

func (e BitcoinInputUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinInputsMeasureable string

const (
	// Date
	BitcoinInputsMeasureableDate BitcoinInputsMeasureable = "date"
	// Time
	BitcoinInputsMeasureableTime BitcoinInputsMeasureable = "time"
	// Block
	BitcoinInputsMeasureableBlock BitcoinInputsMeasureable = "block"
	// Transaction hash
	BitcoinInputsMeasureableTxHash BitcoinInputsMeasureable = "tx_hash"
	// Transaction index
	BitcoinInputsMeasureableTxIndex BitcoinInputsMeasureable = "tx_index"
	// Amount
	BitcoinInputsMeasureableAmount BitcoinInputsMeasureable = "amount"
	// Address
	BitcoinInputsMeasureableAddress BitcoinInputsMeasureable = "address"
	// Input index
	BitcoinInputsMeasureableInputIndex BitcoinInputsMeasureable = "input_index"
)

var AllBitcoinInputsMeasureable = []BitcoinInputsMeasureable{
	BitcoinInputsMeasureableDate,
	BitcoinInputsMeasureableTime,
	BitcoinInputsMeasureableBlock,
	BitcoinInputsMeasureableTxHash,
	BitcoinInputsMeasureableTxIndex,
	BitcoinInputsMeasureableAmount,
	BitcoinInputsMeasureableAddress,
	BitcoinInputsMeasureableInputIndex,
}

func (e BitcoinInputsMeasureable) IsValid() bool {
	switch e {
	case BitcoinInputsMeasureableDate, BitcoinInputsMeasureableTime, BitcoinInputsMeasureableBlock, BitcoinInputsMeasureableTxHash, BitcoinInputsMeasureableTxIndex, BitcoinInputsMeasureableAmount, BitcoinInputsMeasureableAddress, BitcoinInputsMeasureableInputIndex:
		return true
	}
	return false
}

func (e BitcoinInputsMeasureable) String() string {
	return string(e)
}

func (e *BitcoinInputsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinInputsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinInputsMeasureable", str)
	}
	return nil
}

func (e BitcoinInputsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinNetwork string

const (
	// Bitcoin ( BTC )
	BitcoinNetworkBitcoin BitcoinNetwork = "bitcoin"
	// Bitcoin Cash ( BCH )
	BitcoinNetworkBitcash BitcoinNetwork = "bitcash"
	// Bitcoin SV ( BSV )
	BitcoinNetworkBitcoinsv BitcoinNetwork = "bitcoinsv"
	// Litecoin ( LTC )
	BitcoinNetworkLitecoin BitcoinNetwork = "litecoin"
	// Dash ( DASH )
	BitcoinNetworkDash BitcoinNetwork = "dash"
	// Dogecoin ( DOGE )
	BitcoinNetworkDogecoin BitcoinNetwork = "dogecoin"
	// ZCash ( ZCASH )
	BitcoinNetworkZcash BitcoinNetwork = "zcash"
)

var AllBitcoinNetwork = []BitcoinNetwork{
	BitcoinNetworkBitcoin,
	BitcoinNetworkBitcash,
	BitcoinNetworkBitcoinsv,
	BitcoinNetworkLitecoin,
	BitcoinNetworkDash,
	BitcoinNetworkDogecoin,
	BitcoinNetworkZcash,
}

func (e BitcoinNetwork) IsValid() bool {
	switch e {
	case BitcoinNetworkBitcoin, BitcoinNetworkBitcash, BitcoinNetworkBitcoinsv, BitcoinNetworkLitecoin, BitcoinNetworkDash, BitcoinNetworkDogecoin, BitcoinNetworkZcash:
		return true
	}
	return false
}

func (e BitcoinNetwork) String() string {
	return string(e)
}

func (e *BitcoinNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinNetwork", str)
	}
	return nil
}

func (e BitcoinNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOmniTransactionsMeasureablse string

const (
	// Date
	BitcoinOmniTransactionsMeasureablseDate BitcoinOmniTransactionsMeasureablse = "date"
	// Time
	BitcoinOmniTransactionsMeasureablseTime BitcoinOmniTransactionsMeasureablse = "time"
	// Block
	BitcoinOmniTransactionsMeasureablseBlock BitcoinOmniTransactionsMeasureablse = "block"
	// Transactions hash
	BitcoinOmniTransactionsMeasureablseTxHash BitcoinOmniTransactionsMeasureablse = "tx_hash"
	// Transactions index
	BitcoinOmniTransactionsMeasureablseTxIndex BitcoinOmniTransactionsMeasureablse = "tx_index"
)

var AllBitcoinOmniTransactionsMeasureablse = []BitcoinOmniTransactionsMeasureablse{
	BitcoinOmniTransactionsMeasureablseDate,
	BitcoinOmniTransactionsMeasureablseTime,
	BitcoinOmniTransactionsMeasureablseBlock,
	BitcoinOmniTransactionsMeasureablseTxHash,
	BitcoinOmniTransactionsMeasureablseTxIndex,
}

func (e BitcoinOmniTransactionsMeasureablse) IsValid() bool {
	switch e {
	case BitcoinOmniTransactionsMeasureablseDate, BitcoinOmniTransactionsMeasureablseTime, BitcoinOmniTransactionsMeasureablseBlock, BitcoinOmniTransactionsMeasureablseTxHash, BitcoinOmniTransactionsMeasureablseTxIndex:
		return true
	}
	return false
}

func (e BitcoinOmniTransactionsMeasureablse) String() string {
	return string(e)
}

func (e *BitcoinOmniTransactionsMeasureablse) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOmniTransactionsMeasureablse(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOmniTransactionsMeasureablse", str)
	}
	return nil
}

func (e BitcoinOmniTransactionsMeasureablse) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOmniTransactionsUniq string

const (
	// Unique block count
	BitcoinOmniTransactionsUniqBlocks BitcoinOmniTransactionsUniq = "blocks"
	// Unique date count
	BitcoinOmniTransactionsUniqDates BitcoinOmniTransactionsUniq = "dates"
	// Unique transaction sender
	BitcoinOmniTransactionsUniqTxSender BitcoinOmniTransactionsUniq = "tx_sender"
)

var AllBitcoinOmniTransactionsUniq = []BitcoinOmniTransactionsUniq{
	BitcoinOmniTransactionsUniqBlocks,
	BitcoinOmniTransactionsUniqDates,
	BitcoinOmniTransactionsUniqTxSender,
}

func (e BitcoinOmniTransactionsUniq) IsValid() bool {
	switch e {
	case BitcoinOmniTransactionsUniqBlocks, BitcoinOmniTransactionsUniqDates, BitcoinOmniTransactionsUniqTxSender:
		return true
	}
	return false
}

func (e BitcoinOmniTransactionsUniq) String() string {
	return string(e)
}

func (e *BitcoinOmniTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOmniTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOmniTransactionsUniq", str)
	}
	return nil
}

func (e BitcoinOmniTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOmniTransfersMeasureablse string

const (
	// Date
	BitcoinOmniTransfersMeasureablseDate BitcoinOmniTransfersMeasureablse = "date"
	// Time
	BitcoinOmniTransfersMeasureablseTime BitcoinOmniTransfersMeasureablse = "time"
	// Block
	BitcoinOmniTransfersMeasureablseBlock BitcoinOmniTransfersMeasureablse = "block"
	// Transactions hash
	BitcoinOmniTransfersMeasureablseTxHash BitcoinOmniTransfersMeasureablse = "tx_hash"
	// Transactions index
	BitcoinOmniTransfersMeasureablseTxIndex BitcoinOmniTransfersMeasureablse = "tx_index"
)

var AllBitcoinOmniTransfersMeasureablse = []BitcoinOmniTransfersMeasureablse{
	BitcoinOmniTransfersMeasureablseDate,
	BitcoinOmniTransfersMeasureablseTime,
	BitcoinOmniTransfersMeasureablseBlock,
	BitcoinOmniTransfersMeasureablseTxHash,
	BitcoinOmniTransfersMeasureablseTxIndex,
}

func (e BitcoinOmniTransfersMeasureablse) IsValid() bool {
	switch e {
	case BitcoinOmniTransfersMeasureablseDate, BitcoinOmniTransfersMeasureablseTime, BitcoinOmniTransfersMeasureablseBlock, BitcoinOmniTransfersMeasureablseTxHash, BitcoinOmniTransfersMeasureablseTxIndex:
		return true
	}
	return false
}

func (e BitcoinOmniTransfersMeasureablse) String() string {
	return string(e)
}

func (e *BitcoinOmniTransfersMeasureablse) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOmniTransfersMeasureablse(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOmniTransfersMeasureablse", str)
	}
	return nil
}

func (e BitcoinOmniTransfersMeasureablse) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOmniTransfersUniq string

const (
	// Unique block count
	BitcoinOmniTransfersUniqBlocks BitcoinOmniTransfersUniq = "blocks"
	// Unique date count
	BitcoinOmniTransfersUniqDates BitcoinOmniTransfersUniq = "dates"
	// Unique transaction sender
	BitcoinOmniTransfersUniqTxSender BitcoinOmniTransfersUniq = "tx_sender"
)

var AllBitcoinOmniTransfersUniq = []BitcoinOmniTransfersUniq{
	BitcoinOmniTransfersUniqBlocks,
	BitcoinOmniTransfersUniqDates,
	BitcoinOmniTransfersUniqTxSender,
}

func (e BitcoinOmniTransfersUniq) IsValid() bool {
	switch e {
	case BitcoinOmniTransfersUniqBlocks, BitcoinOmniTransfersUniqDates, BitcoinOmniTransfersUniqTxSender:
		return true
	}
	return false
}

func (e BitcoinOmniTransfersUniq) String() string {
	return string(e)
}

func (e *BitcoinOmniTransfersUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOmniTransfersUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOmniTransfersUniq", str)
	}
	return nil
}

func (e BitcoinOmniTransfersUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOutputDirection string

const (
	// Not defined
	BitcoinOutputDirectionUnknown BitcoinOutputDirection = "unknown"
	// Not a change return
	BitcoinOutputDirectionNotChange BitcoinOutputDirection = "not_change"
	// Change return
	BitcoinOutputDirectionChange BitcoinOutputDirection = "change"
	// Likely Not a change return
	BitcoinOutputDirectionLikelyNotChange BitcoinOutputDirection = "likely_not_change"
	// Likely Change return
	BitcoinOutputDirectionLikelyChange BitcoinOutputDirection = "likely_change"
	// Mining
	BitcoinOutputDirectionMining BitcoinOutputDirection = "mining"
	// Fee
	BitcoinOutputDirectionFee BitcoinOutputDirection = "fee"
	// Minting
	BitcoinOutputDirectionMinting BitcoinOutputDirection = "minting"
	// Genesis
	BitcoinOutputDirectionGenesis BitcoinOutputDirection = "genesis"
)

var AllBitcoinOutputDirection = []BitcoinOutputDirection{
	BitcoinOutputDirectionUnknown,
	BitcoinOutputDirectionNotChange,
	BitcoinOutputDirectionChange,
	BitcoinOutputDirectionLikelyNotChange,
	BitcoinOutputDirectionLikelyChange,
	BitcoinOutputDirectionMining,
	BitcoinOutputDirectionFee,
	BitcoinOutputDirectionMinting,
	BitcoinOutputDirectionGenesis,
}

func (e BitcoinOutputDirection) IsValid() bool {
	switch e {
	case BitcoinOutputDirectionUnknown, BitcoinOutputDirectionNotChange, BitcoinOutputDirectionChange, BitcoinOutputDirectionLikelyNotChange, BitcoinOutputDirectionLikelyChange, BitcoinOutputDirectionMining, BitcoinOutputDirectionFee, BitcoinOutputDirectionMinting, BitcoinOutputDirectionGenesis:
		return true
	}
	return false
}

func (e BitcoinOutputDirection) String() string {
	return string(e)
}

func (e *BitcoinOutputDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOutputDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOutputDirection", str)
	}
	return nil
}

func (e BitcoinOutputDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOutputScriptType string

const (
	// Output PubKey
	BitcoinOutputScriptTypePubkey BitcoinOutputScriptType = "pubkey"
	// Output PubKey Hash
	BitcoinOutputScriptTypePubkeyhash BitcoinOutputScriptType = "pubkeyhash"
	// Output Script Hash
	BitcoinOutputScriptTypeScripthash BitcoinOutputScriptType = "scripthash"
	// Output Witness Key Hash
	BitcoinOutputScriptTypeWitnessV0Keyhash BitcoinOutputScriptType = "witness_v0_keyhash"
	// Output nulldata
	BitcoinOutputScriptTypeNulldata BitcoinOutputScriptType = "nulldata"
	// Output Witness Script Hash
	BitcoinOutputScriptTypeWitnessV0Scripthash BitcoinOutputScriptType = "witness_v0_scripthash"
	// Non standard output script
	BitcoinOutputScriptTypeNonstandard BitcoinOutputScriptType = "nonstandard"
	// Output Multisignature Wallet
	BitcoinOutputScriptTypeMultisig BitcoinOutputScriptType = "multisig"
	// Output Witness Other
	BitcoinOutputScriptTypeWitnessUnknown BitcoinOutputScriptType = "witness_unknown"
)

var AllBitcoinOutputScriptType = []BitcoinOutputScriptType{
	BitcoinOutputScriptTypePubkey,
	BitcoinOutputScriptTypePubkeyhash,
	BitcoinOutputScriptTypeScripthash,
	BitcoinOutputScriptTypeWitnessV0Keyhash,
	BitcoinOutputScriptTypeNulldata,
	BitcoinOutputScriptTypeWitnessV0Scripthash,
	BitcoinOutputScriptTypeNonstandard,
	BitcoinOutputScriptTypeMultisig,
	BitcoinOutputScriptTypeWitnessUnknown,
}

func (e BitcoinOutputScriptType) IsValid() bool {
	switch e {
	case BitcoinOutputScriptTypePubkey, BitcoinOutputScriptTypePubkeyhash, BitcoinOutputScriptTypeScripthash, BitcoinOutputScriptTypeWitnessV0Keyhash, BitcoinOutputScriptTypeNulldata, BitcoinOutputScriptTypeWitnessV0Scripthash, BitcoinOutputScriptTypeNonstandard, BitcoinOutputScriptTypeMultisig, BitcoinOutputScriptTypeWitnessUnknown:
		return true
	}
	return false
}

func (e BitcoinOutputScriptType) String() string {
	return string(e)
}

func (e *BitcoinOutputScriptType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOutputScriptType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOutputScriptType", str)
	}
	return nil
}

func (e BitcoinOutputScriptType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOutputUniq string

const (
	// Unique transactions count
	BitcoinOutputUniqTransactions BitcoinOutputUniq = "transactions"
	// Unique block count
	BitcoinOutputUniqBlocks BitcoinOutputUniq = "blocks"
	// Unique date count
	BitcoinOutputUniqDates BitcoinOutputUniq = "dates"
	// Unique input addresses count
	BitcoinOutputUniqAddresses BitcoinOutputUniq = "addresses"
)

var AllBitcoinOutputUniq = []BitcoinOutputUniq{
	BitcoinOutputUniqTransactions,
	BitcoinOutputUniqBlocks,
	BitcoinOutputUniqDates,
	BitcoinOutputUniqAddresses,
}

func (e BitcoinOutputUniq) IsValid() bool {
	switch e {
	case BitcoinOutputUniqTransactions, BitcoinOutputUniqBlocks, BitcoinOutputUniqDates, BitcoinOutputUniqAddresses:
		return true
	}
	return false
}

func (e BitcoinOutputUniq) String() string {
	return string(e)
}

func (e *BitcoinOutputUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOutputUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOutputUniq", str)
	}
	return nil
}

func (e BitcoinOutputUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinOutputsMeasureable string

const (
	// Date
	BitcoinOutputsMeasureableDate BitcoinOutputsMeasureable = "date"
	// Time
	BitcoinOutputsMeasureableTime BitcoinOutputsMeasureable = "time"
	// Block
	BitcoinOutputsMeasureableBlock BitcoinOutputsMeasureable = "block"
	// Transaction hash
	BitcoinOutputsMeasureableTxHash BitcoinOutputsMeasureable = "tx_hash"
	// Transaction index
	BitcoinOutputsMeasureableTxIndex BitcoinOutputsMeasureable = "tx_index"
	// Amount
	BitcoinOutputsMeasureableAmount BitcoinOutputsMeasureable = "amount"
	// Address
	BitcoinOutputsMeasureableAddress BitcoinOutputsMeasureable = "address"
	// Output index
	BitcoinOutputsMeasureableOutputIndex BitcoinOutputsMeasureable = "output_index"
)

var AllBitcoinOutputsMeasureable = []BitcoinOutputsMeasureable{
	BitcoinOutputsMeasureableDate,
	BitcoinOutputsMeasureableTime,
	BitcoinOutputsMeasureableBlock,
	BitcoinOutputsMeasureableTxHash,
	BitcoinOutputsMeasureableTxIndex,
	BitcoinOutputsMeasureableAmount,
	BitcoinOutputsMeasureableAddress,
	BitcoinOutputsMeasureableOutputIndex,
}

func (e BitcoinOutputsMeasureable) IsValid() bool {
	switch e {
	case BitcoinOutputsMeasureableDate, BitcoinOutputsMeasureableTime, BitcoinOutputsMeasureableBlock, BitcoinOutputsMeasureableTxHash, BitcoinOutputsMeasureableTxIndex, BitcoinOutputsMeasureableAmount, BitcoinOutputsMeasureableAddress, BitcoinOutputsMeasureableOutputIndex:
		return true
	}
	return false
}

func (e BitcoinOutputsMeasureable) String() string {
	return string(e)
}

func (e *BitcoinOutputsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinOutputsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinOutputsMeasureable", str)
	}
	return nil
}

func (e BitcoinOutputsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinTransactionUniq string

const (
	// Unique block count
	BitcoinTransactionUniqBlocks BitcoinTransactionUniq = "blocks"
	// Unique date count
	BitcoinTransactionUniqDates BitcoinTransactionUniq = "dates"
)

var AllBitcoinTransactionUniq = []BitcoinTransactionUniq{
	BitcoinTransactionUniqBlocks,
	BitcoinTransactionUniqDates,
}

func (e BitcoinTransactionUniq) IsValid() bool {
	switch e {
	case BitcoinTransactionUniqBlocks, BitcoinTransactionUniqDates:
		return true
	}
	return false
}

func (e BitcoinTransactionUniq) String() string {
	return string(e)
}

func (e *BitcoinTransactionUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinTransactionUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinTransactionUniq", str)
	}
	return nil
}

func (e BitcoinTransactionUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BitcoinTransactionsMeasureable string

const (
	// Date
	BitcoinTransactionsMeasureableDate BitcoinTransactionsMeasureable = "date"
	// Time
	BitcoinTransactionsMeasureableTime BitcoinTransactionsMeasureable = "time"
	// Block
	BitcoinTransactionsMeasureableBlock BitcoinTransactionsMeasureable = "block"
	// Transaction hash
	BitcoinTransactionsMeasureableTxHash BitcoinTransactionsMeasureable = "tx_hash"
	// Transaction index
	BitcoinTransactionsMeasureableTxIndex BitcoinTransactionsMeasureable = "tx_index"
	// Input count
	BitcoinTransactionsMeasureableInputCount BitcoinTransactionsMeasureable = "input_count"
	// Output count
	BitcoinTransactionsMeasureableOutputCount BitcoinTransactionsMeasureable = "output_count"
	// Transaction size
	BitcoinTransactionsMeasureableTxSize BitcoinTransactionsMeasureable = "tx_size"
	// Transaction input value
	BitcoinTransactionsMeasureableInputValue BitcoinTransactionsMeasureable = "input_value"
	// Transaction output value
	BitcoinTransactionsMeasureableOutputValue BitcoinTransactionsMeasureable = "output_value"
)

var AllBitcoinTransactionsMeasureable = []BitcoinTransactionsMeasureable{
	BitcoinTransactionsMeasureableDate,
	BitcoinTransactionsMeasureableTime,
	BitcoinTransactionsMeasureableBlock,
	BitcoinTransactionsMeasureableTxHash,
	BitcoinTransactionsMeasureableTxIndex,
	BitcoinTransactionsMeasureableInputCount,
	BitcoinTransactionsMeasureableOutputCount,
	BitcoinTransactionsMeasureableTxSize,
	BitcoinTransactionsMeasureableInputValue,
	BitcoinTransactionsMeasureableOutputValue,
}

func (e BitcoinTransactionsMeasureable) IsValid() bool {
	switch e {
	case BitcoinTransactionsMeasureableDate, BitcoinTransactionsMeasureableTime, BitcoinTransactionsMeasureableBlock, BitcoinTransactionsMeasureableTxHash, BitcoinTransactionsMeasureableTxIndex, BitcoinTransactionsMeasureableInputCount, BitcoinTransactionsMeasureableOutputCount, BitcoinTransactionsMeasureableTxSize, BitcoinTransactionsMeasureableInputValue, BitcoinTransactionsMeasureableOutputValue:
		return true
	}
	return false
}

func (e BitcoinTransactionsMeasureable) String() string {
	return string(e)
}

func (e *BitcoinTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitcoinTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitcoinTransactionsMeasureable", str)
	}
	return nil
}

func (e BitcoinTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoBlockUniq string

const (
	// Unique date count
	CardanoBlockUniqDates CardanoBlockUniq = "dates"
	// Unique epoch
	CardanoBlockUniqEpoch CardanoBlockUniq = "epoch"
	// Unique slot
	CardanoBlockUniqSlot CardanoBlockUniq = "slot"
	// Unique slot leader
	CardanoBlockUniqSlotLeader CardanoBlockUniq = "slot_leader"
	// Unique version
	CardanoBlockUniqVersion CardanoBlockUniq = "version"
)

var AllCardanoBlockUniq = []CardanoBlockUniq{
	CardanoBlockUniqDates,
	CardanoBlockUniqEpoch,
	CardanoBlockUniqSlot,
	CardanoBlockUniqSlotLeader,
	CardanoBlockUniqVersion,
}

func (e CardanoBlockUniq) IsValid() bool {
	switch e {
	case CardanoBlockUniqDates, CardanoBlockUniqEpoch, CardanoBlockUniqSlot, CardanoBlockUniqSlotLeader, CardanoBlockUniqVersion:
		return true
	}
	return false
}

func (e CardanoBlockUniq) String() string {
	return string(e)
}

func (e *CardanoBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoBlockUniq", str)
	}
	return nil
}

func (e CardanoBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoBlocksMeasureable string

const (
	// Date
	CardanoBlocksMeasureableDate CardanoBlocksMeasureable = "date"
	// Time
	CardanoBlocksMeasureableTime CardanoBlocksMeasureable = "time"
	// Block
	CardanoBlocksMeasureableBlock CardanoBlocksMeasureable = "block"
	// Block hash
	CardanoBlocksMeasureableBlockHash CardanoBlocksMeasureable = "block_hash"
	// Tx Count
	CardanoBlocksMeasureableTransactionCount CardanoBlocksMeasureable = "transaction_count"
)

var AllCardanoBlocksMeasureable = []CardanoBlocksMeasureable{
	CardanoBlocksMeasureableDate,
	CardanoBlocksMeasureableTime,
	CardanoBlocksMeasureableBlock,
	CardanoBlocksMeasureableBlockHash,
	CardanoBlocksMeasureableTransactionCount,
}

func (e CardanoBlocksMeasureable) IsValid() bool {
	switch e {
	case CardanoBlocksMeasureableDate, CardanoBlocksMeasureableTime, CardanoBlocksMeasureableBlock, CardanoBlocksMeasureableBlockHash, CardanoBlocksMeasureableTransactionCount:
		return true
	}
	return false
}

func (e CardanoBlocksMeasureable) String() string {
	return string(e)
}

func (e *CardanoBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoBlocksMeasureable", str)
	}
	return nil
}

func (e CardanoBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoCoinpathMethod string

const (
	// Tracking money flow by amounts, ignoring coins (default)
	CardanoCoinpathMethodMoneyflow CardanoCoinpathMethod = "moneyflow"
	// Tracking coins by UTXO transactions
	CardanoCoinpathMethodUtxo CardanoCoinpathMethod = "utxo"
)

var AllCardanoCoinpathMethod = []CardanoCoinpathMethod{
	CardanoCoinpathMethodMoneyflow,
	CardanoCoinpathMethodUtxo,
}

func (e CardanoCoinpathMethod) IsValid() bool {
	switch e {
	case CardanoCoinpathMethodMoneyflow, CardanoCoinpathMethodUtxo:
		return true
	}
	return false
}

func (e CardanoCoinpathMethod) String() string {
	return string(e)
}

func (e *CardanoCoinpathMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoCoinpathMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoCoinpathMethod", str)
	}
	return nil
}

func (e CardanoCoinpathMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoInputSource string

const (
	// Input
	CardanoInputSourceInput CardanoInputSource = "input"
	// Withdrawal
	CardanoInputSourceWithdrawal CardanoInputSource = "withdrawal"
)

var AllCardanoInputSource = []CardanoInputSource{
	CardanoInputSourceInput,
	CardanoInputSourceWithdrawal,
}

func (e CardanoInputSource) IsValid() bool {
	switch e {
	case CardanoInputSourceInput, CardanoInputSourceWithdrawal:
		return true
	}
	return false
}

func (e CardanoInputSource) String() string {
	return string(e)
}

func (e *CardanoInputSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoInputSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoInputSource", str)
	}
	return nil
}

func (e CardanoInputSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoInputUniq string

const (
	// Unique transactions count
	CardanoInputUniqTransactions CardanoInputUniq = "transactions"
	// Unique block count
	CardanoInputUniqBlocks CardanoInputUniq = "blocks"
	// Unique date count
	CardanoInputUniqDates CardanoInputUniq = "dates"
	// Unique addresses count
	CardanoInputUniqAddresses CardanoInputUniq = "addresses"
	// Unique currencies count
	CardanoInputUniqCurrencies CardanoInputUniq = "currencies"
)

var AllCardanoInputUniq = []CardanoInputUniq{
	CardanoInputUniqTransactions,
	CardanoInputUniqBlocks,
	CardanoInputUniqDates,
	CardanoInputUniqAddresses,
	CardanoInputUniqCurrencies,
}

func (e CardanoInputUniq) IsValid() bool {
	switch e {
	case CardanoInputUniqTransactions, CardanoInputUniqBlocks, CardanoInputUniqDates, CardanoInputUniqAddresses, CardanoInputUniqCurrencies:
		return true
	}
	return false
}

func (e CardanoInputUniq) String() string {
	return string(e)
}

func (e *CardanoInputUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoInputUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoInputUniq", str)
	}
	return nil
}

func (e CardanoInputUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoInputsMeasureable string

const (
	// Date
	CardanoInputsMeasureableDate CardanoInputsMeasureable = "date"
	// Time
	CardanoInputsMeasureableTime CardanoInputsMeasureable = "time"
	// Block
	CardanoInputsMeasureableBlock CardanoInputsMeasureable = "block"
	// Transaction hash
	CardanoInputsMeasureableTxHash CardanoInputsMeasureable = "tx_hash"
	// Transaction index
	CardanoInputsMeasureableTxIndex CardanoInputsMeasureable = "tx_index"
	// Amount
	CardanoInputsMeasureableAmount CardanoInputsMeasureable = "amount"
	// Address
	CardanoInputsMeasureableAddress CardanoInputsMeasureable = "address"
	// Input index
	CardanoInputsMeasureableInputIndex CardanoInputsMeasureable = "input_index"
)

var AllCardanoInputsMeasureable = []CardanoInputsMeasureable{
	CardanoInputsMeasureableDate,
	CardanoInputsMeasureableTime,
	CardanoInputsMeasureableBlock,
	CardanoInputsMeasureableTxHash,
	CardanoInputsMeasureableTxIndex,
	CardanoInputsMeasureableAmount,
	CardanoInputsMeasureableAddress,
	CardanoInputsMeasureableInputIndex,
}

func (e CardanoInputsMeasureable) IsValid() bool {
	switch e {
	case CardanoInputsMeasureableDate, CardanoInputsMeasureableTime, CardanoInputsMeasureableBlock, CardanoInputsMeasureableTxHash, CardanoInputsMeasureableTxIndex, CardanoInputsMeasureableAmount, CardanoInputsMeasureableAddress, CardanoInputsMeasureableInputIndex:
		return true
	}
	return false
}

func (e CardanoInputsMeasureable) String() string {
	return string(e)
}

func (e *CardanoInputsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoInputsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoInputsMeasureable", str)
	}
	return nil
}

func (e CardanoInputsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoMintUniq string

const (
	// Unique transactions count
	CardanoMintUniqTransactions CardanoMintUniq = "transactions"
	// Unique block count
	CardanoMintUniqBlocks CardanoMintUniq = "blocks"
	// Unique date count
	CardanoMintUniqDates CardanoMintUniq = "dates"
	// Unique currencies count
	CardanoMintUniqCurrencies CardanoMintUniq = "currencies"
)

var AllCardanoMintUniq = []CardanoMintUniq{
	CardanoMintUniqTransactions,
	CardanoMintUniqBlocks,
	CardanoMintUniqDates,
	CardanoMintUniqCurrencies,
}

func (e CardanoMintUniq) IsValid() bool {
	switch e {
	case CardanoMintUniqTransactions, CardanoMintUniqBlocks, CardanoMintUniqDates, CardanoMintUniqCurrencies:
		return true
	}
	return false
}

func (e CardanoMintUniq) String() string {
	return string(e)
}

func (e *CardanoMintUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoMintUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoMintUniq", str)
	}
	return nil
}

func (e CardanoMintUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoMintsMeasureable string

const (
	// Date
	CardanoMintsMeasureableDate CardanoMintsMeasureable = "date"
	// Time
	CardanoMintsMeasureableTime CardanoMintsMeasureable = "time"
	// Block
	CardanoMintsMeasureableBlock CardanoMintsMeasureable = "block"
	// Transaction hash
	CardanoMintsMeasureableTxHash CardanoMintsMeasureable = "tx_hash"
	// Transaction index
	CardanoMintsMeasureableTxIndex CardanoMintsMeasureable = "tx_index"
	// Amount
	CardanoMintsMeasureableAmount CardanoMintsMeasureable = "amount"
)

var AllCardanoMintsMeasureable = []CardanoMintsMeasureable{
	CardanoMintsMeasureableDate,
	CardanoMintsMeasureableTime,
	CardanoMintsMeasureableBlock,
	CardanoMintsMeasureableTxHash,
	CardanoMintsMeasureableTxIndex,
	CardanoMintsMeasureableAmount,
}

func (e CardanoMintsMeasureable) IsValid() bool {
	switch e {
	case CardanoMintsMeasureableDate, CardanoMintsMeasureableTime, CardanoMintsMeasureableBlock, CardanoMintsMeasureableTxHash, CardanoMintsMeasureableTxIndex, CardanoMintsMeasureableAmount:
		return true
	}
	return false
}

func (e CardanoMintsMeasureable) String() string {
	return string(e)
}

func (e *CardanoMintsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoMintsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoMintsMeasureable", str)
	}
	return nil
}

func (e CardanoMintsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoNetwork string

const (
	// Cardano ( ADA )
	CardanoNetworkCardano CardanoNetwork = "cardano"
)

var AllCardanoNetwork = []CardanoNetwork{
	CardanoNetworkCardano,
}

func (e CardanoNetwork) IsValid() bool {
	switch e {
	case CardanoNetworkCardano:
		return true
	}
	return false
}

func (e CardanoNetwork) String() string {
	return string(e)
}

func (e *CardanoNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoNetwork", str)
	}
	return nil
}

func (e CardanoNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoOutputDirection string

const (
	// Not defined
	CardanoOutputDirectionUnknown CardanoOutputDirection = "unknown"
	// Not a change return
	CardanoOutputDirectionNotChange CardanoOutputDirection = "not_change"
	// Change return
	CardanoOutputDirectionChange CardanoOutputDirection = "change"
	// Likely Not a change return
	CardanoOutputDirectionLikelyNotChange CardanoOutputDirection = "likely_not_change"
	// Likely Change return
	CardanoOutputDirectionLikelyChange CardanoOutputDirection = "likely_change"
	// Mining
	CardanoOutputDirectionMining CardanoOutputDirection = "mining"
	// Fee
	CardanoOutputDirectionFee CardanoOutputDirection = "fee"
	// Minting
	CardanoOutputDirectionMinting CardanoOutputDirection = "minting"
	// Genesis
	CardanoOutputDirectionGenesis CardanoOutputDirection = "genesis"
)

var AllCardanoOutputDirection = []CardanoOutputDirection{
	CardanoOutputDirectionUnknown,
	CardanoOutputDirectionNotChange,
	CardanoOutputDirectionChange,
	CardanoOutputDirectionLikelyNotChange,
	CardanoOutputDirectionLikelyChange,
	CardanoOutputDirectionMining,
	CardanoOutputDirectionFee,
	CardanoOutputDirectionMinting,
	CardanoOutputDirectionGenesis,
}

func (e CardanoOutputDirection) IsValid() bool {
	switch e {
	case CardanoOutputDirectionUnknown, CardanoOutputDirectionNotChange, CardanoOutputDirectionChange, CardanoOutputDirectionLikelyNotChange, CardanoOutputDirectionLikelyChange, CardanoOutputDirectionMining, CardanoOutputDirectionFee, CardanoOutputDirectionMinting, CardanoOutputDirectionGenesis:
		return true
	}
	return false
}

func (e CardanoOutputDirection) String() string {
	return string(e)
}

func (e *CardanoOutputDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoOutputDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoOutputDirection", str)
	}
	return nil
}

func (e CardanoOutputDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoOutputUniq string

const (
	// Unique transactions count
	CardanoOutputUniqTransactions CardanoOutputUniq = "transactions"
	// Unique block count
	CardanoOutputUniqBlocks CardanoOutputUniq = "blocks"
	// Unique date count
	CardanoOutputUniqDates CardanoOutputUniq = "dates"
	// Unique input addresses count
	CardanoOutputUniqAddresses CardanoOutputUniq = "addresses"
	// Unique currencies count
	CardanoOutputUniqCurrencies CardanoOutputUniq = "currencies"
)

var AllCardanoOutputUniq = []CardanoOutputUniq{
	CardanoOutputUniqTransactions,
	CardanoOutputUniqBlocks,
	CardanoOutputUniqDates,
	CardanoOutputUniqAddresses,
	CardanoOutputUniqCurrencies,
}

func (e CardanoOutputUniq) IsValid() bool {
	switch e {
	case CardanoOutputUniqTransactions, CardanoOutputUniqBlocks, CardanoOutputUniqDates, CardanoOutputUniqAddresses, CardanoOutputUniqCurrencies:
		return true
	}
	return false
}

func (e CardanoOutputUniq) String() string {
	return string(e)
}

func (e *CardanoOutputUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoOutputUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoOutputUniq", str)
	}
	return nil
}

func (e CardanoOutputUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoOutputsMeasureable string

const (
	// Date
	CardanoOutputsMeasureableDate CardanoOutputsMeasureable = "date"
	// Time
	CardanoOutputsMeasureableTime CardanoOutputsMeasureable = "time"
	// Block
	CardanoOutputsMeasureableBlock CardanoOutputsMeasureable = "block"
	// Transaction hash
	CardanoOutputsMeasureableTxHash CardanoOutputsMeasureable = "tx_hash"
	// Transaction index
	CardanoOutputsMeasureableTxIndex CardanoOutputsMeasureable = "tx_index"
	// Amount
	CardanoOutputsMeasureableAmount CardanoOutputsMeasureable = "amount"
	// Address
	CardanoOutputsMeasureableAddress CardanoOutputsMeasureable = "address"
	// Output index
	CardanoOutputsMeasureableOutputIndex CardanoOutputsMeasureable = "output_index"
)

var AllCardanoOutputsMeasureable = []CardanoOutputsMeasureable{
	CardanoOutputsMeasureableDate,
	CardanoOutputsMeasureableTime,
	CardanoOutputsMeasureableBlock,
	CardanoOutputsMeasureableTxHash,
	CardanoOutputsMeasureableTxIndex,
	CardanoOutputsMeasureableAmount,
	CardanoOutputsMeasureableAddress,
	CardanoOutputsMeasureableOutputIndex,
}

func (e CardanoOutputsMeasureable) IsValid() bool {
	switch e {
	case CardanoOutputsMeasureableDate, CardanoOutputsMeasureableTime, CardanoOutputsMeasureableBlock, CardanoOutputsMeasureableTxHash, CardanoOutputsMeasureableTxIndex, CardanoOutputsMeasureableAmount, CardanoOutputsMeasureableAddress, CardanoOutputsMeasureableOutputIndex:
		return true
	}
	return false
}

func (e CardanoOutputsMeasureable) String() string {
	return string(e)
}

func (e *CardanoOutputsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoOutputsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoOutputsMeasureable", str)
	}
	return nil
}

func (e CardanoOutputsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoTransactionUniq string

const (
	// Unique block count
	CardanoTransactionUniqBlocks CardanoTransactionUniq = "blocks"
	// Unique date count
	CardanoTransactionUniqDates CardanoTransactionUniq = "dates"
)

var AllCardanoTransactionUniq = []CardanoTransactionUniq{
	CardanoTransactionUniqBlocks,
	CardanoTransactionUniqDates,
}

func (e CardanoTransactionUniq) IsValid() bool {
	switch e {
	case CardanoTransactionUniqBlocks, CardanoTransactionUniqDates:
		return true
	}
	return false
}

func (e CardanoTransactionUniq) String() string {
	return string(e)
}

func (e *CardanoTransactionUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoTransactionUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoTransactionUniq", str)
	}
	return nil
}

func (e CardanoTransactionUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardanoTransactionsMeasureable string

const (
	// Date
	CardanoTransactionsMeasureableDate CardanoTransactionsMeasureable = "date"
	// Time
	CardanoTransactionsMeasureableTime CardanoTransactionsMeasureable = "time"
	// Block
	CardanoTransactionsMeasureableBlock CardanoTransactionsMeasureable = "block"
	// Transaction hash
	CardanoTransactionsMeasureableTxHash CardanoTransactionsMeasureable = "tx_hash"
	// Transaction index
	CardanoTransactionsMeasureableTxIndex CardanoTransactionsMeasureable = "tx_index"
	// Input count
	CardanoTransactionsMeasureableInputCount CardanoTransactionsMeasureable = "input_count"
	// Output count
	CardanoTransactionsMeasureableOutputCount CardanoTransactionsMeasureable = "output_count"
	// Transaction size
	CardanoTransactionsMeasureableTxSize CardanoTransactionsMeasureable = "tx_size"
	// Transaction input value
	CardanoTransactionsMeasureableInputValue CardanoTransactionsMeasureable = "input_value"
	// Transaction output value
	CardanoTransactionsMeasureableOutputValue CardanoTransactionsMeasureable = "output_value"
	// Transaction withdrawal value
	CardanoTransactionsMeasureableWithdrawalValue CardanoTransactionsMeasureable = "withdrawal_value"
	// Transaction deposit value
	CardanoTransactionsMeasureableDepositValue CardanoTransactionsMeasureable = "deposit_value"
	// Transaction withdrawal count
	CardanoTransactionsMeasureableWithdrawalCount CardanoTransactionsMeasureable = "withdrawal_count"
	// Transaction mint count
	CardanoTransactionsMeasureableMintCount CardanoTransactionsMeasureable = "mint_count"
)

var AllCardanoTransactionsMeasureable = []CardanoTransactionsMeasureable{
	CardanoTransactionsMeasureableDate,
	CardanoTransactionsMeasureableTime,
	CardanoTransactionsMeasureableBlock,
	CardanoTransactionsMeasureableTxHash,
	CardanoTransactionsMeasureableTxIndex,
	CardanoTransactionsMeasureableInputCount,
	CardanoTransactionsMeasureableOutputCount,
	CardanoTransactionsMeasureableTxSize,
	CardanoTransactionsMeasureableInputValue,
	CardanoTransactionsMeasureableOutputValue,
	CardanoTransactionsMeasureableWithdrawalValue,
	CardanoTransactionsMeasureableDepositValue,
	CardanoTransactionsMeasureableWithdrawalCount,
	CardanoTransactionsMeasureableMintCount,
}

func (e CardanoTransactionsMeasureable) IsValid() bool {
	switch e {
	case CardanoTransactionsMeasureableDate, CardanoTransactionsMeasureableTime, CardanoTransactionsMeasureableBlock, CardanoTransactionsMeasureableTxHash, CardanoTransactionsMeasureableTxIndex, CardanoTransactionsMeasureableInputCount, CardanoTransactionsMeasureableOutputCount, CardanoTransactionsMeasureableTxSize, CardanoTransactionsMeasureableInputValue, CardanoTransactionsMeasureableOutputValue, CardanoTransactionsMeasureableWithdrawalValue, CardanoTransactionsMeasureableDepositValue, CardanoTransactionsMeasureableWithdrawalCount, CardanoTransactionsMeasureableMintCount:
		return true
	}
	return false
}

func (e CardanoTransactionsMeasureable) String() string {
	return string(e)
}

func (e *CardanoTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardanoTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardanoTransactionsMeasureable", str)
	}
	return nil
}

func (e CardanoTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CoinpathMeasureable string

const (
	// Time
	CoinpathMeasureableTime CoinpathMeasureable = "time"
	// Block
	CoinpathMeasureableBlock CoinpathMeasureable = "block"
	// Transaction hash
	CoinpathMeasureableTxHash CoinpathMeasureable = "tx_hash"
	// Sender
	CoinpathMeasureableSender CoinpathMeasureable = "sender"
	// Receiver
	CoinpathMeasureableReceiver CoinpathMeasureable = "receiver"
	// Depth
	CoinpathMeasureableDepth CoinpathMeasureable = "depth"
)

var AllCoinpathMeasureable = []CoinpathMeasureable{
	CoinpathMeasureableTime,
	CoinpathMeasureableBlock,
	CoinpathMeasureableTxHash,
	CoinpathMeasureableSender,
	CoinpathMeasureableReceiver,
	CoinpathMeasureableDepth,
}

func (e CoinpathMeasureable) IsValid() bool {
	switch e {
	case CoinpathMeasureableTime, CoinpathMeasureableBlock, CoinpathMeasureableTxHash, CoinpathMeasureableSender, CoinpathMeasureableReceiver, CoinpathMeasureableDepth:
		return true
	}
	return false
}

func (e CoinpathMeasureable) String() string {
	return string(e)
}

func (e *CoinpathMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CoinpathMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CoinpathMeasureable", str)
	}
	return nil
}

func (e CoinpathMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConfluxBlocksMeasureable string

const (
	// Date
	ConfluxBlocksMeasureableDate ConfluxBlocksMeasureable = "date"
	// Time
	ConfluxBlocksMeasureableTime ConfluxBlocksMeasureable = "time"
	// Block
	ConfluxBlocksMeasureableBlock ConfluxBlocksMeasureable = "block"
	// Block hash
	ConfluxBlocksMeasureableBlockHash ConfluxBlocksMeasureable = "block_hash"
	// Block Miner
	ConfluxBlocksMeasureableMiner ConfluxBlocksMeasureable = "miner"
	// Block Referee Count
	ConfluxBlocksMeasureableRefereeCount ConfluxBlocksMeasureable = "referee_count"
	// Block TX Count
	ConfluxBlocksMeasureableTransactionCount ConfluxBlocksMeasureable = "transaction_count"
)

var AllConfluxBlocksMeasureable = []ConfluxBlocksMeasureable{
	ConfluxBlocksMeasureableDate,
	ConfluxBlocksMeasureableTime,
	ConfluxBlocksMeasureableBlock,
	ConfluxBlocksMeasureableBlockHash,
	ConfluxBlocksMeasureableMiner,
	ConfluxBlocksMeasureableRefereeCount,
	ConfluxBlocksMeasureableTransactionCount,
}

func (e ConfluxBlocksMeasureable) IsValid() bool {
	switch e {
	case ConfluxBlocksMeasureableDate, ConfluxBlocksMeasureableTime, ConfluxBlocksMeasureableBlock, ConfluxBlocksMeasureableBlockHash, ConfluxBlocksMeasureableMiner, ConfluxBlocksMeasureableRefereeCount, ConfluxBlocksMeasureableTransactionCount:
		return true
	}
	return false
}

func (e ConfluxBlocksMeasureable) String() string {
	return string(e)
}

func (e *ConfluxBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfluxBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfluxBlocksMeasureable", str)
	}
	return nil
}

func (e ConfluxBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConfluxNetwork string

const (
	// Conflux Oceanus
	ConfluxNetworkConfluxOceanus ConfluxNetwork = "conflux_oceanus"
	// Conflux Tethys
	ConfluxNetworkConfluxTethys ConfluxNetwork = "conflux_tethys"
)

var AllConfluxNetwork = []ConfluxNetwork{
	ConfluxNetworkConfluxOceanus,
	ConfluxNetworkConfluxTethys,
}

func (e ConfluxNetwork) IsValid() bool {
	switch e {
	case ConfluxNetworkConfluxOceanus, ConfluxNetworkConfluxTethys:
		return true
	}
	return false
}

func (e ConfluxNetwork) String() string {
	return string(e)
}

func (e *ConfluxNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfluxNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfluxNetwork", str)
	}
	return nil
}

func (e ConfluxNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConfluxTransactionsMeasureable string

const (
	// Date
	ConfluxTransactionsMeasureableDate ConfluxTransactionsMeasureable = "date"
	// Time
	ConfluxTransactionsMeasureableTime ConfluxTransactionsMeasureable = "time"
	// Block
	ConfluxTransactionsMeasureableBlock ConfluxTransactionsMeasureable = "block"
	// Transaction hash
	ConfluxTransactionsMeasureableTxHash ConfluxTransactionsMeasureable = "tx_hash"
	// Amount
	ConfluxTransactionsMeasureableAmount ConfluxTransactionsMeasureable = "amount"
	// Transaction Sender
	ConfluxTransactionsMeasureableTxSender ConfluxTransactionsMeasureable = "tx_sender"
	// Gas value
	ConfluxTransactionsMeasureableGasValue ConfluxTransactionsMeasureable = "gas_value"
	// Gas price
	ConfluxTransactionsMeasureableGasPrice ConfluxTransactionsMeasureable = "gas_price"
	// Gas used
	ConfluxTransactionsMeasureableGas ConfluxTransactionsMeasureable = "gas"
)

var AllConfluxTransactionsMeasureable = []ConfluxTransactionsMeasureable{
	ConfluxTransactionsMeasureableDate,
	ConfluxTransactionsMeasureableTime,
	ConfluxTransactionsMeasureableBlock,
	ConfluxTransactionsMeasureableTxHash,
	ConfluxTransactionsMeasureableAmount,
	ConfluxTransactionsMeasureableTxSender,
	ConfluxTransactionsMeasureableGasValue,
	ConfluxTransactionsMeasureableGasPrice,
	ConfluxTransactionsMeasureableGas,
}

func (e ConfluxTransactionsMeasureable) IsValid() bool {
	switch e {
	case ConfluxTransactionsMeasureableDate, ConfluxTransactionsMeasureableTime, ConfluxTransactionsMeasureableBlock, ConfluxTransactionsMeasureableTxHash, ConfluxTransactionsMeasureableAmount, ConfluxTransactionsMeasureableTxSender, ConfluxTransactionsMeasureableGasValue, ConfluxTransactionsMeasureableGasPrice, ConfluxTransactionsMeasureableGas:
		return true
	}
	return false
}

func (e ConfluxTransactionsMeasureable) String() string {
	return string(e)
}

func (e *ConfluxTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfluxTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfluxTransactionsMeasureable", str)
	}
	return nil
}

func (e ConfluxTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Continent string

const (
	// Africa
	ContinentAfrica Continent = "Africa"
	// Asia
	ContinentAsia Continent = "Asia"
	// Europe
	ContinentEurope Continent = "Europe"
	// North America
	ContinentNorthAmerica Continent = "North_America"
	// Oceania
	ContinentOceania Continent = "Oceania"
	// South America
	ContinentSouthAmerica Continent = "South_America"
	// Antarctica
	ContinentAntarctica Continent = "Antarctica"
)

var AllContinent = []Continent{
	ContinentAfrica,
	ContinentAsia,
	ContinentEurope,
	ContinentNorthAmerica,
	ContinentOceania,
	ContinentSouthAmerica,
	ContinentAntarctica,
}

func (e Continent) IsValid() bool {
	switch e {
	case ContinentAfrica, ContinentAsia, ContinentEurope, ContinentNorthAmerica, ContinentOceania, ContinentSouthAmerica, ContinentAntarctica:
		return true
	}
	return false
}

func (e Continent) String() string {
	return string(e)
}

func (e *Continent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Continent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Continent", str)
	}
	return nil
}

func (e Continent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CountryCode string

const (
	// Afghanistan
	CountryCodeAf CountryCode = "AF"
	// Albania
	CountryCodeAl CountryCode = "AL"
	// Algeria
	CountryCodeDz CountryCode = "DZ"
	// American Samoa
	CountryCodeAs CountryCode = "AS"
	// Andorra
	CountryCodeAd CountryCode = "AD"
	// Angola
	CountryCodeAo CountryCode = "AO"
	// Anguilla
	CountryCodeAi CountryCode = "AI"
	// Antarctica
	CountryCodeAq CountryCode = "AQ"
	// Antigua and Barbuda
	CountryCodeAg CountryCode = "AG"
	// Argentina
	CountryCodeAr CountryCode = "AR"
	// Armenia
	CountryCodeAm CountryCode = "AM"
	// Aruba
	CountryCodeAw CountryCode = "AW"
	// Australia
	CountryCodeAu CountryCode = "AU"
	// Austria
	CountryCodeAt CountryCode = "AT"
	// Azerbaijan
	CountryCodeAz CountryCode = "AZ"
	// Bahamas
	CountryCodeBs CountryCode = "BS"
	// Bahrain
	CountryCodeBh CountryCode = "BH"
	// Bangladesh
	CountryCodeBd CountryCode = "BD"
	// Barbados
	CountryCodeBb CountryCode = "BB"
	// Belarus
	CountryCodeBy CountryCode = "BY"
	// Belgium
	CountryCodeBe CountryCode = "BE"
	// Belize
	CountryCodeBz CountryCode = "BZ"
	// Benin
	CountryCodeBj CountryCode = "BJ"
	// Bermuda
	CountryCodeBm CountryCode = "BM"
	// Bhutan
	CountryCodeBt CountryCode = "BT"
	// Bolivia
	CountryCodeBo CountryCode = "BO"
	// Bosnia and Herzegovina
	CountryCodeBa CountryCode = "BA"
	// Botswana
	CountryCodeBw CountryCode = "BW"
	// Brazil
	CountryCodeBr CountryCode = "BR"
	// British Indian Ocean Territory
	CountryCodeIo CountryCode = "IO"
	// British Virgin Islands
	CountryCodeVg CountryCode = "VG"
	// Brunei
	CountryCodeBn CountryCode = "BN"
	// Bulgaria
	CountryCodeBg CountryCode = "BG"
	// Burkina Faso
	CountryCodeBf CountryCode = "BF"
	// Burundi
	CountryCodeBi CountryCode = "BI"
	// Cambodia
	CountryCodeKh CountryCode = "KH"
	// Cameroon
	CountryCodeCm CountryCode = "CM"
	// Canada
	CountryCodeCa CountryCode = "CA"
	// Cape Verde
	CountryCodeCv CountryCode = "CV"
	// Cayman Islands
	CountryCodeKy CountryCode = "KY"
	// Central African Republic
	CountryCodeCf CountryCode = "CF"
	// Chad
	CountryCodeTd CountryCode = "TD"
	// Chile
	CountryCodeCl CountryCode = "CL"
	// China
	CountryCodeCn CountryCode = "CN"
	// Christmas Island
	CountryCodeCx CountryCode = "CX"
	// Cocos Islands
	CountryCodeCc CountryCode = "CC"
	// Colombia
	CountryCodeCo CountryCode = "CO"
	// Comoros
	CountryCodeKm CountryCode = "KM"
	// Cook Islands
	CountryCodeCk CountryCode = "CK"
	// Costa Rica
	CountryCodeCr CountryCode = "CR"
	// Croatia
	CountryCodeHr CountryCode = "HR"
	// Cuba
	CountryCodeCu CountryCode = "CU"
	// Curacao
	CountryCodeCw CountryCode = "CW"
	// Cyprus
	CountryCodeCy CountryCode = "CY"
	// Czech Republic
	CountryCodeCz CountryCode = "CZ"
	// Democratic Republic of the Congo
	CountryCodeCd CountryCode = "CD"
	// Denmark
	CountryCodeDk CountryCode = "DK"
	// Djibouti
	CountryCodeDj CountryCode = "DJ"
	// Dominica
	CountryCodeDm CountryCode = "DM"
	// Dominican Republic
	CountryCodeDo CountryCode = "DO"
	// East Timor
	CountryCodeTl CountryCode = "TL"
	// Ecuador
	CountryCodeEc CountryCode = "EC"
	// Egypt
	CountryCodeEg CountryCode = "EG"
	// El Salvador
	CountryCodeSv CountryCode = "SV"
	// Equatorial Guinea
	CountryCodeGq CountryCode = "GQ"
	// Eritrea
	CountryCodeEr CountryCode = "ER"
	// Estonia
	CountryCodeEe CountryCode = "EE"
	// Ethiopia
	CountryCodeEt CountryCode = "ET"
	// Falkland Islands
	CountryCodeFk CountryCode = "FK"
	// Faroe Islands
	CountryCodeFo CountryCode = "FO"
	// Fiji
	CountryCodeFj CountryCode = "FJ"
	// Finland
	CountryCodeFi CountryCode = "FI"
	// France
	CountryCodeFr CountryCode = "FR"
	// French Polynesia
	CountryCodePf CountryCode = "PF"
	// Gabon
	CountryCodeGa CountryCode = "GA"
	// Gambia
	CountryCodeGm CountryCode = "GM"
	// Georgia
	CountryCodeGe CountryCode = "GE"
	// Germany
	CountryCodeDe CountryCode = "DE"
	// Ghana
	CountryCodeGh CountryCode = "GH"
	// Gibraltar
	CountryCodeGi CountryCode = "GI"
	// Greece
	CountryCodeGr CountryCode = "GR"
	// Greenland
	CountryCodeGl CountryCode = "GL"
	// Grenada
	CountryCodeGd CountryCode = "GD"
	// Guam
	CountryCodeGu CountryCode = "GU"
	// Guatemala
	CountryCodeGt CountryCode = "GT"
	// Guernsey
	CountryCodeGg CountryCode = "GG"
	// Guinea
	CountryCodeGn CountryCode = "GN"
	// Guinea-Bissau
	CountryCodeGw CountryCode = "GW"
	// Guyana
	CountryCodeGy CountryCode = "GY"
	// Haiti
	CountryCodeHt CountryCode = "HT"
	// Honduras
	CountryCodeHn CountryCode = "HN"
	// Hong Kong
	CountryCodeHk CountryCode = "HK"
	// Hungary
	CountryCodeHu CountryCode = "HU"
	// Iceland
	CountryCodeIs CountryCode = "IS"
	// India
	CountryCodeIn CountryCode = "IN"
	// Indonesia
	CountryCodeID CountryCode = "ID"
	// Iran
	CountryCodeIr CountryCode = "IR"
	// Iraq
	CountryCodeIq CountryCode = "IQ"
	// Ireland
	CountryCodeIe CountryCode = "IE"
	// Isle of Man
	CountryCodeIm CountryCode = "IM"
	// Israel
	CountryCodeIl CountryCode = "IL"
	// Italy
	CountryCodeIt CountryCode = "IT"
	// Ivory Coast
	CountryCodeCi CountryCode = "CI"
	// Jamaica
	CountryCodeJm CountryCode = "JM"
	// Japan
	CountryCodeJp CountryCode = "JP"
	// Jersey
	CountryCodeJe CountryCode = "JE"
	// Jordan
	CountryCodeJo CountryCode = "JO"
	// Kazakhstan
	CountryCodeKz CountryCode = "KZ"
	// Kenya
	CountryCodeKe CountryCode = "KE"
	// Kiribati
	CountryCodeKi CountryCode = "KI"
	// Kosovo
	CountryCodeXk CountryCode = "XK"
	// Kuwait
	CountryCodeKw CountryCode = "KW"
	// Kyrgyzstan
	CountryCodeKg CountryCode = "KG"
	// Laos
	CountryCodeLa CountryCode = "LA"
	// Latvia
	CountryCodeLv CountryCode = "LV"
	// Lebanon
	CountryCodeLb CountryCode = "LB"
	// Lesotho
	CountryCodeLs CountryCode = "LS"
	// Liberia
	CountryCodeLr CountryCode = "LR"
	// Libya
	CountryCodeLy CountryCode = "LY"
	// Liechtenstein
	CountryCodeLi CountryCode = "LI"
	// Lithuania
	CountryCodeLt CountryCode = "LT"
	// Luxembourg
	CountryCodeLu CountryCode = "LU"
	// Macau
	CountryCodeMo CountryCode = "MO"
	// Macedonia
	CountryCodeMk CountryCode = "MK"
	// Madagascar
	CountryCodeMg CountryCode = "MG"
	// Malawi
	CountryCodeMw CountryCode = "MW"
	// Malaysia
	CountryCodeMy CountryCode = "MY"
	// Maldives
	CountryCodeMv CountryCode = "MV"
	// Mali
	CountryCodeMl CountryCode = "ML"
	// Malta
	CountryCodeMt CountryCode = "MT"
	// Marshall Islands
	CountryCodeMh CountryCode = "MH"
	// Mauritania
	CountryCodeMr CountryCode = "MR"
	// Mauritius
	CountryCodeMu CountryCode = "MU"
	// Mayotte
	CountryCodeYt CountryCode = "YT"
	// Mexico
	CountryCodeMx CountryCode = "MX"
	// Micronesia
	CountryCodeFm CountryCode = "FM"
	// Moldova
	CountryCodeMd CountryCode = "MD"
	// Monaco
	CountryCodeMc CountryCode = "MC"
	// Mongolia
	CountryCodeMn CountryCode = "MN"
	// Montenegro
	CountryCodeMe CountryCode = "ME"
	// Montserrat
	CountryCodeMs CountryCode = "MS"
	// Morocco
	CountryCodeMa CountryCode = "MA"
	// Mozambique
	CountryCodeMz CountryCode = "MZ"
	// Myanmar
	CountryCodeMm CountryCode = "MM"
	// Namibia
	CountryCodeNa CountryCode = "NA"
	// Nauru
	CountryCodeNr CountryCode = "NR"
	// Nepal
	CountryCodeNp CountryCode = "NP"
	// Netherlands
	CountryCodeNl CountryCode = "NL"
	// Netherlands Antilles
	CountryCodeAn CountryCode = "AN"
	// New Caledonia
	CountryCodeNc CountryCode = "NC"
	// New Zealand
	CountryCodeNz CountryCode = "NZ"
	// Nicaragua
	CountryCodeNi CountryCode = "NI"
	// Niger
	CountryCodeNe CountryCode = "NE"
	// Nigeria
	CountryCodeNg CountryCode = "NG"
	// Niue
	CountryCodeNu CountryCode = "NU"
	// North Korea
	CountryCodeKp CountryCode = "KP"
	// Northern Mariana Islands
	CountryCodeMp CountryCode = "MP"
	// Norway
	CountryCodeNo CountryCode = "NO"
	// Oman
	CountryCodeOm CountryCode = "OM"
	// Pakistan
	CountryCodePk CountryCode = "PK"
	// Palau
	CountryCodePw CountryCode = "PW"
	// Palestine
	CountryCodePs CountryCode = "PS"
	// Panama
	CountryCodePa CountryCode = "PA"
	// Papua New Guinea
	CountryCodePg CountryCode = "PG"
	// Paraguay
	CountryCodePy CountryCode = "PY"
	// Peru
	CountryCodePe CountryCode = "PE"
	// Philippines
	CountryCodePh CountryCode = "PH"
	// Pitcairn
	CountryCodePn CountryCode = "PN"
	// Poland
	CountryCodePl CountryCode = "PL"
	// Portugal
	CountryCodePt CountryCode = "PT"
	// Puerto Rico
	CountryCodePr CountryCode = "PR"
	// Qatar
	CountryCodeQa CountryCode = "QA"
	// Republic of the Congo
	CountryCodeCg CountryCode = "CG"
	// Reunion
	CountryCodeRe CountryCode = "RE"
	// Romania
	CountryCodeRo CountryCode = "RO"
	// Russia
	CountryCodeRu CountryCode = "RU"
	// Rwanda
	CountryCodeRw CountryCode = "RW"
	// Saint Barthelemy
	CountryCodeBl CountryCode = "BL"
	// Saint Helena
	CountryCodeSh CountryCode = "SH"
	// Saint Kitts and Nevis
	CountryCodeKn CountryCode = "KN"
	// Saint Lucia
	CountryCodeLc CountryCode = "LC"
	// Saint Martin
	CountryCodeMf CountryCode = "MF"
	// Saint Pierre and Miquelon
	CountryCodePm CountryCode = "PM"
	// Saint Vincent and the Grenadines
	CountryCodeVc CountryCode = "VC"
	// Samoa
	CountryCodeWs CountryCode = "WS"
	// San Marino
	CountryCodeSm CountryCode = "SM"
	// Sao Tome and Principe
	CountryCodeSt CountryCode = "ST"
	// Saudi Arabia
	CountryCodeSa CountryCode = "SA"
	// Senegal
	CountryCodeSn CountryCode = "SN"
	// Serbia
	CountryCodeRs CountryCode = "RS"
	// Seychelles
	CountryCodeSc CountryCode = "SC"
	// Sierra Leone
	CountryCodeSl CountryCode = "SL"
	// Singapore
	CountryCodeSg CountryCode = "SG"
	// Sint Maarten
	CountryCodeSx CountryCode = "SX"
	// Slovakia
	CountryCodeSk CountryCode = "SK"
	// Slovenia
	CountryCodeSi CountryCode = "SI"
	// Solomon Islands
	CountryCodeSb CountryCode = "SB"
	// Somalia
	CountryCodeSo CountryCode = "SO"
	// South Africa
	CountryCodeZa CountryCode = "ZA"
	// South Korea
	CountryCodeKr CountryCode = "KR"
	// South Sudan
	CountryCodeSs CountryCode = "SS"
	// Spain
	CountryCodeEs CountryCode = "ES"
	// Sri Lanka
	CountryCodeLk CountryCode = "LK"
	// Sudan
	CountryCodeSd CountryCode = "SD"
	// Suriname
	CountryCodeSr CountryCode = "SR"
	// Svalbard and Jan Mayen
	CountryCodeSj CountryCode = "SJ"
	// Swaziland
	CountryCodeSz CountryCode = "SZ"
	// Sweden
	CountryCodeSe CountryCode = "SE"
	// Switzerland
	CountryCodeCh CountryCode = "CH"
	// Syria
	CountryCodeSy CountryCode = "SY"
	// Taiwan
	CountryCodeTw CountryCode = "TW"
	// Tajikistan
	CountryCodeTj CountryCode = "TJ"
	// Tanzania
	CountryCodeTz CountryCode = "TZ"
	// Thailand
	CountryCodeTh CountryCode = "TH"
	// Togo
	CountryCodeTg CountryCode = "TG"
	// Tokelau
	CountryCodeTk CountryCode = "TK"
	// Tonga
	CountryCodeTo CountryCode = "TO"
	// Trinidad and Tobago
	CountryCodeTt CountryCode = "TT"
	// Tunisia
	CountryCodeTn CountryCode = "TN"
	// Turkey
	CountryCodeTr CountryCode = "TR"
	// Turkmenistan
	CountryCodeTm CountryCode = "TM"
	// Turks and Caicos Islands
	CountryCodeTc CountryCode = "TC"
	// Tuvalu
	CountryCodeTv CountryCode = "TV"
	// U.S. Virgin Islands
	CountryCodeVi CountryCode = "VI"
	// Uganda
	CountryCodeUg CountryCode = "UG"
	// Ukraine
	CountryCodeUa CountryCode = "UA"
	// United Arab Emirates
	CountryCodeAe CountryCode = "AE"
	// United Kingdom
	CountryCodeGb CountryCode = "GB"
	// United States
	CountryCodeUs CountryCode = "US"
	// Uruguay
	CountryCodeUy CountryCode = "UY"
	// Uzbekistan
	CountryCodeUz CountryCode = "UZ"
	// Vanuatu
	CountryCodeVu CountryCode = "VU"
	// Vatican
	CountryCodeVa CountryCode = "VA"
	// Venezuela
	CountryCodeVe CountryCode = "VE"
	// Vietnam
	CountryCodeVn CountryCode = "VN"
	// Wallis and Futuna
	CountryCodeWf CountryCode = "WF"
	// Western Sahara
	CountryCodeEh CountryCode = "EH"
	// Yemen
	CountryCodeYe CountryCode = "YE"
	// Zambia
	CountryCodeZm CountryCode = "ZM"
	// Zimbabwe
	CountryCodeZw CountryCode = "ZW"
)

var AllCountryCode = []CountryCode{
	CountryCodeAf,
	CountryCodeAl,
	CountryCodeDz,
	CountryCodeAs,
	CountryCodeAd,
	CountryCodeAo,
	CountryCodeAi,
	CountryCodeAq,
	CountryCodeAg,
	CountryCodeAr,
	CountryCodeAm,
	CountryCodeAw,
	CountryCodeAu,
	CountryCodeAt,
	CountryCodeAz,
	CountryCodeBs,
	CountryCodeBh,
	CountryCodeBd,
	CountryCodeBb,
	CountryCodeBy,
	CountryCodeBe,
	CountryCodeBz,
	CountryCodeBj,
	CountryCodeBm,
	CountryCodeBt,
	CountryCodeBo,
	CountryCodeBa,
	CountryCodeBw,
	CountryCodeBr,
	CountryCodeIo,
	CountryCodeVg,
	CountryCodeBn,
	CountryCodeBg,
	CountryCodeBf,
	CountryCodeBi,
	CountryCodeKh,
	CountryCodeCm,
	CountryCodeCa,
	CountryCodeCv,
	CountryCodeKy,
	CountryCodeCf,
	CountryCodeTd,
	CountryCodeCl,
	CountryCodeCn,
	CountryCodeCx,
	CountryCodeCc,
	CountryCodeCo,
	CountryCodeKm,
	CountryCodeCk,
	CountryCodeCr,
	CountryCodeHr,
	CountryCodeCu,
	CountryCodeCw,
	CountryCodeCy,
	CountryCodeCz,
	CountryCodeCd,
	CountryCodeDk,
	CountryCodeDj,
	CountryCodeDm,
	CountryCodeDo,
	CountryCodeTl,
	CountryCodeEc,
	CountryCodeEg,
	CountryCodeSv,
	CountryCodeGq,
	CountryCodeEr,
	CountryCodeEe,
	CountryCodeEt,
	CountryCodeFk,
	CountryCodeFo,
	CountryCodeFj,
	CountryCodeFi,
	CountryCodeFr,
	CountryCodePf,
	CountryCodeGa,
	CountryCodeGm,
	CountryCodeGe,
	CountryCodeDe,
	CountryCodeGh,
	CountryCodeGi,
	CountryCodeGr,
	CountryCodeGl,
	CountryCodeGd,
	CountryCodeGu,
	CountryCodeGt,
	CountryCodeGg,
	CountryCodeGn,
	CountryCodeGw,
	CountryCodeGy,
	CountryCodeHt,
	CountryCodeHn,
	CountryCodeHk,
	CountryCodeHu,
	CountryCodeIs,
	CountryCodeIn,
	CountryCodeID,
	CountryCodeIr,
	CountryCodeIq,
	CountryCodeIe,
	CountryCodeIm,
	CountryCodeIl,
	CountryCodeIt,
	CountryCodeCi,
	CountryCodeJm,
	CountryCodeJp,
	CountryCodeJe,
	CountryCodeJo,
	CountryCodeKz,
	CountryCodeKe,
	CountryCodeKi,
	CountryCodeXk,
	CountryCodeKw,
	CountryCodeKg,
	CountryCodeLa,
	CountryCodeLv,
	CountryCodeLb,
	CountryCodeLs,
	CountryCodeLr,
	CountryCodeLy,
	CountryCodeLi,
	CountryCodeLt,
	CountryCodeLu,
	CountryCodeMo,
	CountryCodeMk,
	CountryCodeMg,
	CountryCodeMw,
	CountryCodeMy,
	CountryCodeMv,
	CountryCodeMl,
	CountryCodeMt,
	CountryCodeMh,
	CountryCodeMr,
	CountryCodeMu,
	CountryCodeYt,
	CountryCodeMx,
	CountryCodeFm,
	CountryCodeMd,
	CountryCodeMc,
	CountryCodeMn,
	CountryCodeMe,
	CountryCodeMs,
	CountryCodeMa,
	CountryCodeMz,
	CountryCodeMm,
	CountryCodeNa,
	CountryCodeNr,
	CountryCodeNp,
	CountryCodeNl,
	CountryCodeAn,
	CountryCodeNc,
	CountryCodeNz,
	CountryCodeNi,
	CountryCodeNe,
	CountryCodeNg,
	CountryCodeNu,
	CountryCodeKp,
	CountryCodeMp,
	CountryCodeNo,
	CountryCodeOm,
	CountryCodePk,
	CountryCodePw,
	CountryCodePs,
	CountryCodePa,
	CountryCodePg,
	CountryCodePy,
	CountryCodePe,
	CountryCodePh,
	CountryCodePn,
	CountryCodePl,
	CountryCodePt,
	CountryCodePr,
	CountryCodeQa,
	CountryCodeCg,
	CountryCodeRe,
	CountryCodeRo,
	CountryCodeRu,
	CountryCodeRw,
	CountryCodeBl,
	CountryCodeSh,
	CountryCodeKn,
	CountryCodeLc,
	CountryCodeMf,
	CountryCodePm,
	CountryCodeVc,
	CountryCodeWs,
	CountryCodeSm,
	CountryCodeSt,
	CountryCodeSa,
	CountryCodeSn,
	CountryCodeRs,
	CountryCodeSc,
	CountryCodeSl,
	CountryCodeSg,
	CountryCodeSx,
	CountryCodeSk,
	CountryCodeSi,
	CountryCodeSb,
	CountryCodeSo,
	CountryCodeZa,
	CountryCodeKr,
	CountryCodeSs,
	CountryCodeEs,
	CountryCodeLk,
	CountryCodeSd,
	CountryCodeSr,
	CountryCodeSj,
	CountryCodeSz,
	CountryCodeSe,
	CountryCodeCh,
	CountryCodeSy,
	CountryCodeTw,
	CountryCodeTj,
	CountryCodeTz,
	CountryCodeTh,
	CountryCodeTg,
	CountryCodeTk,
	CountryCodeTo,
	CountryCodeTt,
	CountryCodeTn,
	CountryCodeTr,
	CountryCodeTm,
	CountryCodeTc,
	CountryCodeTv,
	CountryCodeVi,
	CountryCodeUg,
	CountryCodeUa,
	CountryCodeAe,
	CountryCodeGb,
	CountryCodeUs,
	CountryCodeUy,
	CountryCodeUz,
	CountryCodeVu,
	CountryCodeVa,
	CountryCodeVe,
	CountryCodeVn,
	CountryCodeWf,
	CountryCodeEh,
	CountryCodeYe,
	CountryCodeZm,
	CountryCodeZw,
}

func (e CountryCode) IsValid() bool {
	switch e {
	case CountryCodeAf, CountryCodeAl, CountryCodeDz, CountryCodeAs, CountryCodeAd, CountryCodeAo, CountryCodeAi, CountryCodeAq, CountryCodeAg, CountryCodeAr, CountryCodeAm, CountryCodeAw, CountryCodeAu, CountryCodeAt, CountryCodeAz, CountryCodeBs, CountryCodeBh, CountryCodeBd, CountryCodeBb, CountryCodeBy, CountryCodeBe, CountryCodeBz, CountryCodeBj, CountryCodeBm, CountryCodeBt, CountryCodeBo, CountryCodeBa, CountryCodeBw, CountryCodeBr, CountryCodeIo, CountryCodeVg, CountryCodeBn, CountryCodeBg, CountryCodeBf, CountryCodeBi, CountryCodeKh, CountryCodeCm, CountryCodeCa, CountryCodeCv, CountryCodeKy, CountryCodeCf, CountryCodeTd, CountryCodeCl, CountryCodeCn, CountryCodeCx, CountryCodeCc, CountryCodeCo, CountryCodeKm, CountryCodeCk, CountryCodeCr, CountryCodeHr, CountryCodeCu, CountryCodeCw, CountryCodeCy, CountryCodeCz, CountryCodeCd, CountryCodeDk, CountryCodeDj, CountryCodeDm, CountryCodeDo, CountryCodeTl, CountryCodeEc, CountryCodeEg, CountryCodeSv, CountryCodeGq, CountryCodeEr, CountryCodeEe, CountryCodeEt, CountryCodeFk, CountryCodeFo, CountryCodeFj, CountryCodeFi, CountryCodeFr, CountryCodePf, CountryCodeGa, CountryCodeGm, CountryCodeGe, CountryCodeDe, CountryCodeGh, CountryCodeGi, CountryCodeGr, CountryCodeGl, CountryCodeGd, CountryCodeGu, CountryCodeGt, CountryCodeGg, CountryCodeGn, CountryCodeGw, CountryCodeGy, CountryCodeHt, CountryCodeHn, CountryCodeHk, CountryCodeHu, CountryCodeIs, CountryCodeIn, CountryCodeID, CountryCodeIr, CountryCodeIq, CountryCodeIe, CountryCodeIm, CountryCodeIl, CountryCodeIt, CountryCodeCi, CountryCodeJm, CountryCodeJp, CountryCodeJe, CountryCodeJo, CountryCodeKz, CountryCodeKe, CountryCodeKi, CountryCodeXk, CountryCodeKw, CountryCodeKg, CountryCodeLa, CountryCodeLv, CountryCodeLb, CountryCodeLs, CountryCodeLr, CountryCodeLy, CountryCodeLi, CountryCodeLt, CountryCodeLu, CountryCodeMo, CountryCodeMk, CountryCodeMg, CountryCodeMw, CountryCodeMy, CountryCodeMv, CountryCodeMl, CountryCodeMt, CountryCodeMh, CountryCodeMr, CountryCodeMu, CountryCodeYt, CountryCodeMx, CountryCodeFm, CountryCodeMd, CountryCodeMc, CountryCodeMn, CountryCodeMe, CountryCodeMs, CountryCodeMa, CountryCodeMz, CountryCodeMm, CountryCodeNa, CountryCodeNr, CountryCodeNp, CountryCodeNl, CountryCodeAn, CountryCodeNc, CountryCodeNz, CountryCodeNi, CountryCodeNe, CountryCodeNg, CountryCodeNu, CountryCodeKp, CountryCodeMp, CountryCodeNo, CountryCodeOm, CountryCodePk, CountryCodePw, CountryCodePs, CountryCodePa, CountryCodePg, CountryCodePy, CountryCodePe, CountryCodePh, CountryCodePn, CountryCodePl, CountryCodePt, CountryCodePr, CountryCodeQa, CountryCodeCg, CountryCodeRe, CountryCodeRo, CountryCodeRu, CountryCodeRw, CountryCodeBl, CountryCodeSh, CountryCodeKn, CountryCodeLc, CountryCodeMf, CountryCodePm, CountryCodeVc, CountryCodeWs, CountryCodeSm, CountryCodeSt, CountryCodeSa, CountryCodeSn, CountryCodeRs, CountryCodeSc, CountryCodeSl, CountryCodeSg, CountryCodeSx, CountryCodeSk, CountryCodeSi, CountryCodeSb, CountryCodeSo, CountryCodeZa, CountryCodeKr, CountryCodeSs, CountryCodeEs, CountryCodeLk, CountryCodeSd, CountryCodeSr, CountryCodeSj, CountryCodeSz, CountryCodeSe, CountryCodeCh, CountryCodeSy, CountryCodeTw, CountryCodeTj, CountryCodeTz, CountryCodeTh, CountryCodeTg, CountryCodeTk, CountryCodeTo, CountryCodeTt, CountryCodeTn, CountryCodeTr, CountryCodeTm, CountryCodeTc, CountryCodeTv, CountryCodeVi, CountryCodeUg, CountryCodeUa, CountryCodeAe, CountryCodeGb, CountryCodeUs, CountryCodeUy, CountryCodeUz, CountryCodeVu, CountryCodeVa, CountryCodeVe, CountryCodeVn, CountryCodeWf, CountryCodeEh, CountryCodeYe, CountryCodeZm, CountryCodeZw:
		return true
	}
	return false
}

func (e CountryCode) String() string {
	return string(e)
}

func (e *CountryCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountryCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountryCode", str)
	}
	return nil
}

func (e CountryCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DateInterval string

const (
	// Year
	DateIntervalYear DateInterval = "year"
	// Month
	DateIntervalMonth DateInterval = "month"
	// Week
	DateIntervalWeek DateInterval = "week"
	// Day
	DateIntervalDay DateInterval = "day"
)

var AllDateInterval = []DateInterval{
	DateIntervalYear,
	DateIntervalMonth,
	DateIntervalWeek,
	DateIntervalDay,
}

func (e DateInterval) IsValid() bool {
	switch e {
	case DateIntervalYear, DateIntervalMonth, DateIntervalWeek, DateIntervalDay:
		return true
	}
	return false
}

func (e DateInterval) String() string {
	return string(e)
}

func (e *DateInterval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DateInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DateInterval", str)
	}
	return nil
}

func (e DateInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DiemNetwork string

const (
	// Diem Testnet
	DiemNetworkDiemTestnet DiemNetwork = "diem_testnet"
	// Libra Testnet
	DiemNetworkLibraTestnet DiemNetwork = "libra_testnet"
)

var AllDiemNetwork = []DiemNetwork{
	DiemNetworkDiemTestnet,
	DiemNetworkLibraTestnet,
}

func (e DiemNetwork) IsValid() bool {
	switch e {
	case DiemNetworkDiemTestnet, DiemNetworkLibraTestnet:
		return true
	}
	return false
}

func (e DiemNetwork) String() string {
	return string(e)
}

func (e *DiemNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiemNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiemNetwork", str)
	}
	return nil
}

func (e DiemNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondArgumentUniq string

const (
	// Unique time
	ElrondArgumentUniqTimes ElrondArgumentUniq = "times"
	// Unique date count
	ElrondArgumentUniqDates ElrondArgumentUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondArgumentUniqBlockHeight ElrondArgumentUniq = "block_height"
	// Unique Transaction Hash
	ElrondArgumentUniqSignature ElrondArgumentUniq = "signature"
	// Unique number of arguments
	ElrondArgumentUniqArgumentIndex ElrondArgumentUniq = "argument_index"
)

var AllElrondArgumentUniq = []ElrondArgumentUniq{
	ElrondArgumentUniqTimes,
	ElrondArgumentUniqDates,
	ElrondArgumentUniqBlockHeight,
	ElrondArgumentUniqSignature,
	ElrondArgumentUniqArgumentIndex,
}

func (e ElrondArgumentUniq) IsValid() bool {
	switch e {
	case ElrondArgumentUniqTimes, ElrondArgumentUniqDates, ElrondArgumentUniqBlockHeight, ElrondArgumentUniqSignature, ElrondArgumentUniqArgumentIndex:
		return true
	}
	return false
}

func (e ElrondArgumentUniq) String() string {
	return string(e)
}

func (e *ElrondArgumentUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondArgumentUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondArgumentUniq", str)
	}
	return nil
}

func (e ElrondArgumentUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondArgumentsMeasureable string

const (
	// Date
	ElrondArgumentsMeasureableDate ElrondArgumentsMeasureable = "date"
	// Time
	ElrondArgumentsMeasureableTime ElrondArgumentsMeasureable = "time"
	// Hash of the the block
	ElrondArgumentsMeasureableBlockHash ElrondArgumentsMeasureable = "block_hash"
	// Number of block in the blockhains
	ElrondArgumentsMeasureableHeight ElrondArgumentsMeasureable = "height"
	// The block hash of this block`s parent
	ElrondArgumentsMeasureablePreviousBlockHash ElrondArgumentsMeasureable = "previous_block_hash"
	// The block hash of this block`s parent
	ElrondArgumentsMeasureableTransactionCount ElrondArgumentsMeasureable = "transaction_count"
	// Hash of the miniblock
	ElrondArgumentsMeasureableMiniblockHash ElrondArgumentsMeasureable = "miniblock_hash"
	// Hash of the miniblocks receiver block
	ElrondArgumentsMeasureableMiniblockReceiverBlockHash ElrondArgumentsMeasureable = "miniblock_receiver_block_hash"
	// Miniblock receiver shard
	ElrondArgumentsMeasureableMiniblockReceiverShard ElrondArgumentsMeasureable = "miniblock_receiver_shard"
	// Type of miniblock
	ElrondArgumentsMeasureableType ElrondArgumentsMeasureable = "type"
	// Transaction hash
	ElrondArgumentsMeasureableTxHash ElrondArgumentsMeasureable = "tx_hash"
	// Receiver hash
	ElrondArgumentsMeasureableTxReceiver ElrondArgumentsMeasureable = "tx_receiver"
	// Shard number of the receiver
	ElrondArgumentsMeasureableTxReceiverShard ElrondArgumentsMeasureable = "tx_receiver_shard"
	// Sender hash
	ElrondArgumentsMeasureableTxSender ElrondArgumentsMeasureable = "tx_sender"
	// Shard number of the sender
	ElrondArgumentsMeasureableTxSenderShard ElrondArgumentsMeasureable = "tx_sender_shard"
	// Transaction Signature
	ElrondArgumentsMeasureableTxSignature ElrondArgumentsMeasureable = "tx_signature"
	// Data
	ElrondArgumentsMeasureableData ElrondArgumentsMeasureable = "data"
	// Gas Limit
	ElrondArgumentsMeasureableGasLimit ElrondArgumentsMeasureable = "gas_limit"
	// Gas Price
	ElrondArgumentsMeasureableGasPrice ElrondArgumentsMeasureable = "gas_price"
	// Gas Used
	ElrondArgumentsMeasureableGasUsed ElrondArgumentsMeasureable = "gas_used"
	// Value
	ElrondArgumentsMeasureableTxValue ElrondArgumentsMeasureable = "tx_value"
	// Smart Contract Address
	ElrondArgumentsMeasureableSmartContractAddress ElrondArgumentsMeasureable = "smart_contract_address"
	// Smart Contract call path
	ElrondArgumentsMeasureableCallDepth ElrondArgumentsMeasureable = "call_depth"
	// Argument Index
	ElrondArgumentsMeasureableArgumentIndex ElrondArgumentsMeasureable = "argument_index"
	// Argument Value
	ElrondArgumentsMeasureableArgumentValue ElrondArgumentsMeasureable = "argument_value"
)

var AllElrondArgumentsMeasureable = []ElrondArgumentsMeasureable{
	ElrondArgumentsMeasureableDate,
	ElrondArgumentsMeasureableTime,
	ElrondArgumentsMeasureableBlockHash,
	ElrondArgumentsMeasureableHeight,
	ElrondArgumentsMeasureablePreviousBlockHash,
	ElrondArgumentsMeasureableTransactionCount,
	ElrondArgumentsMeasureableMiniblockHash,
	ElrondArgumentsMeasureableMiniblockReceiverBlockHash,
	ElrondArgumentsMeasureableMiniblockReceiverShard,
	ElrondArgumentsMeasureableType,
	ElrondArgumentsMeasureableTxHash,
	ElrondArgumentsMeasureableTxReceiver,
	ElrondArgumentsMeasureableTxReceiverShard,
	ElrondArgumentsMeasureableTxSender,
	ElrondArgumentsMeasureableTxSenderShard,
	ElrondArgumentsMeasureableTxSignature,
	ElrondArgumentsMeasureableData,
	ElrondArgumentsMeasureableGasLimit,
	ElrondArgumentsMeasureableGasPrice,
	ElrondArgumentsMeasureableGasUsed,
	ElrondArgumentsMeasureableTxValue,
	ElrondArgumentsMeasureableSmartContractAddress,
	ElrondArgumentsMeasureableCallDepth,
	ElrondArgumentsMeasureableArgumentIndex,
	ElrondArgumentsMeasureableArgumentValue,
}

func (e ElrondArgumentsMeasureable) IsValid() bool {
	switch e {
	case ElrondArgumentsMeasureableDate, ElrondArgumentsMeasureableTime, ElrondArgumentsMeasureableBlockHash, ElrondArgumentsMeasureableHeight, ElrondArgumentsMeasureablePreviousBlockHash, ElrondArgumentsMeasureableTransactionCount, ElrondArgumentsMeasureableMiniblockHash, ElrondArgumentsMeasureableMiniblockReceiverBlockHash, ElrondArgumentsMeasureableMiniblockReceiverShard, ElrondArgumentsMeasureableType, ElrondArgumentsMeasureableTxHash, ElrondArgumentsMeasureableTxReceiver, ElrondArgumentsMeasureableTxReceiverShard, ElrondArgumentsMeasureableTxSender, ElrondArgumentsMeasureableTxSenderShard, ElrondArgumentsMeasureableTxSignature, ElrondArgumentsMeasureableData, ElrondArgumentsMeasureableGasLimit, ElrondArgumentsMeasureableGasPrice, ElrondArgumentsMeasureableGasUsed, ElrondArgumentsMeasureableTxValue, ElrondArgumentsMeasureableSmartContractAddress, ElrondArgumentsMeasureableCallDepth, ElrondArgumentsMeasureableArgumentIndex, ElrondArgumentsMeasureableArgumentValue:
		return true
	}
	return false
}

func (e ElrondArgumentsMeasureable) String() string {
	return string(e)
}

func (e *ElrondArgumentsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondArgumentsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondArgumentsMeasureable", str)
	}
	return nil
}

func (e ElrondArgumentsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondBlockUniq string

const (
	// Unique time
	ElrondBlockUniqTimes ElrondBlockUniq = "times"
	// Unique date count
	ElrondBlockUniqDates ElrondBlockUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondBlockUniqHeight ElrondBlockUniq = "height"
	// Unique Number of Shards in the blockchains
	ElrondBlockUniqBlockShard ElrondBlockUniq = "block_shard"
)

var AllElrondBlockUniq = []ElrondBlockUniq{
	ElrondBlockUniqTimes,
	ElrondBlockUniqDates,
	ElrondBlockUniqHeight,
	ElrondBlockUniqBlockShard,
}

func (e ElrondBlockUniq) IsValid() bool {
	switch e {
	case ElrondBlockUniqTimes, ElrondBlockUniqDates, ElrondBlockUniqHeight, ElrondBlockUniqBlockShard:
		return true
	}
	return false
}

func (e ElrondBlockUniq) String() string {
	return string(e)
}

func (e *ElrondBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondBlockUniq", str)
	}
	return nil
}

func (e ElrondBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondBlockValidatorUniq string

const (
	// Unique time
	ElrondBlockValidatorUniqTimes ElrondBlockValidatorUniq = "times"
	// Unique date count
	ElrondBlockValidatorUniqDates ElrondBlockValidatorUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondBlockValidatorUniqHeight ElrondBlockValidatorUniq = "height"
	// Unique number of validators
	ElrondBlockValidatorUniqValidators ElrondBlockValidatorUniq = "validators"
)

var AllElrondBlockValidatorUniq = []ElrondBlockValidatorUniq{
	ElrondBlockValidatorUniqTimes,
	ElrondBlockValidatorUniqDates,
	ElrondBlockValidatorUniqHeight,
	ElrondBlockValidatorUniqValidators,
}

func (e ElrondBlockValidatorUniq) IsValid() bool {
	switch e {
	case ElrondBlockValidatorUniqTimes, ElrondBlockValidatorUniqDates, ElrondBlockValidatorUniqHeight, ElrondBlockValidatorUniqValidators:
		return true
	}
	return false
}

func (e ElrondBlockValidatorUniq) String() string {
	return string(e)
}

func (e *ElrondBlockValidatorUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondBlockValidatorUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondBlockValidatorUniq", str)
	}
	return nil
}

func (e ElrondBlockValidatorUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondBlockValidatorsMeasureable string

const (
	// Date
	ElrondBlockValidatorsMeasureableDate ElrondBlockValidatorsMeasureable = "date"
	// Time
	ElrondBlockValidatorsMeasureableTime ElrondBlockValidatorsMeasureable = "time"
	// Hash of the the block
	ElrondBlockValidatorsMeasureableHash ElrondBlockValidatorsMeasureable = "hash"
	// Number of block in the blockhains
	ElrondBlockValidatorsMeasureableHeight ElrondBlockValidatorsMeasureable = "height"
	// The block hash of this block`s parent
	ElrondBlockValidatorsMeasureablePreviousBlockHash ElrondBlockValidatorsMeasureable = "previous_block_hash"
	// Shard number of block
	ElrondBlockValidatorsMeasureableShard ElrondBlockValidatorsMeasureable = "shard"
	// Block proposer
	ElrondBlockValidatorsMeasureableProposer ElrondBlockValidatorsMeasureable = "proposer"
	// Block epoch
	ElrondBlockValidatorsMeasureableEpoch ElrondBlockValidatorsMeasureable = "epoch"
	// Block nonce
	ElrondBlockValidatorsMeasureableNonce ElrondBlockValidatorsMeasureable = "nonce"
	// Block round
	ElrondBlockValidatorsMeasureableRound ElrondBlockValidatorsMeasureable = "round"
	// Block public key bitmap
	ElrondBlockValidatorsMeasureablePublicKeyBitmap ElrondBlockValidatorsMeasureable = "public_key_bitmap"
	// Block size
	ElrondBlockValidatorsMeasureableSize ElrondBlockValidatorsMeasureable = "size"
	// Block size txs
	ElrondBlockValidatorsMeasureableSizeTxs ElrondBlockValidatorsMeasureable = "size_txs"
	// State root hash
	ElrondBlockValidatorsMeasureableStateRootHash ElrondBlockValidatorsMeasureable = "state_root_hash"
	// Count of transactions in this block
	ElrondBlockValidatorsMeasureableTransactionCount ElrondBlockValidatorsMeasureable = "transaction_count"
	// Hash of the validator
	ElrondBlockValidatorsMeasureableValidator ElrondBlockValidatorsMeasureable = "validator"
)

var AllElrondBlockValidatorsMeasureable = []ElrondBlockValidatorsMeasureable{
	ElrondBlockValidatorsMeasureableDate,
	ElrondBlockValidatorsMeasureableTime,
	ElrondBlockValidatorsMeasureableHash,
	ElrondBlockValidatorsMeasureableHeight,
	ElrondBlockValidatorsMeasureablePreviousBlockHash,
	ElrondBlockValidatorsMeasureableShard,
	ElrondBlockValidatorsMeasureableProposer,
	ElrondBlockValidatorsMeasureableEpoch,
	ElrondBlockValidatorsMeasureableNonce,
	ElrondBlockValidatorsMeasureableRound,
	ElrondBlockValidatorsMeasureablePublicKeyBitmap,
	ElrondBlockValidatorsMeasureableSize,
	ElrondBlockValidatorsMeasureableSizeTxs,
	ElrondBlockValidatorsMeasureableStateRootHash,
	ElrondBlockValidatorsMeasureableTransactionCount,
	ElrondBlockValidatorsMeasureableValidator,
}

func (e ElrondBlockValidatorsMeasureable) IsValid() bool {
	switch e {
	case ElrondBlockValidatorsMeasureableDate, ElrondBlockValidatorsMeasureableTime, ElrondBlockValidatorsMeasureableHash, ElrondBlockValidatorsMeasureableHeight, ElrondBlockValidatorsMeasureablePreviousBlockHash, ElrondBlockValidatorsMeasureableShard, ElrondBlockValidatorsMeasureableProposer, ElrondBlockValidatorsMeasureableEpoch, ElrondBlockValidatorsMeasureableNonce, ElrondBlockValidatorsMeasureableRound, ElrondBlockValidatorsMeasureablePublicKeyBitmap, ElrondBlockValidatorsMeasureableSize, ElrondBlockValidatorsMeasureableSizeTxs, ElrondBlockValidatorsMeasureableStateRootHash, ElrondBlockValidatorsMeasureableTransactionCount, ElrondBlockValidatorsMeasureableValidator:
		return true
	}
	return false
}

func (e ElrondBlockValidatorsMeasureable) String() string {
	return string(e)
}

func (e *ElrondBlockValidatorsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondBlockValidatorsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondBlockValidatorsMeasureable", str)
	}
	return nil
}

func (e ElrondBlockValidatorsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondBlocksMeasureable string

const (
	// Date
	ElrondBlocksMeasureableDate ElrondBlocksMeasureable = "date"
	// Time
	ElrondBlocksMeasureableTime ElrondBlocksMeasureable = "time"
	// Hash of the the block
	ElrondBlocksMeasureableHash ElrondBlocksMeasureable = "hash"
	// Number of block in the blockhains
	ElrondBlocksMeasureableHeight ElrondBlocksMeasureable = "height"
	// The block hash of this block`s parent
	ElrondBlocksMeasureablePreviousBlockHash ElrondBlocksMeasureable = "previous_block_hash"
	// Shard number of block
	ElrondBlocksMeasureableShard ElrondBlocksMeasureable = "shard"
	// Block proposer
	ElrondBlocksMeasureableProposer ElrondBlocksMeasureable = "proposer"
	// Block epoch
	ElrondBlocksMeasureableEpoch ElrondBlocksMeasureable = "epoch"
	// Block nonce
	ElrondBlocksMeasureableNonce ElrondBlocksMeasureable = "nonce"
	// Block round
	ElrondBlocksMeasureableRound ElrondBlocksMeasureable = "round"
	// Block public key bitmap
	ElrondBlocksMeasureablePublicKeyBitmap ElrondBlocksMeasureable = "public_key_bitmap"
	// Block size
	ElrondBlocksMeasureableSize ElrondBlocksMeasureable = "size"
	// Block size txs
	ElrondBlocksMeasureableSizeTxs ElrondBlocksMeasureable = "size_txs"
	// State root hash
	ElrondBlocksMeasureableStateRootHash ElrondBlocksMeasureable = "state_root_hash"
	// Count of transactions in this block
	ElrondBlocksMeasureableTransactionCount ElrondBlocksMeasureable = "transaction_count"
)

var AllElrondBlocksMeasureable = []ElrondBlocksMeasureable{
	ElrondBlocksMeasureableDate,
	ElrondBlocksMeasureableTime,
	ElrondBlocksMeasureableHash,
	ElrondBlocksMeasureableHeight,
	ElrondBlocksMeasureablePreviousBlockHash,
	ElrondBlocksMeasureableShard,
	ElrondBlocksMeasureableProposer,
	ElrondBlocksMeasureableEpoch,
	ElrondBlocksMeasureableNonce,
	ElrondBlocksMeasureableRound,
	ElrondBlocksMeasureablePublicKeyBitmap,
	ElrondBlocksMeasureableSize,
	ElrondBlocksMeasureableSizeTxs,
	ElrondBlocksMeasureableStateRootHash,
	ElrondBlocksMeasureableTransactionCount,
}

func (e ElrondBlocksMeasureable) IsValid() bool {
	switch e {
	case ElrondBlocksMeasureableDate, ElrondBlocksMeasureableTime, ElrondBlocksMeasureableHash, ElrondBlocksMeasureableHeight, ElrondBlocksMeasureablePreviousBlockHash, ElrondBlocksMeasureableShard, ElrondBlocksMeasureableProposer, ElrondBlocksMeasureableEpoch, ElrondBlocksMeasureableNonce, ElrondBlocksMeasureableRound, ElrondBlocksMeasureablePublicKeyBitmap, ElrondBlocksMeasureableSize, ElrondBlocksMeasureableSizeTxs, ElrondBlocksMeasureableStateRootHash, ElrondBlocksMeasureableTransactionCount:
		return true
	}
	return false
}

func (e ElrondBlocksMeasureable) String() string {
	return string(e)
}

func (e *ElrondBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondBlocksMeasureable", str)
	}
	return nil
}

func (e ElrondBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondCallResultUniq string

const (
	// Unique time
	ElrondCallResultUniqTimes ElrondCallResultUniq = "times"
	// Unique date count
	ElrondCallResultUniqDates ElrondCallResultUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondCallResultUniqHeight ElrondCallResultUniq = "height"
	// Unique Number of call results
	ElrondCallResultUniqIndex ElrondCallResultUniq = "index"
)

var AllElrondCallResultUniq = []ElrondCallResultUniq{
	ElrondCallResultUniqTimes,
	ElrondCallResultUniqDates,
	ElrondCallResultUniqHeight,
	ElrondCallResultUniqIndex,
}

func (e ElrondCallResultUniq) IsValid() bool {
	switch e {
	case ElrondCallResultUniqTimes, ElrondCallResultUniqDates, ElrondCallResultUniqHeight, ElrondCallResultUniqIndex:
		return true
	}
	return false
}

func (e ElrondCallResultUniq) String() string {
	return string(e)
}

func (e *ElrondCallResultUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondCallResultUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondCallResultUniq", str)
	}
	return nil
}

func (e ElrondCallResultUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondCallResultsMeasureable string

const (
	// Date
	ElrondCallResultsMeasureableDate ElrondCallResultsMeasureable = "date"
	// Time
	ElrondCallResultsMeasureableTime ElrondCallResultsMeasureable = "time"
	// Hash of the the block
	ElrondCallResultsMeasureableBlockHash ElrondCallResultsMeasureable = "block_hash"
	// Number of block in the blockhains
	ElrondCallResultsMeasureableHeight ElrondCallResultsMeasureable = "height"
	// The block hash of this block`s parent
	ElrondCallResultsMeasureablePreviousBlockHash ElrondCallResultsMeasureable = "previous_block_hash"
	// The block hash of this block`s parent
	ElrondCallResultsMeasureableTransactionCount ElrondCallResultsMeasureable = "transaction_count"
	// Hash of the miniblock
	ElrondCallResultsMeasureableMiniblockHash ElrondCallResultsMeasureable = "miniblock_hash"
	// Hash of the miniblocks receiver block
	ElrondCallResultsMeasureableMiniblockReceiverBlockHash ElrondCallResultsMeasureable = "miniblock_receiver_block_hash"
	// Miniblock receiver shard
	ElrondCallResultsMeasureableMiniblockReceiverShard ElrondCallResultsMeasureable = "miniblock_receiver_shard"
	// Type of miniblock
	ElrondCallResultsMeasureableType ElrondCallResultsMeasureable = "type"
	// Transaction hash
	ElrondCallResultsMeasureableTxHash ElrondCallResultsMeasureable = "tx_hash"
	// Receiver hash
	ElrondCallResultsMeasureableTxReceiver ElrondCallResultsMeasureable = "tx_receiver"
	// Shard number of the receiver
	ElrondCallResultsMeasureableTxReceiverShard ElrondCallResultsMeasureable = "tx_receiver_shard"
	// Sender hash
	ElrondCallResultsMeasureableTxSender ElrondCallResultsMeasureable = "tx_sender"
	// Shard number of the sender
	ElrondCallResultsMeasureableTxSenderShard ElrondCallResultsMeasureable = "tx_sender_shard"
	// Data
	ElrondCallResultsMeasureableData ElrondCallResultsMeasureable = "data"
	// Gas Limit
	ElrondCallResultsMeasureableGasLimit ElrondCallResultsMeasureable = "gas_limit"
	// Gas Price
	ElrondCallResultsMeasureableGasPrice ElrondCallResultsMeasureable = "gas_price"
	// Gas Used
	ElrondCallResultsMeasureableGasUsed ElrondCallResultsMeasureable = "gas_used"
	// Value
	ElrondCallResultsMeasureableTxValue ElrondCallResultsMeasureable = "tx_value"
	// Index of the call result
	ElrondCallResultsMeasureableCallResultIndex ElrondCallResultsMeasureable = "call_result_index"
	// Data of the call result
	ElrondCallResultsMeasureableCallResultData ElrondCallResultsMeasureable = "call_result_data"
	// Hash of the call result
	ElrondCallResultsMeasureableCallResultHash ElrondCallResultsMeasureable = "call_result_hash"
	// Previous transaction hash of the call result
	ElrondCallResultsMeasureablePreviousTxHash ElrondCallResultsMeasureable = "previous_tx_hash"
	// Receiver of the call result
	ElrondCallResultsMeasureableCallResultReceiver ElrondCallResultsMeasureable = "call_result_receiver"
	// Sender of the call result
	ElrondCallResultsMeasureableCallResultSender ElrondCallResultsMeasureable = "call_result_sender"
)

var AllElrondCallResultsMeasureable = []ElrondCallResultsMeasureable{
	ElrondCallResultsMeasureableDate,
	ElrondCallResultsMeasureableTime,
	ElrondCallResultsMeasureableBlockHash,
	ElrondCallResultsMeasureableHeight,
	ElrondCallResultsMeasureablePreviousBlockHash,
	ElrondCallResultsMeasureableTransactionCount,
	ElrondCallResultsMeasureableMiniblockHash,
	ElrondCallResultsMeasureableMiniblockReceiverBlockHash,
	ElrondCallResultsMeasureableMiniblockReceiverShard,
	ElrondCallResultsMeasureableType,
	ElrondCallResultsMeasureableTxHash,
	ElrondCallResultsMeasureableTxReceiver,
	ElrondCallResultsMeasureableTxReceiverShard,
	ElrondCallResultsMeasureableTxSender,
	ElrondCallResultsMeasureableTxSenderShard,
	ElrondCallResultsMeasureableData,
	ElrondCallResultsMeasureableGasLimit,
	ElrondCallResultsMeasureableGasPrice,
	ElrondCallResultsMeasureableGasUsed,
	ElrondCallResultsMeasureableTxValue,
	ElrondCallResultsMeasureableCallResultIndex,
	ElrondCallResultsMeasureableCallResultData,
	ElrondCallResultsMeasureableCallResultHash,
	ElrondCallResultsMeasureablePreviousTxHash,
	ElrondCallResultsMeasureableCallResultReceiver,
	ElrondCallResultsMeasureableCallResultSender,
}

func (e ElrondCallResultsMeasureable) IsValid() bool {
	switch e {
	case ElrondCallResultsMeasureableDate, ElrondCallResultsMeasureableTime, ElrondCallResultsMeasureableBlockHash, ElrondCallResultsMeasureableHeight, ElrondCallResultsMeasureablePreviousBlockHash, ElrondCallResultsMeasureableTransactionCount, ElrondCallResultsMeasureableMiniblockHash, ElrondCallResultsMeasureableMiniblockReceiverBlockHash, ElrondCallResultsMeasureableMiniblockReceiverShard, ElrondCallResultsMeasureableType, ElrondCallResultsMeasureableTxHash, ElrondCallResultsMeasureableTxReceiver, ElrondCallResultsMeasureableTxReceiverShard, ElrondCallResultsMeasureableTxSender, ElrondCallResultsMeasureableTxSenderShard, ElrondCallResultsMeasureableData, ElrondCallResultsMeasureableGasLimit, ElrondCallResultsMeasureableGasPrice, ElrondCallResultsMeasureableGasUsed, ElrondCallResultsMeasureableTxValue, ElrondCallResultsMeasureableCallResultIndex, ElrondCallResultsMeasureableCallResultData, ElrondCallResultsMeasureableCallResultHash, ElrondCallResultsMeasureablePreviousTxHash, ElrondCallResultsMeasureableCallResultReceiver, ElrondCallResultsMeasureableCallResultSender:
		return true
	}
	return false
}

func (e ElrondCallResultsMeasureable) String() string {
	return string(e)
}

func (e *ElrondCallResultsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondCallResultsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondCallResultsMeasureable", str)
	}
	return nil
}

func (e ElrondCallResultsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondCallsMeasureable string

const (
	// Date
	ElrondCallsMeasureableDate ElrondCallsMeasureable = "date"
	// Time
	ElrondCallsMeasureableTime ElrondCallsMeasureable = "time"
	// Hash of the the block
	ElrondCallsMeasureableBlockHash ElrondCallsMeasureable = "block_hash"
	// Number of block in the blockhains
	ElrondCallsMeasureableHeight ElrondCallsMeasureable = "height"
	// The block hash of this block`s parent
	ElrondCallsMeasureablePreviousBlockHash ElrondCallsMeasureable = "previous_block_hash"
	// The block hash of this block`s parent
	ElrondCallsMeasureableTransactionCount ElrondCallsMeasureable = "transaction_count"
	// Hash of the miniblock
	ElrondCallsMeasureableMiniblockHash ElrondCallsMeasureable = "miniblock_hash"
	// Hash of the miniblocks receiver block
	ElrondCallsMeasureableMiniblockReceiverBlockHash ElrondCallsMeasureable = "miniblock_receiver_block_hash"
	// Miniblock receiver shard
	ElrondCallsMeasureableMiniblockReceiverShard ElrondCallsMeasureable = "miniblock_receiver_shard"
	// Type of miniblock
	ElrondCallsMeasureableType ElrondCallsMeasureable = "type"
	// Transaction hash
	ElrondCallsMeasureableTxHash ElrondCallsMeasureable = "tx_hash"
	// Receiver hash
	ElrondCallsMeasureableTxReceiver ElrondCallsMeasureable = "tx_receiver"
	// Shard number of the receiver
	ElrondCallsMeasureableTxReceiverShard ElrondCallsMeasureable = "tx_receiver_shard"
	// Sender hash
	ElrondCallsMeasureableTxSender ElrondCallsMeasureable = "tx_sender"
	// Shard number of the sender
	ElrondCallsMeasureableTxSenderShard ElrondCallsMeasureable = "tx_sender_shard"
	// Data
	ElrondCallsMeasureableData ElrondCallsMeasureable = "data"
	// Gas Limit
	ElrondCallsMeasureableGasLimit ElrondCallsMeasureable = "gas_limit"
	// Gas Price
	ElrondCallsMeasureableGasPrice ElrondCallsMeasureable = "gas_price"
	// Gas Used
	ElrondCallsMeasureableGasUsed ElrondCallsMeasureable = "gas_used"
	// Value
	ElrondCallsMeasureableTxValue ElrondCallsMeasureable = "tx_value"
	// Smart Contract
	ElrondCallsMeasureableSmartContract ElrondCallsMeasureable = "smart_contract"
	// Smart Contract Method Name
	ElrondCallsMeasureableSignatureName ElrondCallsMeasureable = "signature_name"
	// Smart Contract Method Signature
	ElrondCallsMeasureableSignature ElrondCallsMeasureable = "signature"
	// Smart Contract Method Signature Hash
	ElrondCallsMeasureableSignatureHash ElrondCallsMeasureable = "signature_hash"
	// Call depth
	ElrondCallsMeasureableCallDepth ElrondCallsMeasureable = "call_depth"
)

var AllElrondCallsMeasureable = []ElrondCallsMeasureable{
	ElrondCallsMeasureableDate,
	ElrondCallsMeasureableTime,
	ElrondCallsMeasureableBlockHash,
	ElrondCallsMeasureableHeight,
	ElrondCallsMeasureablePreviousBlockHash,
	ElrondCallsMeasureableTransactionCount,
	ElrondCallsMeasureableMiniblockHash,
	ElrondCallsMeasureableMiniblockReceiverBlockHash,
	ElrondCallsMeasureableMiniblockReceiverShard,
	ElrondCallsMeasureableType,
	ElrondCallsMeasureableTxHash,
	ElrondCallsMeasureableTxReceiver,
	ElrondCallsMeasureableTxReceiverShard,
	ElrondCallsMeasureableTxSender,
	ElrondCallsMeasureableTxSenderShard,
	ElrondCallsMeasureableData,
	ElrondCallsMeasureableGasLimit,
	ElrondCallsMeasureableGasPrice,
	ElrondCallsMeasureableGasUsed,
	ElrondCallsMeasureableTxValue,
	ElrondCallsMeasureableSmartContract,
	ElrondCallsMeasureableSignatureName,
	ElrondCallsMeasureableSignature,
	ElrondCallsMeasureableSignatureHash,
	ElrondCallsMeasureableCallDepth,
}

func (e ElrondCallsMeasureable) IsValid() bool {
	switch e {
	case ElrondCallsMeasureableDate, ElrondCallsMeasureableTime, ElrondCallsMeasureableBlockHash, ElrondCallsMeasureableHeight, ElrondCallsMeasureablePreviousBlockHash, ElrondCallsMeasureableTransactionCount, ElrondCallsMeasureableMiniblockHash, ElrondCallsMeasureableMiniblockReceiverBlockHash, ElrondCallsMeasureableMiniblockReceiverShard, ElrondCallsMeasureableType, ElrondCallsMeasureableTxHash, ElrondCallsMeasureableTxReceiver, ElrondCallsMeasureableTxReceiverShard, ElrondCallsMeasureableTxSender, ElrondCallsMeasureableTxSenderShard, ElrondCallsMeasureableData, ElrondCallsMeasureableGasLimit, ElrondCallsMeasureableGasPrice, ElrondCallsMeasureableGasUsed, ElrondCallsMeasureableTxValue, ElrondCallsMeasureableSmartContract, ElrondCallsMeasureableSignatureName, ElrondCallsMeasureableSignature, ElrondCallsMeasureableSignatureHash, ElrondCallsMeasureableCallDepth:
		return true
	}
	return false
}

func (e ElrondCallsMeasureable) String() string {
	return string(e)
}

func (e *ElrondCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondCallsMeasureable", str)
	}
	return nil
}

func (e ElrondCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondCallsUni string

const (
	// Unique time
	ElrondCallsUniTimes ElrondCallsUni = "times"
	// Unique date count
	ElrondCallsUniDates ElrondCallsUni = "dates"
	// Unique Number of block in the blockchains
	ElrondCallsUniHeight ElrondCallsUni = "height"
	// Unique Number of smart contract
	ElrondCallsUniSmartContracts ElrondCallsUni = "smart_contracts"
	// Unique Number of smart contract methods
	ElrondCallsUniSmartContractMethods ElrondCallsUni = "smart_contract_methods"
)

var AllElrondCallsUni = []ElrondCallsUni{
	ElrondCallsUniTimes,
	ElrondCallsUniDates,
	ElrondCallsUniHeight,
	ElrondCallsUniSmartContracts,
	ElrondCallsUniSmartContractMethods,
}

func (e ElrondCallsUni) IsValid() bool {
	switch e {
	case ElrondCallsUniTimes, ElrondCallsUniDates, ElrondCallsUniHeight, ElrondCallsUniSmartContracts, ElrondCallsUniSmartContractMethods:
		return true
	}
	return false
}

func (e ElrondCallsUni) String() string {
	return string(e)
}

func (e *ElrondCallsUni) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondCallsUni(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondCallsUni", str)
	}
	return nil
}

func (e ElrondCallsUni) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondCoinpathMeasureable string

const (
	// Time
	ElrondCoinpathMeasureableTime ElrondCoinpathMeasureable = "time"
	// Block
	ElrondCoinpathMeasureableBlock ElrondCoinpathMeasureable = "block"
	// Version
	ElrondCoinpathMeasureableTxHash ElrondCoinpathMeasureable = "tx_hash"
	// Sender
	ElrondCoinpathMeasureableSender ElrondCoinpathMeasureable = "sender"
	// Receiver
	ElrondCoinpathMeasureableReceiver ElrondCoinpathMeasureable = "receiver"
	// Depth
	ElrondCoinpathMeasureableDepth ElrondCoinpathMeasureable = "depth"
)

var AllElrondCoinpathMeasureable = []ElrondCoinpathMeasureable{
	ElrondCoinpathMeasureableTime,
	ElrondCoinpathMeasureableBlock,
	ElrondCoinpathMeasureableTxHash,
	ElrondCoinpathMeasureableSender,
	ElrondCoinpathMeasureableReceiver,
	ElrondCoinpathMeasureableDepth,
}

func (e ElrondCoinpathMeasureable) IsValid() bool {
	switch e {
	case ElrondCoinpathMeasureableTime, ElrondCoinpathMeasureableBlock, ElrondCoinpathMeasureableTxHash, ElrondCoinpathMeasureableSender, ElrondCoinpathMeasureableReceiver, ElrondCoinpathMeasureableDepth:
		return true
	}
	return false
}

func (e ElrondCoinpathMeasureable) String() string {
	return string(e)
}

func (e *ElrondCoinpathMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondCoinpathMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondCoinpathMeasureable", str)
	}
	return nil
}

func (e ElrondCoinpathMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondMiniblockUniq string

const (
	// Unique time
	ElrondMiniblockUniqTimes ElrondMiniblockUniq = "times"
	// Unique date count
	ElrondMiniblockUniqDates ElrondMiniblockUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondMiniblockUniqHeight ElrondMiniblockUniq = "height"
)

var AllElrondMiniblockUniq = []ElrondMiniblockUniq{
	ElrondMiniblockUniqTimes,
	ElrondMiniblockUniqDates,
	ElrondMiniblockUniqHeight,
}

func (e ElrondMiniblockUniq) IsValid() bool {
	switch e {
	case ElrondMiniblockUniqTimes, ElrondMiniblockUniqDates, ElrondMiniblockUniqHeight:
		return true
	}
	return false
}

func (e ElrondMiniblockUniq) String() string {
	return string(e)
}

func (e *ElrondMiniblockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondMiniblockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondMiniblockUniq", str)
	}
	return nil
}

func (e ElrondMiniblockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondMiniblocksMeasureable string

const (
	// Date
	ElrondMiniblocksMeasureableDate ElrondMiniblocksMeasureable = "date"
	// Time
	ElrondMiniblocksMeasureableTime ElrondMiniblocksMeasureable = "time"
	// Hash of the the block
	ElrondMiniblocksMeasureableBlockHash ElrondMiniblocksMeasureable = "block_hash"
	// Number of block in the blockhains
	ElrondMiniblocksMeasureableHeight ElrondMiniblocksMeasureable = "height"
	// The block hash of this block`s parent
	ElrondMiniblocksMeasureablePreviousBlockHash ElrondMiniblocksMeasureable = "previous_block_hash"
	// Count of transactions
	ElrondMiniblocksMeasureableTransactionCount ElrondMiniblocksMeasureable = "transaction_count"
	// Hash of the miniblock
	ElrondMiniblocksMeasureableHash ElrondMiniblocksMeasureable = "hash"
	// Hash of the miniblocks receiver block
	ElrondMiniblocksMeasureableReceiverBlockHash ElrondMiniblocksMeasureable = "receiver_block_hash"
	// Miniblock receiver shard
	ElrondMiniblocksMeasureableReceiverShard ElrondMiniblocksMeasureable = "receiver_shard"
	// Type of miniblock
	ElrondMiniblocksMeasureableType ElrondMiniblocksMeasureable = "type"
)

var AllElrondMiniblocksMeasureable = []ElrondMiniblocksMeasureable{
	ElrondMiniblocksMeasureableDate,
	ElrondMiniblocksMeasureableTime,
	ElrondMiniblocksMeasureableBlockHash,
	ElrondMiniblocksMeasureableHeight,
	ElrondMiniblocksMeasureablePreviousBlockHash,
	ElrondMiniblocksMeasureableTransactionCount,
	ElrondMiniblocksMeasureableHash,
	ElrondMiniblocksMeasureableReceiverBlockHash,
	ElrondMiniblocksMeasureableReceiverShard,
	ElrondMiniblocksMeasureableType,
}

func (e ElrondMiniblocksMeasureable) IsValid() bool {
	switch e {
	case ElrondMiniblocksMeasureableDate, ElrondMiniblocksMeasureableTime, ElrondMiniblocksMeasureableBlockHash, ElrondMiniblocksMeasureableHeight, ElrondMiniblocksMeasureablePreviousBlockHash, ElrondMiniblocksMeasureableTransactionCount, ElrondMiniblocksMeasureableHash, ElrondMiniblocksMeasureableReceiverBlockHash, ElrondMiniblocksMeasureableReceiverShard, ElrondMiniblocksMeasureableType:
		return true
	}
	return false
}

func (e ElrondMiniblocksMeasureable) String() string {
	return string(e)
}

func (e *ElrondMiniblocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondMiniblocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondMiniblocksMeasureable", str)
	}
	return nil
}

func (e ElrondMiniblocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondNetwork string

const (
	// Elrond mainnet
	ElrondNetworkElrond ElrondNetwork = "elrond"
)

var AllElrondNetwork = []ElrondNetwork{
	ElrondNetworkElrond,
}

func (e ElrondNetwork) IsValid() bool {
	switch e {
	case ElrondNetworkElrond:
		return true
	}
	return false
}

func (e ElrondNetwork) String() string {
	return string(e)
}

func (e *ElrondNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondNetwork", str)
	}
	return nil
}

func (e ElrondNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondNotarizedBlockUniq string

const (
	// Unique time
	ElrondNotarizedBlockUniqTimes ElrondNotarizedBlockUniq = "times"
	// Unique date count
	ElrondNotarizedBlockUniqDates ElrondNotarizedBlockUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondNotarizedBlockUniqHeight ElrondNotarizedBlockUniq = "height"
	// Unique hash of notarized block
	ElrondNotarizedBlockUniqNotarizedBlockHash ElrondNotarizedBlockUniq = "notarized_block_hash"
)

var AllElrondNotarizedBlockUniq = []ElrondNotarizedBlockUniq{
	ElrondNotarizedBlockUniqTimes,
	ElrondNotarizedBlockUniqDates,
	ElrondNotarizedBlockUniqHeight,
	ElrondNotarizedBlockUniqNotarizedBlockHash,
}

func (e ElrondNotarizedBlockUniq) IsValid() bool {
	switch e {
	case ElrondNotarizedBlockUniqTimes, ElrondNotarizedBlockUniqDates, ElrondNotarizedBlockUniqHeight, ElrondNotarizedBlockUniqNotarizedBlockHash:
		return true
	}
	return false
}

func (e ElrondNotarizedBlockUniq) String() string {
	return string(e)
}

func (e *ElrondNotarizedBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondNotarizedBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondNotarizedBlockUniq", str)
	}
	return nil
}

func (e ElrondNotarizedBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondNotarizedBlocksMeasureable string

const (
	// Date
	ElrondNotarizedBlocksMeasureableDate ElrondNotarizedBlocksMeasureable = "date"
	// Time
	ElrondNotarizedBlocksMeasureableTime ElrondNotarizedBlocksMeasureable = "time"
	// Hash of the the block
	ElrondNotarizedBlocksMeasureableHash ElrondNotarizedBlocksMeasureable = "hash"
	// Number of block in the blockhains
	ElrondNotarizedBlocksMeasureableHeight ElrondNotarizedBlocksMeasureable = "height"
	// The block hash of this block`s parent
	ElrondNotarizedBlocksMeasureablePreviousBlockHash ElrondNotarizedBlocksMeasureable = "previous_block_hash"
	// Shard number of block
	ElrondNotarizedBlocksMeasureableShard ElrondNotarizedBlocksMeasureable = "shard"
	// Block proposer
	ElrondNotarizedBlocksMeasureableProposer ElrondNotarizedBlocksMeasureable = "proposer"
	// Block epoch
	ElrondNotarizedBlocksMeasureableEpoch ElrondNotarizedBlocksMeasureable = "epoch"
	// Block nonce
	ElrondNotarizedBlocksMeasureableNonce ElrondNotarizedBlocksMeasureable = "nonce"
	// Block round
	ElrondNotarizedBlocksMeasureableRound ElrondNotarizedBlocksMeasureable = "round"
	// Block public key bitmap
	ElrondNotarizedBlocksMeasureablePublicKeyBitmap ElrondNotarizedBlocksMeasureable = "public_key_bitmap"
	// Block size
	ElrondNotarizedBlocksMeasureableSize ElrondNotarizedBlocksMeasureable = "size"
	// Block size txs
	ElrondNotarizedBlocksMeasureableSizeTxs ElrondNotarizedBlocksMeasureable = "size_txs"
	// State root hash
	ElrondNotarizedBlocksMeasureableStateRootHash ElrondNotarizedBlocksMeasureable = "state_root_hash"
	// Count of transactions in this block
	ElrondNotarizedBlocksMeasureableTransactionCount ElrondNotarizedBlocksMeasureable = "transaction_count"
	// Notarized block hash
	ElrondNotarizedBlocksMeasureableNotarizedBlockHash ElrondNotarizedBlocksMeasureable = "notarized_block_hash"
)

var AllElrondNotarizedBlocksMeasureable = []ElrondNotarizedBlocksMeasureable{
	ElrondNotarizedBlocksMeasureableDate,
	ElrondNotarizedBlocksMeasureableTime,
	ElrondNotarizedBlocksMeasureableHash,
	ElrondNotarizedBlocksMeasureableHeight,
	ElrondNotarizedBlocksMeasureablePreviousBlockHash,
	ElrondNotarizedBlocksMeasureableShard,
	ElrondNotarizedBlocksMeasureableProposer,
	ElrondNotarizedBlocksMeasureableEpoch,
	ElrondNotarizedBlocksMeasureableNonce,
	ElrondNotarizedBlocksMeasureableRound,
	ElrondNotarizedBlocksMeasureablePublicKeyBitmap,
	ElrondNotarizedBlocksMeasureableSize,
	ElrondNotarizedBlocksMeasureableSizeTxs,
	ElrondNotarizedBlocksMeasureableStateRootHash,
	ElrondNotarizedBlocksMeasureableTransactionCount,
	ElrondNotarizedBlocksMeasureableNotarizedBlockHash,
}

func (e ElrondNotarizedBlocksMeasureable) IsValid() bool {
	switch e {
	case ElrondNotarizedBlocksMeasureableDate, ElrondNotarizedBlocksMeasureableTime, ElrondNotarizedBlocksMeasureableHash, ElrondNotarizedBlocksMeasureableHeight, ElrondNotarizedBlocksMeasureablePreviousBlockHash, ElrondNotarizedBlocksMeasureableShard, ElrondNotarizedBlocksMeasureableProposer, ElrondNotarizedBlocksMeasureableEpoch, ElrondNotarizedBlocksMeasureableNonce, ElrondNotarizedBlocksMeasureableRound, ElrondNotarizedBlocksMeasureablePublicKeyBitmap, ElrondNotarizedBlocksMeasureableSize, ElrondNotarizedBlocksMeasureableSizeTxs, ElrondNotarizedBlocksMeasureableStateRootHash, ElrondNotarizedBlocksMeasureableTransactionCount, ElrondNotarizedBlocksMeasureableNotarizedBlockHash:
		return true
	}
	return false
}

func (e ElrondNotarizedBlocksMeasureable) String() string {
	return string(e)
}

func (e *ElrondNotarizedBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondNotarizedBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondNotarizedBlocksMeasureable", str)
	}
	return nil
}

func (e ElrondNotarizedBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondTransactionUniq string

const (
	// Unique time
	ElrondTransactionUniqTimes ElrondTransactionUniq = "times"
	// Unique date count
	ElrondTransactionUniqDates ElrondTransactionUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondTransactionUniqHeight ElrondTransactionUniq = "height"
)

var AllElrondTransactionUniq = []ElrondTransactionUniq{
	ElrondTransactionUniqTimes,
	ElrondTransactionUniqDates,
	ElrondTransactionUniqHeight,
}

func (e ElrondTransactionUniq) IsValid() bool {
	switch e {
	case ElrondTransactionUniqTimes, ElrondTransactionUniqDates, ElrondTransactionUniqHeight:
		return true
	}
	return false
}

func (e ElrondTransactionUniq) String() string {
	return string(e)
}

func (e *ElrondTransactionUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondTransactionUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondTransactionUniq", str)
	}
	return nil
}

func (e ElrondTransactionUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondTransactionsMeasureable string

const (
	// Date
	ElrondTransactionsMeasureableDate ElrondTransactionsMeasureable = "date"
	// Time
	ElrondTransactionsMeasureableTime ElrondTransactionsMeasureable = "time"
	// Hash of the the block
	ElrondTransactionsMeasureableBlockHash ElrondTransactionsMeasureable = "block_hash"
	// Number of block in the blockhains
	ElrondTransactionsMeasureableHeight ElrondTransactionsMeasureable = "height"
	// The block hash of this block`s parent
	ElrondTransactionsMeasureablePreviousBlockHash ElrondTransactionsMeasureable = "previous_block_hash"
	// The block hash of this block`s parent
	ElrondTransactionsMeasureableTransactionCount ElrondTransactionsMeasureable = "transaction_count"
	// Hash of the miniblock
	ElrondTransactionsMeasureableMiniblockHash ElrondTransactionsMeasureable = "miniblock_hash"
	// Hash of the miniblocks receiver block
	ElrondTransactionsMeasureableMiniblockReceiverBlockHash ElrondTransactionsMeasureable = "miniblock_receiver_block_hash"
	// Miniblock receiver shard
	ElrondTransactionsMeasureableMiniblockReceiverShard ElrondTransactionsMeasureable = "miniblock_receiver_shard"
	// Type of miniblock
	ElrondTransactionsMeasureableType ElrondTransactionsMeasureable = "type"
	// Transaction hash
	ElrondTransactionsMeasureableHash ElrondTransactionsMeasureable = "hash"
	// Receiver hash
	ElrondTransactionsMeasureableTxReceiver ElrondTransactionsMeasureable = "tx_receiver"
	// Shard number of the receiver
	ElrondTransactionsMeasureableTxReceiverShard ElrondTransactionsMeasureable = "tx_receiver_shard"
	// Sender hash
	ElrondTransactionsMeasureableTxSender ElrondTransactionsMeasureable = "tx_sender"
	// Shard number of the sender
	ElrondTransactionsMeasureableTxSenderShard ElrondTransactionsMeasureable = "tx_sender_shard"
	// Data
	ElrondTransactionsMeasureableData ElrondTransactionsMeasureable = "data"
	// Gas Limit
	ElrondTransactionsMeasureableGasLimit ElrondTransactionsMeasureable = "gas_limit"
	// Gas Price
	ElrondTransactionsMeasureableGasPrice ElrondTransactionsMeasureable = "gas_price"
	// Gas Used
	ElrondTransactionsMeasureableGasUsed ElrondTransactionsMeasureable = "gas_used"
	// Value
	ElrondTransactionsMeasureableValue ElrondTransactionsMeasureable = "value"
)

var AllElrondTransactionsMeasureable = []ElrondTransactionsMeasureable{
	ElrondTransactionsMeasureableDate,
	ElrondTransactionsMeasureableTime,
	ElrondTransactionsMeasureableBlockHash,
	ElrondTransactionsMeasureableHeight,
	ElrondTransactionsMeasureablePreviousBlockHash,
	ElrondTransactionsMeasureableTransactionCount,
	ElrondTransactionsMeasureableMiniblockHash,
	ElrondTransactionsMeasureableMiniblockReceiverBlockHash,
	ElrondTransactionsMeasureableMiniblockReceiverShard,
	ElrondTransactionsMeasureableType,
	ElrondTransactionsMeasureableHash,
	ElrondTransactionsMeasureableTxReceiver,
	ElrondTransactionsMeasureableTxReceiverShard,
	ElrondTransactionsMeasureableTxSender,
	ElrondTransactionsMeasureableTxSenderShard,
	ElrondTransactionsMeasureableData,
	ElrondTransactionsMeasureableGasLimit,
	ElrondTransactionsMeasureableGasPrice,
	ElrondTransactionsMeasureableGasUsed,
	ElrondTransactionsMeasureableValue,
}

func (e ElrondTransactionsMeasureable) IsValid() bool {
	switch e {
	case ElrondTransactionsMeasureableDate, ElrondTransactionsMeasureableTime, ElrondTransactionsMeasureableBlockHash, ElrondTransactionsMeasureableHeight, ElrondTransactionsMeasureablePreviousBlockHash, ElrondTransactionsMeasureableTransactionCount, ElrondTransactionsMeasureableMiniblockHash, ElrondTransactionsMeasureableMiniblockReceiverBlockHash, ElrondTransactionsMeasureableMiniblockReceiverShard, ElrondTransactionsMeasureableType, ElrondTransactionsMeasureableHash, ElrondTransactionsMeasureableTxReceiver, ElrondTransactionsMeasureableTxReceiverShard, ElrondTransactionsMeasureableTxSender, ElrondTransactionsMeasureableTxSenderShard, ElrondTransactionsMeasureableData, ElrondTransactionsMeasureableGasLimit, ElrondTransactionsMeasureableGasPrice, ElrondTransactionsMeasureableGasUsed, ElrondTransactionsMeasureableValue:
		return true
	}
	return false
}

func (e ElrondTransactionsMeasureable) String() string {
	return string(e)
}

func (e *ElrondTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondTransactionsMeasureable", str)
	}
	return nil
}

func (e ElrondTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondTransferUniq string

const (
	// Unique time
	ElrondTransferUniqTimes ElrondTransferUniq = "times"
	// Unique date count
	ElrondTransferUniqDates ElrondTransferUniq = "dates"
	// Unique Number of block in the blockchains
	ElrondTransferUniqBlockHeight ElrondTransferUniq = "block_height"
	// Unique Transaction Hash
	ElrondTransferUniqSignature ElrondTransferUniq = "signature"
)

var AllElrondTransferUniq = []ElrondTransferUniq{
	ElrondTransferUniqTimes,
	ElrondTransferUniqDates,
	ElrondTransferUniqBlockHeight,
	ElrondTransferUniqSignature,
}

func (e ElrondTransferUniq) IsValid() bool {
	switch e {
	case ElrondTransferUniqTimes, ElrondTransferUniqDates, ElrondTransferUniqBlockHeight, ElrondTransferUniqSignature:
		return true
	}
	return false
}

func (e ElrondTransferUniq) String() string {
	return string(e)
}

func (e *ElrondTransferUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondTransferUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondTransferUniq", str)
	}
	return nil
}

func (e ElrondTransferUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ElrondTransfersMeasureable string

const (
	// Date
	ElrondTransfersMeasureableDate ElrondTransfersMeasureable = "date"
	// Time
	ElrondTransfersMeasureableTime ElrondTransfersMeasureable = "time"
	// Hash of the the block
	ElrondTransfersMeasureableBlockHash ElrondTransfersMeasureable = "block_hash"
	// Number of block in the blockhains
	ElrondTransfersMeasureableHeight ElrondTransfersMeasureable = "height"
	// The block hash of this block`s parent
	ElrondTransfersMeasureablePreviousBlockHash ElrondTransfersMeasureable = "previous_block_hash"
	// The block hash of this block`s parent
	ElrondTransfersMeasureableTransactionCount ElrondTransfersMeasureable = "transaction_count"
	// Hash of the miniblock
	ElrondTransfersMeasureableMiniblockHash ElrondTransfersMeasureable = "miniblock_hash"
	// Hash of the miniblocks receiver block
	ElrondTransfersMeasureableMiniblockReceiverBlockHash ElrondTransfersMeasureable = "miniblock_receiver_block_hash"
	// Miniblock receiver shard
	ElrondTransfersMeasureableMiniblockReceiverShard ElrondTransfersMeasureable = "miniblock_receiver_shard"
	// Type of miniblock
	ElrondTransfersMeasureableType ElrondTransfersMeasureable = "type"
	// Transaction hash
	ElrondTransfersMeasureableTxHash ElrondTransfersMeasureable = "tx_hash"
	// Receiver hash
	ElrondTransfersMeasureableTxReceiver ElrondTransfersMeasureable = "tx_receiver"
	// Shard number of the receiver
	ElrondTransfersMeasureableTxReceiverShard ElrondTransfersMeasureable = "tx_receiver_shard"
	// Sender hash
	ElrondTransfersMeasureableTxSender ElrondTransfersMeasureable = "tx_sender"
	// Shard number of the sender
	ElrondTransfersMeasureableTxSenderShard ElrondTransfersMeasureable = "tx_sender_shard"
	// Data
	ElrondTransfersMeasureableData ElrondTransfersMeasureable = "data"
	// Gas Limit
	ElrondTransfersMeasureableGasLimit ElrondTransfersMeasureable = "gas_limit"
	// Gas Price
	ElrondTransfersMeasureableGasPrice ElrondTransfersMeasureable = "gas_price"
	// Gas Used
	ElrondTransfersMeasureableGasUsed ElrondTransfersMeasureable = "gas_used"
	// Value
	ElrondTransfersMeasureableTxValue ElrondTransfersMeasureable = "tx_value"
	// Transfer Amount
	ElrondTransfersMeasureableAmount ElrondTransfersMeasureable = "amount"
	// Sender
	ElrondTransfersMeasureableSender ElrondTransfersMeasureable = "sender"
	// Receiver
	ElrondTransfersMeasureableReceiver ElrondTransfersMeasureable = "receiver"
)

var AllElrondTransfersMeasureable = []ElrondTransfersMeasureable{
	ElrondTransfersMeasureableDate,
	ElrondTransfersMeasureableTime,
	ElrondTransfersMeasureableBlockHash,
	ElrondTransfersMeasureableHeight,
	ElrondTransfersMeasureablePreviousBlockHash,
	ElrondTransfersMeasureableTransactionCount,
	ElrondTransfersMeasureableMiniblockHash,
	ElrondTransfersMeasureableMiniblockReceiverBlockHash,
	ElrondTransfersMeasureableMiniblockReceiverShard,
	ElrondTransfersMeasureableType,
	ElrondTransfersMeasureableTxHash,
	ElrondTransfersMeasureableTxReceiver,
	ElrondTransfersMeasureableTxReceiverShard,
	ElrondTransfersMeasureableTxSender,
	ElrondTransfersMeasureableTxSenderShard,
	ElrondTransfersMeasureableData,
	ElrondTransfersMeasureableGasLimit,
	ElrondTransfersMeasureableGasPrice,
	ElrondTransfersMeasureableGasUsed,
	ElrondTransfersMeasureableTxValue,
	ElrondTransfersMeasureableAmount,
	ElrondTransfersMeasureableSender,
	ElrondTransfersMeasureableReceiver,
}

func (e ElrondTransfersMeasureable) IsValid() bool {
	switch e {
	case ElrondTransfersMeasureableDate, ElrondTransfersMeasureableTime, ElrondTransfersMeasureableBlockHash, ElrondTransfersMeasureableHeight, ElrondTransfersMeasureablePreviousBlockHash, ElrondTransfersMeasureableTransactionCount, ElrondTransfersMeasureableMiniblockHash, ElrondTransfersMeasureableMiniblockReceiverBlockHash, ElrondTransfersMeasureableMiniblockReceiverShard, ElrondTransfersMeasureableType, ElrondTransfersMeasureableTxHash, ElrondTransfersMeasureableTxReceiver, ElrondTransfersMeasureableTxReceiverShard, ElrondTransfersMeasureableTxSender, ElrondTransfersMeasureableTxSenderShard, ElrondTransfersMeasureableData, ElrondTransfersMeasureableGasLimit, ElrondTransfersMeasureableGasPrice, ElrondTransfersMeasureableGasUsed, ElrondTransfersMeasureableTxValue, ElrondTransfersMeasureableAmount, ElrondTransfersMeasureableSender, ElrondTransfersMeasureableReceiver:
		return true
	}
	return false
}

func (e ElrondTransfersMeasureable) String() string {
	return string(e)
}

func (e *ElrondTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElrondTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElrondTransfersMeasureable", str)
	}
	return nil
}

func (e ElrondTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntityTypeEnum string

const (
	// account
	EntityTypeEnumAccount EntityTypeEnum = "account"
	// contract
	EntityTypeEnumContract EntityTypeEnum = "contract"
	// file
	EntityTypeEnumFile EntityTypeEnum = "file"
	// topic
	EntityTypeEnumTopic EntityTypeEnum = "topic"
	// token
	EntityTypeEnumToken EntityTypeEnum = "token"
	// schedule
	EntityTypeEnumSchedule EntityTypeEnum = "schedule"
)

var AllEntityTypeEnum = []EntityTypeEnum{
	EntityTypeEnumAccount,
	EntityTypeEnumContract,
	EntityTypeEnumFile,
	EntityTypeEnumTopic,
	EntityTypeEnumToken,
	EntityTypeEnumSchedule,
}

func (e EntityTypeEnum) IsValid() bool {
	switch e {
	case EntityTypeEnumAccount, EntityTypeEnumContract, EntityTypeEnumFile, EntityTypeEnumTopic, EntityTypeEnumToken, EntityTypeEnumSchedule:
		return true
	}
	return false
}

func (e EntityTypeEnum) String() string {
	return string(e)
}

func (e *EntityTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeEnum", str)
	}
	return nil
}

func (e EntityTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EosBlocksMeasureable string

const (
	// Date
	EosBlocksMeasureableDate EosBlocksMeasureable = "date"
	// Time
	EosBlocksMeasureableTime EosBlocksMeasureable = "time"
	// Block
	EosBlocksMeasureableBlock EosBlocksMeasureable = "block"
	// Block hash
	EosBlocksMeasureableBlockHash EosBlocksMeasureable = "block_hash"
	// Block Proposer
	EosBlocksMeasureableProposer EosBlocksMeasureable = "proposer"
)

var AllEosBlocksMeasureable = []EosBlocksMeasureable{
	EosBlocksMeasureableDate,
	EosBlocksMeasureableTime,
	EosBlocksMeasureableBlock,
	EosBlocksMeasureableBlockHash,
	EosBlocksMeasureableProposer,
}

func (e EosBlocksMeasureable) IsValid() bool {
	switch e {
	case EosBlocksMeasureableDate, EosBlocksMeasureableTime, EosBlocksMeasureableBlock, EosBlocksMeasureableBlockHash, EosBlocksMeasureableProposer:
		return true
	}
	return false
}

func (e EosBlocksMeasureable) String() string {
	return string(e)
}

func (e *EosBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EosBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EosBlocksMeasureable", str)
	}
	return nil
}

func (e EosBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EosBlocksUniq string

const (
	// Unique proposer count
	EosBlocksUniqProposers EosBlocksUniq = "proposers"
	// Unique date count
	EosBlocksUniqDates EosBlocksUniq = "dates"
)

var AllEosBlocksUniq = []EosBlocksUniq{
	EosBlocksUniqProposers,
	EosBlocksUniqDates,
}

func (e EosBlocksUniq) IsValid() bool {
	switch e {
	case EosBlocksUniqProposers, EosBlocksUniqDates:
		return true
	}
	return false
}

func (e EosBlocksUniq) String() string {
	return string(e)
}

func (e *EosBlocksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EosBlocksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EosBlocksUniq", str)
	}
	return nil
}

func (e EosBlocksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EosCallsMeasureable string

const (
	// Date
	EosCallsMeasureableDate EosCallsMeasureable = "date"
	// Time
	EosCallsMeasureableTime EosCallsMeasureable = "time"
	// Block
	EosCallsMeasureableBlock EosCallsMeasureable = "block"
	// Transaction hash
	EosCallsMeasureableTxHash EosCallsMeasureable = "tx_hash"
	// Sender
	EosCallsMeasureableTxSender EosCallsMeasureable = "tx_sender"
	// Action From
	EosCallsMeasureableTxFrom EosCallsMeasureable = "tx_from"
	// Action To
	EosCallsMeasureableTxTo EosCallsMeasureable = "tx_to"
	// Smart Contract
	EosCallsMeasureableSmartContract EosCallsMeasureable = "smart_contract"
	// Smart Contract Method Name
	EosCallsMeasureableSignatureName EosCallsMeasureable = "signature_name"
	// Smart Contract Method Signature
	EosCallsMeasureableSignature EosCallsMeasureable = "signature"
	// Smart Contract Method Signature Hash
	EosCallsMeasureableSignatureHash EosCallsMeasureable = "signature_hash"
	// Call depth
	EosCallsMeasureableCallDepth EosCallsMeasureable = "call_depth"
)

var AllEosCallsMeasureable = []EosCallsMeasureable{
	EosCallsMeasureableDate,
	EosCallsMeasureableTime,
	EosCallsMeasureableBlock,
	EosCallsMeasureableTxHash,
	EosCallsMeasureableTxSender,
	EosCallsMeasureableTxFrom,
	EosCallsMeasureableTxTo,
	EosCallsMeasureableSmartContract,
	EosCallsMeasureableSignatureName,
	EosCallsMeasureableSignature,
	EosCallsMeasureableSignatureHash,
	EosCallsMeasureableCallDepth,
}

func (e EosCallsMeasureable) IsValid() bool {
	switch e {
	case EosCallsMeasureableDate, EosCallsMeasureableTime, EosCallsMeasureableBlock, EosCallsMeasureableTxHash, EosCallsMeasureableTxSender, EosCallsMeasureableTxFrom, EosCallsMeasureableTxTo, EosCallsMeasureableSmartContract, EosCallsMeasureableSignatureName, EosCallsMeasureableSignature, EosCallsMeasureableSignatureHash, EosCallsMeasureableCallDepth:
		return true
	}
	return false
}

func (e EosCallsMeasureable) String() string {
	return string(e)
}

func (e *EosCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EosCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EosCallsMeasureable", str)
	}
	return nil
}

func (e EosCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EosNetwork string

const (
	// EOS mainnet
	EosNetworkEos EosNetwork = "eos"
)

var AllEosNetwork = []EosNetwork{
	EosNetworkEos,
}

func (e EosNetwork) IsValid() bool {
	switch e {
	case EosNetworkEos:
		return true
	}
	return false
}

func (e EosNetwork) String() string {
	return string(e)
}

func (e *EosNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EosNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EosNetwork", str)
	}
	return nil
}

func (e EosNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EosTransactionsMeasureable string

const (
	// Date
	EosTransactionsMeasureableDate EosTransactionsMeasureable = "date"
	// Time
	EosTransactionsMeasureableTime EosTransactionsMeasureable = "time"
	// Block
	EosTransactionsMeasureableBlock EosTransactionsMeasureable = "block"
	// Transaction hash
	EosTransactionsMeasureableTxHash EosTransactionsMeasureable = "tx_hash"
	// CPU Usage
	EosTransactionsMeasureableCPUUsageUs EosTransactionsMeasureable = "cpu_usage_us"
	// Net Usage
	EosTransactionsMeasureableNetUsageWords EosTransactionsMeasureable = "net_usage_words"
)

var AllEosTransactionsMeasureable = []EosTransactionsMeasureable{
	EosTransactionsMeasureableDate,
	EosTransactionsMeasureableTime,
	EosTransactionsMeasureableBlock,
	EosTransactionsMeasureableTxHash,
	EosTransactionsMeasureableCPUUsageUs,
	EosTransactionsMeasureableNetUsageWords,
}

func (e EosTransactionsMeasureable) IsValid() bool {
	switch e {
	case EosTransactionsMeasureableDate, EosTransactionsMeasureableTime, EosTransactionsMeasureableBlock, EosTransactionsMeasureableTxHash, EosTransactionsMeasureableCPUUsageUs, EosTransactionsMeasureableNetUsageWords:
		return true
	}
	return false
}

func (e EosTransactionsMeasureable) String() string {
	return string(e)
}

func (e *EosTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EosTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EosTransactionsMeasureable", str)
	}
	return nil
}

func (e EosTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EosTransactionsUniq string

const (
	// Unique blocks
	EosTransactionsUniqBlocks EosTransactionsUniq = "blocks"
	// Unique date count
	EosTransactionsUniqDates EosTransactionsUniq = "dates"
)

var AllEosTransactionsUniq = []EosTransactionsUniq{
	EosTransactionsUniqBlocks,
	EosTransactionsUniqDates,
}

func (e EosTransactionsUniq) IsValid() bool {
	switch e {
	case EosTransactionsUniqBlocks, EosTransactionsUniqDates:
		return true
	}
	return false
}

func (e EosTransactionsUniq) String() string {
	return string(e)
}

func (e *EosTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EosTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EosTransactionsUniq", str)
	}
	return nil
}

func (e EosTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EosTransfersMeasureable string

const (
	// Date
	EosTransfersMeasureableDate EosTransfersMeasureable = "date"
	// Time
	EosTransfersMeasureableTime EosTransfersMeasureable = "time"
	// Block
	EosTransfersMeasureableBlock EosTransfersMeasureable = "block"
	// Transaction hash
	EosTransfersMeasureableTxHash EosTransfersMeasureable = "tx_hash"
	// Amount
	EosTransfersMeasureableAmount EosTransfersMeasureable = "amount"
	// Sender
	EosTransfersMeasureableSender EosTransfersMeasureable = "sender"
	// Receiver
	EosTransfersMeasureableReceiver EosTransfersMeasureable = "receiver"
	// Currency symbol
	EosTransfersMeasureableCurrencySymbol EosTransfersMeasureable = "currency_symbol"
	// Token address
	EosTransfersMeasureableCurrencyAddress EosTransfersMeasureable = "currency_address"
)

var AllEosTransfersMeasureable = []EosTransfersMeasureable{
	EosTransfersMeasureableDate,
	EosTransfersMeasureableTime,
	EosTransfersMeasureableBlock,
	EosTransfersMeasureableTxHash,
	EosTransfersMeasureableAmount,
	EosTransfersMeasureableSender,
	EosTransfersMeasureableReceiver,
	EosTransfersMeasureableCurrencySymbol,
	EosTransfersMeasureableCurrencyAddress,
}

func (e EosTransfersMeasureable) IsValid() bool {
	switch e {
	case EosTransfersMeasureableDate, EosTransfersMeasureableTime, EosTransfersMeasureableBlock, EosTransfersMeasureableTxHash, EosTransfersMeasureableAmount, EosTransfersMeasureableSender, EosTransfersMeasureableReceiver, EosTransfersMeasureableCurrencySymbol, EosTransfersMeasureableCurrencyAddress:
		return true
	}
	return false
}

func (e EosTransfersMeasureable) String() string {
	return string(e)
}

func (e *EosTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EosTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EosTransfersMeasureable", str)
	}
	return nil
}

func (e EosTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2AttestationsMeasureable string

const (
	// Date
	Ethereum2AttestationsMeasureableDate Ethereum2AttestationsMeasureable = "date"
	// Time
	Ethereum2AttestationsMeasureableTime Ethereum2AttestationsMeasureable = "time"
	// Block
	Ethereum2AttestationsMeasureableBlock Ethereum2AttestationsMeasureable = "block"
	// Block hash
	Ethereum2AttestationsMeasureableBlockRootHash Ethereum2AttestationsMeasureable = "block_root_hash"
	// Block Proposer
	Ethereum2AttestationsMeasureableBlockProposer Ethereum2AttestationsMeasureable = "block_proposer"
	// Committee Index
	Ethereum2AttestationsMeasureableCommittee Ethereum2AttestationsMeasureable = "committee"
	// Validator index
	Ethereum2AttestationsMeasureableValidator Ethereum2AttestationsMeasureable = "validator"
)

var AllEthereum2AttestationsMeasureable = []Ethereum2AttestationsMeasureable{
	Ethereum2AttestationsMeasureableDate,
	Ethereum2AttestationsMeasureableTime,
	Ethereum2AttestationsMeasureableBlock,
	Ethereum2AttestationsMeasureableBlockRootHash,
	Ethereum2AttestationsMeasureableBlockProposer,
	Ethereum2AttestationsMeasureableCommittee,
	Ethereum2AttestationsMeasureableValidator,
}

func (e Ethereum2AttestationsMeasureable) IsValid() bool {
	switch e {
	case Ethereum2AttestationsMeasureableDate, Ethereum2AttestationsMeasureableTime, Ethereum2AttestationsMeasureableBlock, Ethereum2AttestationsMeasureableBlockRootHash, Ethereum2AttestationsMeasureableBlockProposer, Ethereum2AttestationsMeasureableCommittee, Ethereum2AttestationsMeasureableValidator:
		return true
	}
	return false
}

func (e Ethereum2AttestationsMeasureable) String() string {
	return string(e)
}

func (e *Ethereum2AttestationsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2AttestationsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2AttestationsMeasureable", str)
	}
	return nil
}

func (e Ethereum2AttestationsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2AttestationsUniq string

const (
	// Unique blocks
	Ethereum2AttestationsUniqBlocks Ethereum2AttestationsUniq = "blocks"
	// Unique block proposers
	Ethereum2AttestationsUniqBlockProposers Ethereum2AttestationsUniq = "block_proposers"
	// Unique date count
	Ethereum2AttestationsUniqDates Ethereum2AttestationsUniq = "dates"
	// Unique commitees
	Ethereum2AttestationsUniqCommittees Ethereum2AttestationsUniq = "committees"
	// Unique validators
	Ethereum2AttestationsUniqValidators Ethereum2AttestationsUniq = "validators"
	// Unique attestations
	Ethereum2AttestationsUniqAttestations Ethereum2AttestationsUniq = "attestations"
	// Unique attestation slots
	Ethereum2AttestationsUniqAttestationSlots Ethereum2AttestationsUniq = "attestation_slots"
	// Unique attestation epochs
	Ethereum2AttestationsUniqAttestationEpochs Ethereum2AttestationsUniq = "attestation_epochs"
)

var AllEthereum2AttestationsUniq = []Ethereum2AttestationsUniq{
	Ethereum2AttestationsUniqBlocks,
	Ethereum2AttestationsUniqBlockProposers,
	Ethereum2AttestationsUniqDates,
	Ethereum2AttestationsUniqCommittees,
	Ethereum2AttestationsUniqValidators,
	Ethereum2AttestationsUniqAttestations,
	Ethereum2AttestationsUniqAttestationSlots,
	Ethereum2AttestationsUniqAttestationEpochs,
}

func (e Ethereum2AttestationsUniq) IsValid() bool {
	switch e {
	case Ethereum2AttestationsUniqBlocks, Ethereum2AttestationsUniqBlockProposers, Ethereum2AttestationsUniqDates, Ethereum2AttestationsUniqCommittees, Ethereum2AttestationsUniqValidators, Ethereum2AttestationsUniqAttestations, Ethereum2AttestationsUniqAttestationSlots, Ethereum2AttestationsUniqAttestationEpochs:
		return true
	}
	return false
}

func (e Ethereum2AttestationsUniq) String() string {
	return string(e)
}

func (e *Ethereum2AttestationsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2AttestationsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2AttestationsUniq", str)
	}
	return nil
}

func (e Ethereum2AttestationsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2AttesterSlashingMeasureable string

const (
	// Date
	Ethereum2AttesterSlashingMeasureableDate Ethereum2AttesterSlashingMeasureable = "date"
	// Time
	Ethereum2AttesterSlashingMeasureableTime Ethereum2AttesterSlashingMeasureable = "time"
	// Block
	Ethereum2AttesterSlashingMeasureableBlock Ethereum2AttesterSlashingMeasureable = "block"
	// Block hash
	Ethereum2AttesterSlashingMeasureableBlockRootHash Ethereum2AttesterSlashingMeasureable = "block_root_hash"
	// Block Proposer
	Ethereum2AttesterSlashingMeasureableBlockProposer Ethereum2AttesterSlashingMeasureable = "block_proposer"
	// Validator index
	Ethereum2AttesterSlashingMeasureableValidator Ethereum2AttesterSlashingMeasureable = "validator"
)

var AllEthereum2AttesterSlashingMeasureable = []Ethereum2AttesterSlashingMeasureable{
	Ethereum2AttesterSlashingMeasureableDate,
	Ethereum2AttesterSlashingMeasureableTime,
	Ethereum2AttesterSlashingMeasureableBlock,
	Ethereum2AttesterSlashingMeasureableBlockRootHash,
	Ethereum2AttesterSlashingMeasureableBlockProposer,
	Ethereum2AttesterSlashingMeasureableValidator,
}

func (e Ethereum2AttesterSlashingMeasureable) IsValid() bool {
	switch e {
	case Ethereum2AttesterSlashingMeasureableDate, Ethereum2AttesterSlashingMeasureableTime, Ethereum2AttesterSlashingMeasureableBlock, Ethereum2AttesterSlashingMeasureableBlockRootHash, Ethereum2AttesterSlashingMeasureableBlockProposer, Ethereum2AttesterSlashingMeasureableValidator:
		return true
	}
	return false
}

func (e Ethereum2AttesterSlashingMeasureable) String() string {
	return string(e)
}

func (e *Ethereum2AttesterSlashingMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2AttesterSlashingMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2AttesterSlashingMeasureable", str)
	}
	return nil
}

func (e Ethereum2AttesterSlashingMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2AttesterSlashingsUniq string

const (
	// Unique blocks
	Ethereum2AttesterSlashingsUniqBlocks Ethereum2AttesterSlashingsUniq = "blocks"
	// Unique block proposers
	Ethereum2AttesterSlashingsUniqBlockProposers Ethereum2AttesterSlashingsUniq = "block_proposers"
	// Unique date count
	Ethereum2AttesterSlashingsUniqDates Ethereum2AttesterSlashingsUniq = "dates"
	// Unique validators
	Ethereum2AttesterSlashingsUniqValidators Ethereum2AttesterSlashingsUniq = "validators"
	// Unique slashing slots
	Ethereum2AttesterSlashingsUniqAttestationSlots Ethereum2AttesterSlashingsUniq = "attestation_slots"
	// Unique slashing epochs
	Ethereum2AttesterSlashingsUniqAttestationEpochs Ethereum2AttesterSlashingsUniq = "attestation_epochs"
)

var AllEthereum2AttesterSlashingsUniq = []Ethereum2AttesterSlashingsUniq{
	Ethereum2AttesterSlashingsUniqBlocks,
	Ethereum2AttesterSlashingsUniqBlockProposers,
	Ethereum2AttesterSlashingsUniqDates,
	Ethereum2AttesterSlashingsUniqValidators,
	Ethereum2AttesterSlashingsUniqAttestationSlots,
	Ethereum2AttesterSlashingsUniqAttestationEpochs,
}

func (e Ethereum2AttesterSlashingsUniq) IsValid() bool {
	switch e {
	case Ethereum2AttesterSlashingsUniqBlocks, Ethereum2AttesterSlashingsUniqBlockProposers, Ethereum2AttesterSlashingsUniqDates, Ethereum2AttesterSlashingsUniqValidators, Ethereum2AttesterSlashingsUniqAttestationSlots, Ethereum2AttesterSlashingsUniqAttestationEpochs:
		return true
	}
	return false
}

func (e Ethereum2AttesterSlashingsUniq) String() string {
	return string(e)
}

func (e *Ethereum2AttesterSlashingsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2AttesterSlashingsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2AttesterSlashingsUniq", str)
	}
	return nil
}

func (e Ethereum2AttesterSlashingsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2BlocksMeasureable string

const (
	// Date
	Ethereum2BlocksMeasureableDate Ethereum2BlocksMeasureable = "date"
	// Time
	Ethereum2BlocksMeasureableTime Ethereum2BlocksMeasureable = "time"
	// Block
	Ethereum2BlocksMeasureableBlock Ethereum2BlocksMeasureable = "block"
	// Block hash
	Ethereum2BlocksMeasureableBlockRootHash Ethereum2BlocksMeasureable = "block_root_hash"
	// Block Miner
	Ethereum2BlocksMeasureableBlockProposer Ethereum2BlocksMeasureable = "block_proposer"
)

var AllEthereum2BlocksMeasureable = []Ethereum2BlocksMeasureable{
	Ethereum2BlocksMeasureableDate,
	Ethereum2BlocksMeasureableTime,
	Ethereum2BlocksMeasureableBlock,
	Ethereum2BlocksMeasureableBlockRootHash,
	Ethereum2BlocksMeasureableBlockProposer,
}

func (e Ethereum2BlocksMeasureable) IsValid() bool {
	switch e {
	case Ethereum2BlocksMeasureableDate, Ethereum2BlocksMeasureableTime, Ethereum2BlocksMeasureableBlock, Ethereum2BlocksMeasureableBlockRootHash, Ethereum2BlocksMeasureableBlockProposer:
		return true
	}
	return false
}

func (e Ethereum2BlocksMeasureable) String() string {
	return string(e)
}

func (e *Ethereum2BlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2BlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2BlocksMeasureable", str)
	}
	return nil
}

func (e Ethereum2BlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2BlocksUniq string

const (
	// Unique proposers
	Ethereum2BlocksUniqBlockProposers Ethereum2BlocksUniq = "block_proposers"
	// Unique date count
	Ethereum2BlocksUniqDates Ethereum2BlocksUniq = "dates"
)

var AllEthereum2BlocksUniq = []Ethereum2BlocksUniq{
	Ethereum2BlocksUniqBlockProposers,
	Ethereum2BlocksUniqDates,
}

func (e Ethereum2BlocksUniq) IsValid() bool {
	switch e {
	case Ethereum2BlocksUniqBlockProposers, Ethereum2BlocksUniqDates:
		return true
	}
	return false
}

func (e Ethereum2BlocksUniq) String() string {
	return string(e)
}

func (e *Ethereum2BlocksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2BlocksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2BlocksUniq", str)
	}
	return nil
}

func (e Ethereum2BlocksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2DepositsMeasureable string

const (
	// Date
	Ethereum2DepositsMeasureableDate Ethereum2DepositsMeasureable = "date"
	// Time
	Ethereum2DepositsMeasureableTime Ethereum2DepositsMeasureable = "time"
	// Block
	Ethereum2DepositsMeasureableBlock Ethereum2DepositsMeasureable = "block"
	// Block hash
	Ethereum2DepositsMeasureableBlockRootHash Ethereum2DepositsMeasureable = "block_root_hash"
	// Block Proposer
	Ethereum2DepositsMeasureableBlockProposer Ethereum2DepositsMeasureable = "block_proposer"
	// Validator index
	Ethereum2DepositsMeasureableValidator Ethereum2DepositsMeasureable = "validator"
)

var AllEthereum2DepositsMeasureable = []Ethereum2DepositsMeasureable{
	Ethereum2DepositsMeasureableDate,
	Ethereum2DepositsMeasureableTime,
	Ethereum2DepositsMeasureableBlock,
	Ethereum2DepositsMeasureableBlockRootHash,
	Ethereum2DepositsMeasureableBlockProposer,
	Ethereum2DepositsMeasureableValidator,
}

func (e Ethereum2DepositsMeasureable) IsValid() bool {
	switch e {
	case Ethereum2DepositsMeasureableDate, Ethereum2DepositsMeasureableTime, Ethereum2DepositsMeasureableBlock, Ethereum2DepositsMeasureableBlockRootHash, Ethereum2DepositsMeasureableBlockProposer, Ethereum2DepositsMeasureableValidator:
		return true
	}
	return false
}

func (e Ethereum2DepositsMeasureable) String() string {
	return string(e)
}

func (e *Ethereum2DepositsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2DepositsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2DepositsMeasureable", str)
	}
	return nil
}

func (e Ethereum2DepositsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2DepositsUniq string

const (
	// Unique blocks
	Ethereum2DepositsUniqBlocks Ethereum2DepositsUniq = "blocks"
	// Unique block proposers
	Ethereum2DepositsUniqBlockProposers Ethereum2DepositsUniq = "block_proposers"
	// Unique date count
	Ethereum2DepositsUniqDates Ethereum2DepositsUniq = "dates"
	// Unique validators
	Ethereum2DepositsUniqValidators Ethereum2DepositsUniq = "validators"
)

var AllEthereum2DepositsUniq = []Ethereum2DepositsUniq{
	Ethereum2DepositsUniqBlocks,
	Ethereum2DepositsUniqBlockProposers,
	Ethereum2DepositsUniqDates,
	Ethereum2DepositsUniqValidators,
}

func (e Ethereum2DepositsUniq) IsValid() bool {
	switch e {
	case Ethereum2DepositsUniqBlocks, Ethereum2DepositsUniqBlockProposers, Ethereum2DepositsUniqDates, Ethereum2DepositsUniqValidators:
		return true
	}
	return false
}

func (e Ethereum2DepositsUniq) String() string {
	return string(e)
}

func (e *Ethereum2DepositsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2DepositsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2DepositsUniq", str)
	}
	return nil
}

func (e Ethereum2DepositsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2Network string

const (
	// Beacon Chain Ethereum 2.0
	Ethereum2NetworkEth2 Ethereum2Network = "eth2"
	// Medalla Ethereum 2.0 Beacon Testnet
	Ethereum2NetworkMedalla Ethereum2Network = "medalla"
)

var AllEthereum2Network = []Ethereum2Network{
	Ethereum2NetworkEth2,
	Ethereum2NetworkMedalla,
}

func (e Ethereum2Network) IsValid() bool {
	switch e {
	case Ethereum2NetworkEth2, Ethereum2NetworkMedalla:
		return true
	}
	return false
}

func (e Ethereum2Network) String() string {
	return string(e)
}

func (e *Ethereum2Network) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2Network(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2Network", str)
	}
	return nil
}

func (e Ethereum2Network) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2ProposerSlashingMeasureable string

const (
	// Date
	Ethereum2ProposerSlashingMeasureableDate Ethereum2ProposerSlashingMeasureable = "date"
	// Time
	Ethereum2ProposerSlashingMeasureableTime Ethereum2ProposerSlashingMeasureable = "time"
	// Block
	Ethereum2ProposerSlashingMeasureableBlock Ethereum2ProposerSlashingMeasureable = "block"
	// Block hash
	Ethereum2ProposerSlashingMeasureableBlockRootHash Ethereum2ProposerSlashingMeasureable = "block_root_hash"
	// Block Proposer
	Ethereum2ProposerSlashingMeasureableBlockProposer Ethereum2ProposerSlashingMeasureable = "block_proposer"
	// Slashed Proposer
	Ethereum2ProposerSlashingMeasureableProposer Ethereum2ProposerSlashingMeasureable = "proposer"
)

var AllEthereum2ProposerSlashingMeasureable = []Ethereum2ProposerSlashingMeasureable{
	Ethereum2ProposerSlashingMeasureableDate,
	Ethereum2ProposerSlashingMeasureableTime,
	Ethereum2ProposerSlashingMeasureableBlock,
	Ethereum2ProposerSlashingMeasureableBlockRootHash,
	Ethereum2ProposerSlashingMeasureableBlockProposer,
	Ethereum2ProposerSlashingMeasureableProposer,
}

func (e Ethereum2ProposerSlashingMeasureable) IsValid() bool {
	switch e {
	case Ethereum2ProposerSlashingMeasureableDate, Ethereum2ProposerSlashingMeasureableTime, Ethereum2ProposerSlashingMeasureableBlock, Ethereum2ProposerSlashingMeasureableBlockRootHash, Ethereum2ProposerSlashingMeasureableBlockProposer, Ethereum2ProposerSlashingMeasureableProposer:
		return true
	}
	return false
}

func (e Ethereum2ProposerSlashingMeasureable) String() string {
	return string(e)
}

func (e *Ethereum2ProposerSlashingMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2ProposerSlashingMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2ProposerSlashingMeasureable", str)
	}
	return nil
}

func (e Ethereum2ProposerSlashingMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2ProposerSlashingsUniq string

const (
	// Unique blocks
	Ethereum2ProposerSlashingsUniqBlocks Ethereum2ProposerSlashingsUniq = "blocks"
	// Unique block proposers
	Ethereum2ProposerSlashingsUniqBlockProposers Ethereum2ProposerSlashingsUniq = "block_proposers"
	// Unique date count
	Ethereum2ProposerSlashingsUniqDates Ethereum2ProposerSlashingsUniq = "dates"
	// Unique slashing slots
	Ethereum2ProposerSlashingsUniqSlashingSlots Ethereum2ProposerSlashingsUniq = "slashing_slots"
	// Unique slashing epochs
	Ethereum2ProposerSlashingsUniqSlashingEpochs Ethereum2ProposerSlashingsUniq = "slashing_epochs"
	// Unique slashing proposers
	Ethereum2ProposerSlashingsUniqSlashingProposers Ethereum2ProposerSlashingsUniq = "slashing_proposers"
)

var AllEthereum2ProposerSlashingsUniq = []Ethereum2ProposerSlashingsUniq{
	Ethereum2ProposerSlashingsUniqBlocks,
	Ethereum2ProposerSlashingsUniqBlockProposers,
	Ethereum2ProposerSlashingsUniqDates,
	Ethereum2ProposerSlashingsUniqSlashingSlots,
	Ethereum2ProposerSlashingsUniqSlashingEpochs,
	Ethereum2ProposerSlashingsUniqSlashingProposers,
}

func (e Ethereum2ProposerSlashingsUniq) IsValid() bool {
	switch e {
	case Ethereum2ProposerSlashingsUniqBlocks, Ethereum2ProposerSlashingsUniqBlockProposers, Ethereum2ProposerSlashingsUniqDates, Ethereum2ProposerSlashingsUniqSlashingSlots, Ethereum2ProposerSlashingsUniqSlashingEpochs, Ethereum2ProposerSlashingsUniqSlashingProposers:
		return true
	}
	return false
}

func (e Ethereum2ProposerSlashingsUniq) String() string {
	return string(e)
}

func (e *Ethereum2ProposerSlashingsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2ProposerSlashingsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2ProposerSlashingsUniq", str)
	}
	return nil
}

func (e Ethereum2ProposerSlashingsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2VoluntaryExitsMeasureable string

const (
	// Date
	Ethereum2VoluntaryExitsMeasureableDate Ethereum2VoluntaryExitsMeasureable = "date"
	// Time
	Ethereum2VoluntaryExitsMeasureableTime Ethereum2VoluntaryExitsMeasureable = "time"
	// Block
	Ethereum2VoluntaryExitsMeasureableBlock Ethereum2VoluntaryExitsMeasureable = "block"
	// Block hash
	Ethereum2VoluntaryExitsMeasureableBlockRootHash Ethereum2VoluntaryExitsMeasureable = "block_root_hash"
	// Block Proposer
	Ethereum2VoluntaryExitsMeasureableBlockProposer Ethereum2VoluntaryExitsMeasureable = "block_proposer"
	// Validator index
	Ethereum2VoluntaryExitsMeasureableValidator Ethereum2VoluntaryExitsMeasureable = "validator"
)

var AllEthereum2VoluntaryExitsMeasureable = []Ethereum2VoluntaryExitsMeasureable{
	Ethereum2VoluntaryExitsMeasureableDate,
	Ethereum2VoluntaryExitsMeasureableTime,
	Ethereum2VoluntaryExitsMeasureableBlock,
	Ethereum2VoluntaryExitsMeasureableBlockRootHash,
	Ethereum2VoluntaryExitsMeasureableBlockProposer,
	Ethereum2VoluntaryExitsMeasureableValidator,
}

func (e Ethereum2VoluntaryExitsMeasureable) IsValid() bool {
	switch e {
	case Ethereum2VoluntaryExitsMeasureableDate, Ethereum2VoluntaryExitsMeasureableTime, Ethereum2VoluntaryExitsMeasureableBlock, Ethereum2VoluntaryExitsMeasureableBlockRootHash, Ethereum2VoluntaryExitsMeasureableBlockProposer, Ethereum2VoluntaryExitsMeasureableValidator:
		return true
	}
	return false
}

func (e Ethereum2VoluntaryExitsMeasureable) String() string {
	return string(e)
}

func (e *Ethereum2VoluntaryExitsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2VoluntaryExitsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2VoluntaryExitsMeasureable", str)
	}
	return nil
}

func (e Ethereum2VoluntaryExitsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Ethereum2VoluntaryExitsUniq string

const (
	// Unique blocks
	Ethereum2VoluntaryExitsUniqBlocks Ethereum2VoluntaryExitsUniq = "blocks"
	// Unique block proposers
	Ethereum2VoluntaryExitsUniqBlockProposers Ethereum2VoluntaryExitsUniq = "block_proposers"
	// Unique date count
	Ethereum2VoluntaryExitsUniqDates Ethereum2VoluntaryExitsUniq = "dates"
	// Unique validators
	Ethereum2VoluntaryExitsUniqValidators Ethereum2VoluntaryExitsUniq = "validators"
)

var AllEthereum2VoluntaryExitsUniq = []Ethereum2VoluntaryExitsUniq{
	Ethereum2VoluntaryExitsUniqBlocks,
	Ethereum2VoluntaryExitsUniqBlockProposers,
	Ethereum2VoluntaryExitsUniqDates,
	Ethereum2VoluntaryExitsUniqValidators,
}

func (e Ethereum2VoluntaryExitsUniq) IsValid() bool {
	switch e {
	case Ethereum2VoluntaryExitsUniqBlocks, Ethereum2VoluntaryExitsUniqBlockProposers, Ethereum2VoluntaryExitsUniqDates, Ethereum2VoluntaryExitsUniqValidators:
		return true
	}
	return false
}

func (e Ethereum2VoluntaryExitsUniq) String() string {
	return string(e)
}

func (e *Ethereum2VoluntaryExitsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Ethereum2VoluntaryExitsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Ethereum2VoluntaryExitsUniq", str)
	}
	return nil
}

func (e Ethereum2VoluntaryExitsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumArgumentsConvertable string

const (
	// Token symbol
	EthereumArgumentsConvertableTokenSymbol EthereumArgumentsConvertable = "token_symbol"
	// Token name
	EthereumArgumentsConvertableTokenName EthereumArgumentsConvertable = "token_name"
)

var AllEthereumArgumentsConvertable = []EthereumArgumentsConvertable{
	EthereumArgumentsConvertableTokenSymbol,
	EthereumArgumentsConvertableTokenName,
}

func (e EthereumArgumentsConvertable) IsValid() bool {
	switch e {
	case EthereumArgumentsConvertableTokenSymbol, EthereumArgumentsConvertableTokenName:
		return true
	}
	return false
}

func (e EthereumArgumentsConvertable) String() string {
	return string(e)
}

func (e *EthereumArgumentsConvertable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumArgumentsConvertable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumArgumentsConvertable", str)
	}
	return nil
}

func (e EthereumArgumentsConvertable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumArgumentsMeasureable string

const (
	// Date
	EthereumArgumentsMeasureableDate EthereumArgumentsMeasureable = "date"
	// Time
	EthereumArgumentsMeasureableTime EthereumArgumentsMeasureable = "time"
	// Block
	EthereumArgumentsMeasureableBlock EthereumArgumentsMeasureable = "block"
	// Transaction hash
	EthereumArgumentsMeasureableTxHash EthereumArgumentsMeasureable = "tx_hash"
	// Caller
	EthereumArgumentsMeasureableCaller EthereumArgumentsMeasureable = "caller"
	// Smart Contract
	EthereumArgumentsMeasureableSmartContract EthereumArgumentsMeasureable = "smart_contract"
	// Smart Contract Method Name
	EthereumArgumentsMeasureableSignatureName EthereumArgumentsMeasureable = "signature_name"
	// Smart Contract Method Signature
	EthereumArgumentsMeasureableSignature EthereumArgumentsMeasureable = "signature"
	// Smart Contract Method Signature
	EthereumArgumentsMeasureableSignatureType EthereumArgumentsMeasureable = "signature_type"
	// Smart Contract Method Signature Hash
	EthereumArgumentsMeasureableSignatureHash EthereumArgumentsMeasureable = "signature_hash"
	// Call depth
	EthereumArgumentsMeasureableCallDepth EthereumArgumentsMeasureable = "call_depth"
	// Argument
	EthereumArgumentsMeasureableArgument EthereumArgumentsMeasureable = "argument"
	// Argument type
	EthereumArgumentsMeasureableArgumentType EthereumArgumentsMeasureable = "argument_type"
	// Argument value
	EthereumArgumentsMeasureableArgumentValue EthereumArgumentsMeasureable = "argument_value"
	// Argument index
	EthereumArgumentsMeasureableArgumentIndex EthereumArgumentsMeasureable = "argument_index"
)

var AllEthereumArgumentsMeasureable = []EthereumArgumentsMeasureable{
	EthereumArgumentsMeasureableDate,
	EthereumArgumentsMeasureableTime,
	EthereumArgumentsMeasureableBlock,
	EthereumArgumentsMeasureableTxHash,
	EthereumArgumentsMeasureableCaller,
	EthereumArgumentsMeasureableSmartContract,
	EthereumArgumentsMeasureableSignatureName,
	EthereumArgumentsMeasureableSignature,
	EthereumArgumentsMeasureableSignatureType,
	EthereumArgumentsMeasureableSignatureHash,
	EthereumArgumentsMeasureableCallDepth,
	EthereumArgumentsMeasureableArgument,
	EthereumArgumentsMeasureableArgumentType,
	EthereumArgumentsMeasureableArgumentValue,
	EthereumArgumentsMeasureableArgumentIndex,
}

func (e EthereumArgumentsMeasureable) IsValid() bool {
	switch e {
	case EthereumArgumentsMeasureableDate, EthereumArgumentsMeasureableTime, EthereumArgumentsMeasureableBlock, EthereumArgumentsMeasureableTxHash, EthereumArgumentsMeasureableCaller, EthereumArgumentsMeasureableSmartContract, EthereumArgumentsMeasureableSignatureName, EthereumArgumentsMeasureableSignature, EthereumArgumentsMeasureableSignatureType, EthereumArgumentsMeasureableSignatureHash, EthereumArgumentsMeasureableCallDepth, EthereumArgumentsMeasureableArgument, EthereumArgumentsMeasureableArgumentType, EthereumArgumentsMeasureableArgumentValue, EthereumArgumentsMeasureableArgumentIndex:
		return true
	}
	return false
}

func (e EthereumArgumentsMeasureable) String() string {
	return string(e)
}

func (e *EthereumArgumentsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumArgumentsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumArgumentsMeasureable", str)
	}
	return nil
}

func (e EthereumArgumentsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumBlocksMeasureable string

const (
	// Date
	EthereumBlocksMeasureableDate EthereumBlocksMeasureable = "date"
	// Time
	EthereumBlocksMeasureableTime EthereumBlocksMeasureable = "time"
	// Block
	EthereumBlocksMeasureableBlock EthereumBlocksMeasureable = "block"
	// Block hash
	EthereumBlocksMeasureableBlockHash EthereumBlocksMeasureable = "block_hash"
	// Block Reward
	EthereumBlocksMeasureableBlockReward EthereumBlocksMeasureable = "block_reward"
	// Block Miner
	EthereumBlocksMeasureableMiner EthereumBlocksMeasureable = "miner"
)

var AllEthereumBlocksMeasureable = []EthereumBlocksMeasureable{
	EthereumBlocksMeasureableDate,
	EthereumBlocksMeasureableTime,
	EthereumBlocksMeasureableBlock,
	EthereumBlocksMeasureableBlockHash,
	EthereumBlocksMeasureableBlockReward,
	EthereumBlocksMeasureableMiner,
}

func (e EthereumBlocksMeasureable) IsValid() bool {
	switch e {
	case EthereumBlocksMeasureableDate, EthereumBlocksMeasureableTime, EthereumBlocksMeasureableBlock, EthereumBlocksMeasureableBlockHash, EthereumBlocksMeasureableBlockReward, EthereumBlocksMeasureableMiner:
		return true
	}
	return false
}

func (e EthereumBlocksMeasureable) String() string {
	return string(e)
}

func (e *EthereumBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumBlocksMeasureable", str)
	}
	return nil
}

func (e EthereumBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumBlocksUniq string

const (
	// Unique miner count
	EthereumBlocksUniqMiners EthereumBlocksUniq = "miners"
	// Unique date count
	EthereumBlocksUniqDates EthereumBlocksUniq = "dates"
)

var AllEthereumBlocksUniq = []EthereumBlocksUniq{
	EthereumBlocksUniqMiners,
	EthereumBlocksUniqDates,
}

func (e EthereumBlocksUniq) IsValid() bool {
	switch e {
	case EthereumBlocksUniqMiners, EthereumBlocksUniqDates:
		return true
	}
	return false
}

func (e EthereumBlocksUniq) String() string {
	return string(e)
}

func (e *EthereumBlocksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumBlocksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumBlocksUniq", str)
	}
	return nil
}

func (e EthereumBlocksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumCallsMeasureable string

const (
	// Date
	EthereumCallsMeasureableDate EthereumCallsMeasureable = "date"
	// Time
	EthereumCallsMeasureableTime EthereumCallsMeasureable = "time"
	// Block
	EthereumCallsMeasureableBlock EthereumCallsMeasureable = "block"
	// Transaction hash
	EthereumCallsMeasureableTxHash EthereumCallsMeasureable = "tx_hash"
	// Caller
	EthereumCallsMeasureableCaller EthereumCallsMeasureable = "caller"
	// Smart Contract
	EthereumCallsMeasureableSmartContract EthereumCallsMeasureable = "smart_contract"
	// Smart Contract Method Name
	EthereumCallsMeasureableSignatureName EthereumCallsMeasureable = "signature_name"
	// Smart Contract Method Signature
	EthereumCallsMeasureableSignature EthereumCallsMeasureable = "signature"
	// Smart Contract Method Signature Hash
	EthereumCallsMeasureableSignatureHash EthereumCallsMeasureable = "signature_hash"
	// Call depth
	EthereumCallsMeasureableCallDepth EthereumCallsMeasureable = "call_depth"
)

var AllEthereumCallsMeasureable = []EthereumCallsMeasureable{
	EthereumCallsMeasureableDate,
	EthereumCallsMeasureableTime,
	EthereumCallsMeasureableBlock,
	EthereumCallsMeasureableTxHash,
	EthereumCallsMeasureableCaller,
	EthereumCallsMeasureableSmartContract,
	EthereumCallsMeasureableSignatureName,
	EthereumCallsMeasureableSignature,
	EthereumCallsMeasureableSignatureHash,
	EthereumCallsMeasureableCallDepth,
}

func (e EthereumCallsMeasureable) IsValid() bool {
	switch e {
	case EthereumCallsMeasureableDate, EthereumCallsMeasureableTime, EthereumCallsMeasureableBlock, EthereumCallsMeasureableTxHash, EthereumCallsMeasureableCaller, EthereumCallsMeasureableSmartContract, EthereumCallsMeasureableSignatureName, EthereumCallsMeasureableSignature, EthereumCallsMeasureableSignatureHash, EthereumCallsMeasureableCallDepth:
		return true
	}
	return false
}

func (e EthereumCallsMeasureable) String() string {
	return string(e)
}

func (e *EthereumCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumCallsMeasureable", str)
	}
	return nil
}

func (e EthereumCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumDexTradesMeasureable string

const (
	// Date
	EthereumDexTradesMeasureableDate EthereumDexTradesMeasureable = "date"
	// Time
	EthereumDexTradesMeasureableTime EthereumDexTradesMeasureable = "time"
	// Block
	EthereumDexTradesMeasureableBlock EthereumDexTradesMeasureable = "block"
	// Transaction hash
	EthereumDexTradesMeasureableTxHash EthereumDexTradesMeasureable = "tx_hash"
	// Buy Amount
	EthereumDexTradesMeasureableBuyAmount EthereumDexTradesMeasureable = "buy_amount"
	// Sell Amount
	EthereumDexTradesMeasureableSellAmount EthereumDexTradesMeasureable = "sell_amount"
	// Price
	EthereumDexTradesMeasureablePrice EthereumDexTradesMeasureable = "price"
	// Quote Price
	EthereumDexTradesMeasureableQuotePrice EthereumDexTradesMeasureable = "quote_price"
	// Maker
	EthereumDexTradesMeasureableMaker EthereumDexTradesMeasureable = "maker"
	// Taker
	EthereumDexTradesMeasureableTaker EthereumDexTradesMeasureable = "taker"
	// Buy Currency symbol
	EthereumDexTradesMeasureableBuyCurrencySymbol EthereumDexTradesMeasureable = "buy_currency_symbol"
	// Buy Token address
	EthereumDexTradesMeasureableBuyCurrencyAddress EthereumDexTradesMeasureable = "buy_currency_address"
	// Sell Currency symbol
	EthereumDexTradesMeasureableSellCurrencySymbol EthereumDexTradesMeasureable = "sell_currency_symbol"
	// Sell Token address
	EthereumDexTradesMeasureableSellCurrencyAddress EthereumDexTradesMeasureable = "sell_currency_address"
)

var AllEthereumDexTradesMeasureable = []EthereumDexTradesMeasureable{
	EthereumDexTradesMeasureableDate,
	EthereumDexTradesMeasureableTime,
	EthereumDexTradesMeasureableBlock,
	EthereumDexTradesMeasureableTxHash,
	EthereumDexTradesMeasureableBuyAmount,
	EthereumDexTradesMeasureableSellAmount,
	EthereumDexTradesMeasureablePrice,
	EthereumDexTradesMeasureableQuotePrice,
	EthereumDexTradesMeasureableMaker,
	EthereumDexTradesMeasureableTaker,
	EthereumDexTradesMeasureableBuyCurrencySymbol,
	EthereumDexTradesMeasureableBuyCurrencyAddress,
	EthereumDexTradesMeasureableSellCurrencySymbol,
	EthereumDexTradesMeasureableSellCurrencyAddress,
}

func (e EthereumDexTradesMeasureable) IsValid() bool {
	switch e {
	case EthereumDexTradesMeasureableDate, EthereumDexTradesMeasureableTime, EthereumDexTradesMeasureableBlock, EthereumDexTradesMeasureableTxHash, EthereumDexTradesMeasureableBuyAmount, EthereumDexTradesMeasureableSellAmount, EthereumDexTradesMeasureablePrice, EthereumDexTradesMeasureableQuotePrice, EthereumDexTradesMeasureableMaker, EthereumDexTradesMeasureableTaker, EthereumDexTradesMeasureableBuyCurrencySymbol, EthereumDexTradesMeasureableBuyCurrencyAddress, EthereumDexTradesMeasureableSellCurrencySymbol, EthereumDexTradesMeasureableSellCurrencyAddress:
		return true
	}
	return false
}

func (e EthereumDexTradesMeasureable) String() string {
	return string(e)
}

func (e *EthereumDexTradesMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumDexTradesMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumDexTradesMeasureable", str)
	}
	return nil
}

func (e EthereumDexTradesMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumDexTradesUniq string

const (
	// Unique TX senders count
	EthereumDexTradesUniqSenders EthereumDexTradesUniq = "senders"
	// Unique makers count
	EthereumDexTradesUniqMakers EthereumDexTradesUniq = "makers"
	// Unique makers count
	EthereumDexTradesUniqTakers EthereumDexTradesUniq = "takers"
	// Unique makers & takers count
	EthereumDexTradesUniqAddress EthereumDexTradesUniq = "address"
	// Buy currencies count
	EthereumDexTradesUniqBuyCurrency EthereumDexTradesUniq = "buy_currency"
	// Sell currencies count
	EthereumDexTradesUniqSellCurrency EthereumDexTradesUniq = "sell_currency"
	// Base currencies count
	EthereumDexTradesUniqBaseCurrency EthereumDexTradesUniq = "base_currency"
	// Quote currencies count
	EthereumDexTradesUniqQuoteCurrency EthereumDexTradesUniq = "quote_currency"
	// Unique blocks
	EthereumDexTradesUniqBlocks EthereumDexTradesUniq = "blocks"
	// Unique transactions count
	EthereumDexTradesUniqTxs EthereumDexTradesUniq = "txs"
	// Unique date count
	EthereumDexTradesUniqDates EthereumDexTradesUniq = "dates"
	// Unique smart contract count
	EthereumDexTradesUniqSmartContracts EthereumDexTradesUniq = "smart_contracts"
	// Unique protocols count
	EthereumDexTradesUniqProtocols EthereumDexTradesUniq = "protocols"
)

var AllEthereumDexTradesUniq = []EthereumDexTradesUniq{
	EthereumDexTradesUniqSenders,
	EthereumDexTradesUniqMakers,
	EthereumDexTradesUniqTakers,
	EthereumDexTradesUniqAddress,
	EthereumDexTradesUniqBuyCurrency,
	EthereumDexTradesUniqSellCurrency,
	EthereumDexTradesUniqBaseCurrency,
	EthereumDexTradesUniqQuoteCurrency,
	EthereumDexTradesUniqBlocks,
	EthereumDexTradesUniqTxs,
	EthereumDexTradesUniqDates,
	EthereumDexTradesUniqSmartContracts,
	EthereumDexTradesUniqProtocols,
}

func (e EthereumDexTradesUniq) IsValid() bool {
	switch e {
	case EthereumDexTradesUniqSenders, EthereumDexTradesUniqMakers, EthereumDexTradesUniqTakers, EthereumDexTradesUniqAddress, EthereumDexTradesUniqBuyCurrency, EthereumDexTradesUniqSellCurrency, EthereumDexTradesUniqBaseCurrency, EthereumDexTradesUniqQuoteCurrency, EthereumDexTradesUniqBlocks, EthereumDexTradesUniqTxs, EthereumDexTradesUniqDates, EthereumDexTradesUniqSmartContracts, EthereumDexTradesUniqProtocols:
		return true
	}
	return false
}

func (e EthereumDexTradesUniq) String() string {
	return string(e)
}

func (e *EthereumDexTradesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumDexTradesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumDexTradesUniq", str)
	}
	return nil
}

func (e EthereumDexTradesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumEventsMeasureable string

const (
	// Date
	EthereumEventsMeasureableDate EthereumEventsMeasureable = "date"
	// Time
	EthereumEventsMeasureableTime EthereumEventsMeasureable = "time"
	// Block
	EthereumEventsMeasureableBlock EthereumEventsMeasureable = "block"
	// Transaction hash
	EthereumEventsMeasureableTxHash EthereumEventsMeasureable = "tx_hash"
	// Smart Contract
	EthereumEventsMeasureableSmartContract EthereumEventsMeasureable = "smart_contract"
	// Smart Contract Event Name
	EthereumEventsMeasureableSignatureName EthereumEventsMeasureable = "signature_name"
	// Smart Contract Event Signature
	EthereumEventsMeasureableSignature EthereumEventsMeasureable = "signature"
	// Smart Contract Event Signature Hash
	EthereumEventsMeasureableSignatureHash EthereumEventsMeasureable = "signature_hash"
)

var AllEthereumEventsMeasureable = []EthereumEventsMeasureable{
	EthereumEventsMeasureableDate,
	EthereumEventsMeasureableTime,
	EthereumEventsMeasureableBlock,
	EthereumEventsMeasureableTxHash,
	EthereumEventsMeasureableSmartContract,
	EthereumEventsMeasureableSignatureName,
	EthereumEventsMeasureableSignature,
	EthereumEventsMeasureableSignatureHash,
}

func (e EthereumEventsMeasureable) IsValid() bool {
	switch e {
	case EthereumEventsMeasureableDate, EthereumEventsMeasureableTime, EthereumEventsMeasureableBlock, EthereumEventsMeasureableTxHash, EthereumEventsMeasureableSmartContract, EthereumEventsMeasureableSignatureName, EthereumEventsMeasureableSignature, EthereumEventsMeasureableSignatureHash:
		return true
	}
	return false
}

func (e EthereumEventsMeasureable) String() string {
	return string(e)
}

func (e *EthereumEventsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumEventsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumEventsMeasureable", str)
	}
	return nil
}

func (e EthereumEventsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumNetwork string

const (
	// Ethereum Mainnet
	EthereumNetworkEthereum EthereumNetwork = "ethereum"
	// Ethereum Classic
	EthereumNetworkEthclassic EthereumNetwork = "ethclassic"
	// Ethereum Classic ( no reorg from block 10904146)
	EthereumNetworkEthclassicReorg EthereumNetwork = "ethclassic_reorg"
	// Celo Alfajores Testnet
	EthereumNetworkCeloAlfajores EthereumNetwork = "celo_alfajores"
	// Celo Baklava Testnet
	EthereumNetworkCeloBaklava EthereumNetwork = "celo_baklava"
	// Celo RC1
	EthereumNetworkCeloRc1 EthereumNetwork = "celo_rc1"
	// Binance Smart Chain Mainnet
	EthereumNetworkBsc EthereumNetwork = "bsc"
	// Binance Smart Chain Testnet
	EthereumNetworkBscTestnet EthereumNetwork = "bsc_testnet"
	// Goerli Ethereum Testnet
	EthereumNetworkGoerli EthereumNetwork = "goerli"
	// Matic (Polygon) Mainnet
	EthereumNetworkMatic EthereumNetwork = "matic"
	// Velas Mainnet
	EthereumNetworkVelas EthereumNetwork = "velas"
	// Velas Testnet
	EthereumNetworkVelasTestnet EthereumNetwork = "velas_testnet"
	// Klaytn Mainnet
	EthereumNetworkKlaytn EthereumNetwork = "klaytn"
)

var AllEthereumNetwork = []EthereumNetwork{
	EthereumNetworkEthereum,
	EthereumNetworkEthclassic,
	EthereumNetworkEthclassicReorg,
	EthereumNetworkCeloAlfajores,
	EthereumNetworkCeloBaklava,
	EthereumNetworkCeloRc1,
	EthereumNetworkBsc,
	EthereumNetworkBscTestnet,
	EthereumNetworkGoerli,
	EthereumNetworkMatic,
	EthereumNetworkVelas,
	EthereumNetworkVelasTestnet,
	EthereumNetworkKlaytn,
}

func (e EthereumNetwork) IsValid() bool {
	switch e {
	case EthereumNetworkEthereum, EthereumNetworkEthclassic, EthereumNetworkEthclassicReorg, EthereumNetworkCeloAlfajores, EthereumNetworkCeloBaklava, EthereumNetworkCeloRc1, EthereumNetworkBsc, EthereumNetworkBscTestnet, EthereumNetworkGoerli, EthereumNetworkMatic, EthereumNetworkVelas, EthereumNetworkVelasTestnet, EthereumNetworkKlaytn:
		return true
	}
	return false
}

func (e EthereumNetwork) String() string {
	return string(e)
}

func (e *EthereumNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumNetwork", str)
	}
	return nil
}

func (e EthereumNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumTransactionsMeasureable string

const (
	// Date
	EthereumTransactionsMeasureableDate EthereumTransactionsMeasureable = "date"
	// Time
	EthereumTransactionsMeasureableTime EthereumTransactionsMeasureable = "time"
	// Block
	EthereumTransactionsMeasureableBlock EthereumTransactionsMeasureable = "block"
	// Transaction hash
	EthereumTransactionsMeasureableTxHash EthereumTransactionsMeasureable = "tx_hash"
	// Amount
	EthereumTransactionsMeasureableAmount EthereumTransactionsMeasureable = "amount"
	// Transaction Sender
	EthereumTransactionsMeasureableTxSender EthereumTransactionsMeasureable = "tx_sender"
	// Gas value
	EthereumTransactionsMeasureableGasValue EthereumTransactionsMeasureable = "gas_value"
	// Gas price
	EthereumTransactionsMeasureableGasPrice EthereumTransactionsMeasureable = "gas_price"
	// Gas used
	EthereumTransactionsMeasureableGas EthereumTransactionsMeasureable = "gas"
)

var AllEthereumTransactionsMeasureable = []EthereumTransactionsMeasureable{
	EthereumTransactionsMeasureableDate,
	EthereumTransactionsMeasureableTime,
	EthereumTransactionsMeasureableBlock,
	EthereumTransactionsMeasureableTxHash,
	EthereumTransactionsMeasureableAmount,
	EthereumTransactionsMeasureableTxSender,
	EthereumTransactionsMeasureableGasValue,
	EthereumTransactionsMeasureableGasPrice,
	EthereumTransactionsMeasureableGas,
}

func (e EthereumTransactionsMeasureable) IsValid() bool {
	switch e {
	case EthereumTransactionsMeasureableDate, EthereumTransactionsMeasureableTime, EthereumTransactionsMeasureableBlock, EthereumTransactionsMeasureableTxHash, EthereumTransactionsMeasureableAmount, EthereumTransactionsMeasureableTxSender, EthereumTransactionsMeasureableGasValue, EthereumTransactionsMeasureableGasPrice, EthereumTransactionsMeasureableGas:
		return true
	}
	return false
}

func (e EthereumTransactionsMeasureable) String() string {
	return string(e)
}

func (e *EthereumTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumTransactionsMeasureable", str)
	}
	return nil
}

func (e EthereumTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumTransactionsUniq string

const (
	// Unique TX senders count
	EthereumTransactionsUniqSenders EthereumTransactionsUniq = "senders"
	// Unique TX receivers count
	EthereumTransactionsUniqReceivers EthereumTransactionsUniq = "receivers"
	// Unique blocks
	EthereumTransactionsUniqBlocks EthereumTransactionsUniq = "blocks"
	// Unique date count
	EthereumTransactionsUniqDates EthereumTransactionsUniq = "dates"
)

var AllEthereumTransactionsUniq = []EthereumTransactionsUniq{
	EthereumTransactionsUniqSenders,
	EthereumTransactionsUniqReceivers,
	EthereumTransactionsUniqBlocks,
	EthereumTransactionsUniqDates,
}

func (e EthereumTransactionsUniq) IsValid() bool {
	switch e {
	case EthereumTransactionsUniqSenders, EthereumTransactionsUniqReceivers, EthereumTransactionsUniqBlocks, EthereumTransactionsUniqDates:
		return true
	}
	return false
}

func (e EthereumTransactionsUniq) String() string {
	return string(e)
}

func (e *EthereumTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumTransactionsUniq", str)
	}
	return nil
}

func (e EthereumTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthereumTransfersMeasureable string

const (
	// Date
	EthereumTransfersMeasureableDate EthereumTransfersMeasureable = "date"
	// Time
	EthereumTransfersMeasureableTime EthereumTransfersMeasureable = "time"
	// Block
	EthereumTransfersMeasureableBlock EthereumTransfersMeasureable = "block"
	// Transaction hash
	EthereumTransfersMeasureableTxHash EthereumTransfersMeasureable = "tx_hash"
	// Amount
	EthereumTransfersMeasureableAmount EthereumTransfersMeasureable = "amount"
	// Sender
	EthereumTransfersMeasureableSender EthereumTransfersMeasureable = "sender"
	// Receiver
	EthereumTransfersMeasureableReceiver EthereumTransfersMeasureable = "receiver"
	// Currency symbol
	EthereumTransfersMeasureableCurrencySymbol EthereumTransfersMeasureable = "currency_symbol"
	// Token address
	EthereumTransfersMeasureableCurrencyAddress EthereumTransfersMeasureable = "currency_address"
	// Entity ID
	EthereumTransfersMeasureableEntityID EthereumTransfersMeasureable = "entity_id"
)

var AllEthereumTransfersMeasureable = []EthereumTransfersMeasureable{
	EthereumTransfersMeasureableDate,
	EthereumTransfersMeasureableTime,
	EthereumTransfersMeasureableBlock,
	EthereumTransfersMeasureableTxHash,
	EthereumTransfersMeasureableAmount,
	EthereumTransfersMeasureableSender,
	EthereumTransfersMeasureableReceiver,
	EthereumTransfersMeasureableCurrencySymbol,
	EthereumTransfersMeasureableCurrencyAddress,
	EthereumTransfersMeasureableEntityID,
}

func (e EthereumTransfersMeasureable) IsValid() bool {
	switch e {
	case EthereumTransfersMeasureableDate, EthereumTransfersMeasureableTime, EthereumTransfersMeasureableBlock, EthereumTransfersMeasureableTxHash, EthereumTransfersMeasureableAmount, EthereumTransfersMeasureableSender, EthereumTransfersMeasureableReceiver, EthereumTransfersMeasureableCurrencySymbol, EthereumTransfersMeasureableCurrencyAddress, EthereumTransfersMeasureableEntityID:
		return true
	}
	return false
}

func (e EthereumTransfersMeasureable) String() string {
	return string(e)
}

func (e *EthereumTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthereumTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthereumTransfersMeasureable", str)
	}
	return nil
}

func (e EthereumTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinBlockUniq string

const (
	// Miner
	FilecoinBlockUniqMiners FilecoinBlockUniq = "miners"
	// Unique date count
	FilecoinBlockUniqDates FilecoinBlockUniq = "dates"
	// Unique block height count
	FilecoinBlockUniqHeights FilecoinBlockUniq = "heights"
	// Unique block count
	FilecoinBlockUniqBlocks FilecoinBlockUniq = "blocks"
)

var AllFilecoinBlockUniq = []FilecoinBlockUniq{
	FilecoinBlockUniqMiners,
	FilecoinBlockUniqDates,
	FilecoinBlockUniqHeights,
	FilecoinBlockUniqBlocks,
}

func (e FilecoinBlockUniq) IsValid() bool {
	switch e {
	case FilecoinBlockUniqMiners, FilecoinBlockUniqDates, FilecoinBlockUniqHeights, FilecoinBlockUniqBlocks:
		return true
	}
	return false
}

func (e FilecoinBlockUniq) String() string {
	return string(e)
}

func (e *FilecoinBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinBlockUniq", str)
	}
	return nil
}

func (e FilecoinBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinBlocksMeasureable string

const (
	// Date
	FilecoinBlocksMeasureableDate FilecoinBlocksMeasureable = "date"
	// Time
	FilecoinBlocksMeasureableTime FilecoinBlocksMeasureable = "time"
	// Block
	FilecoinBlocksMeasureableBlock FilecoinBlocksMeasureable = "block"
	// Block hash
	FilecoinBlocksMeasureableBlockHash FilecoinBlocksMeasureable = "block_hash"
	// Block Miner
	FilecoinBlocksMeasureableMiner FilecoinBlocksMeasureable = "miner"
)

var AllFilecoinBlocksMeasureable = []FilecoinBlocksMeasureable{
	FilecoinBlocksMeasureableDate,
	FilecoinBlocksMeasureableTime,
	FilecoinBlocksMeasureableBlock,
	FilecoinBlocksMeasureableBlockHash,
	FilecoinBlocksMeasureableMiner,
}

func (e FilecoinBlocksMeasureable) IsValid() bool {
	switch e {
	case FilecoinBlocksMeasureableDate, FilecoinBlocksMeasureableTime, FilecoinBlocksMeasureableBlock, FilecoinBlocksMeasureableBlockHash, FilecoinBlocksMeasureableMiner:
		return true
	}
	return false
}

func (e FilecoinBlocksMeasureable) String() string {
	return string(e)
}

func (e *FilecoinBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinBlocksMeasureable", str)
	}
	return nil
}

func (e FilecoinBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinCallsMeasureable string

const (
	// Date
	FilecoinCallsMeasureableDate FilecoinCallsMeasureable = "date"
	// Time
	FilecoinCallsMeasureableTime FilecoinCallsMeasureable = "time"
	// Block
	FilecoinCallsMeasureableBlock FilecoinCallsMeasureable = "block"
	// Message hash
	FilecoinCallsMeasureableMessageHash FilecoinCallsMeasureable = "message_hash"
	// Amount
	FilecoinCallsMeasureableAmount FilecoinCallsMeasureable = "amount"
	// Gas value
	FilecoinCallsMeasureableGasValue FilecoinCallsMeasureable = "gas_value"
	// Gas limit
	FilecoinCallsMeasureableGasLimit FilecoinCallsMeasureable = "gas_limit"
	// Gas used
	FilecoinCallsMeasureableGas FilecoinCallsMeasureable = "gas"
)

var AllFilecoinCallsMeasureable = []FilecoinCallsMeasureable{
	FilecoinCallsMeasureableDate,
	FilecoinCallsMeasureableTime,
	FilecoinCallsMeasureableBlock,
	FilecoinCallsMeasureableMessageHash,
	FilecoinCallsMeasureableAmount,
	FilecoinCallsMeasureableGasValue,
	FilecoinCallsMeasureableGasLimit,
	FilecoinCallsMeasureableGas,
}

func (e FilecoinCallsMeasureable) IsValid() bool {
	switch e {
	case FilecoinCallsMeasureableDate, FilecoinCallsMeasureableTime, FilecoinCallsMeasureableBlock, FilecoinCallsMeasureableMessageHash, FilecoinCallsMeasureableAmount, FilecoinCallsMeasureableGasValue, FilecoinCallsMeasureableGasLimit, FilecoinCallsMeasureableGas:
		return true
	}
	return false
}

func (e FilecoinCallsMeasureable) String() string {
	return string(e)
}

func (e *FilecoinCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinCallsMeasureable", str)
	}
	return nil
}

func (e FilecoinCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinMessagesMeasureable string

const (
	// Date
	FilecoinMessagesMeasureableDate FilecoinMessagesMeasureable = "date"
	// Time
	FilecoinMessagesMeasureableTime FilecoinMessagesMeasureable = "time"
	// Block
	FilecoinMessagesMeasureableBlock FilecoinMessagesMeasureable = "block"
	// Message hash
	FilecoinMessagesMeasureableMessageHash FilecoinMessagesMeasureable = "message_hash"
	// Amount
	FilecoinMessagesMeasureableAmount FilecoinMessagesMeasureable = "amount"
	// Gas value
	FilecoinMessagesMeasureableGasValue FilecoinMessagesMeasureable = "gas_value"
	// Gas limit
	FilecoinMessagesMeasureableGasLimit FilecoinMessagesMeasureable = "gas_limit"
	// Gas used
	FilecoinMessagesMeasureableGas FilecoinMessagesMeasureable = "gas"
)

var AllFilecoinMessagesMeasureable = []FilecoinMessagesMeasureable{
	FilecoinMessagesMeasureableDate,
	FilecoinMessagesMeasureableTime,
	FilecoinMessagesMeasureableBlock,
	FilecoinMessagesMeasureableMessageHash,
	FilecoinMessagesMeasureableAmount,
	FilecoinMessagesMeasureableGasValue,
	FilecoinMessagesMeasureableGasLimit,
	FilecoinMessagesMeasureableGas,
}

func (e FilecoinMessagesMeasureable) IsValid() bool {
	switch e {
	case FilecoinMessagesMeasureableDate, FilecoinMessagesMeasureableTime, FilecoinMessagesMeasureableBlock, FilecoinMessagesMeasureableMessageHash, FilecoinMessagesMeasureableAmount, FilecoinMessagesMeasureableGasValue, FilecoinMessagesMeasureableGasLimit, FilecoinMessagesMeasureableGas:
		return true
	}
	return false
}

func (e FilecoinMessagesMeasureable) String() string {
	return string(e)
}

func (e *FilecoinMessagesMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinMessagesMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinMessagesMeasureable", str)
	}
	return nil
}

func (e FilecoinMessagesMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinMessagesUniq string

const (
	// Unique block heights
	FilecoinMessagesUniqBlocks FilecoinMessagesUniq = "blocks"
	// Unique date count
	FilecoinMessagesUniqDates FilecoinMessagesUniq = "dates"
	// Unique Message senders
	FilecoinMessagesUniqSenders FilecoinMessagesUniq = "senders"
	// Unique Message receivers
	FilecoinMessagesUniqReceivers FilecoinMessagesUniq = "receivers"
)

var AllFilecoinMessagesUniq = []FilecoinMessagesUniq{
	FilecoinMessagesUniqBlocks,
	FilecoinMessagesUniqDates,
	FilecoinMessagesUniqSenders,
	FilecoinMessagesUniqReceivers,
}

func (e FilecoinMessagesUniq) IsValid() bool {
	switch e {
	case FilecoinMessagesUniqBlocks, FilecoinMessagesUniqDates, FilecoinMessagesUniqSenders, FilecoinMessagesUniqReceivers:
		return true
	}
	return false
}

func (e FilecoinMessagesUniq) String() string {
	return string(e)
}

func (e *FilecoinMessagesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinMessagesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinMessagesUniq", str)
	}
	return nil
}

func (e FilecoinMessagesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinNetwork string

const (
	// Filecoin Mainnet
	FilecoinNetworkFilecoin FilecoinNetwork = "filecoin"
)

var AllFilecoinNetwork = []FilecoinNetwork{
	FilecoinNetworkFilecoin,
}

func (e FilecoinNetwork) IsValid() bool {
	switch e {
	case FilecoinNetworkFilecoin:
		return true
	}
	return false
}

func (e FilecoinNetwork) String() string {
	return string(e)
}

func (e *FilecoinNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinNetwork", str)
	}
	return nil
}

func (e FilecoinNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinTransferType string

const (
	// Send (transfer)
	FilecoinTransferTypeSend FilecoinTransferType = "send"
	// Miner Tip
	FilecoinTransferTypeMiner FilecoinTransferType = "miner"
	// Reward
	FilecoinTransferTypeReward FilecoinTransferType = "reward"
	// Burn
	FilecoinTransferTypeBurn FilecoinTransferType = "burn"
	// Rebalance
	FilecoinTransferTypeRebalance FilecoinTransferType = "rebalance"
	// Genesis
	FilecoinTransferTypeGenesis FilecoinTransferType = "genesis"
)

var AllFilecoinTransferType = []FilecoinTransferType{
	FilecoinTransferTypeSend,
	FilecoinTransferTypeMiner,
	FilecoinTransferTypeReward,
	FilecoinTransferTypeBurn,
	FilecoinTransferTypeRebalance,
	FilecoinTransferTypeGenesis,
}

func (e FilecoinTransferType) IsValid() bool {
	switch e {
	case FilecoinTransferTypeSend, FilecoinTransferTypeMiner, FilecoinTransferTypeReward, FilecoinTransferTypeBurn, FilecoinTransferTypeRebalance, FilecoinTransferTypeGenesis:
		return true
	}
	return false
}

func (e FilecoinTransferType) String() string {
	return string(e)
}

func (e *FilecoinTransferType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinTransferType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinTransferType", str)
	}
	return nil
}

func (e FilecoinTransferType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilecoinTransfersMeasureable string

const (
	// Date
	FilecoinTransfersMeasureableDate FilecoinTransfersMeasureable = "date"
	// Time
	FilecoinTransfersMeasureableTime FilecoinTransfersMeasureable = "time"
	// Block
	FilecoinTransfersMeasureableBlock FilecoinTransfersMeasureable = "block"
	// Block hash
	FilecoinTransfersMeasureableBlockHash FilecoinTransfersMeasureable = "block_hash"
	// Transfer hash
	FilecoinTransfersMeasureableTxHash FilecoinTransfersMeasureable = "tx_hash"
	// Value
	FilecoinTransfersMeasureableValue FilecoinTransfersMeasureable = "value"
	// Gas value
	FilecoinTransfersMeasureableGasValue FilecoinTransfersMeasureable = "gas_value"
	// Gas limit
	FilecoinTransfersMeasureableGasLimit FilecoinTransfersMeasureable = "gas_limit"
	// Gas used
	FilecoinTransfersMeasureableGas FilecoinTransfersMeasureable = "gas"
)

var AllFilecoinTransfersMeasureable = []FilecoinTransfersMeasureable{
	FilecoinTransfersMeasureableDate,
	FilecoinTransfersMeasureableTime,
	FilecoinTransfersMeasureableBlock,
	FilecoinTransfersMeasureableBlockHash,
	FilecoinTransfersMeasureableTxHash,
	FilecoinTransfersMeasureableValue,
	FilecoinTransfersMeasureableGasValue,
	FilecoinTransfersMeasureableGasLimit,
	FilecoinTransfersMeasureableGas,
}

func (e FilecoinTransfersMeasureable) IsValid() bool {
	switch e {
	case FilecoinTransfersMeasureableDate, FilecoinTransfersMeasureableTime, FilecoinTransfersMeasureableBlock, FilecoinTransfersMeasureableBlockHash, FilecoinTransfersMeasureableTxHash, FilecoinTransfersMeasureableValue, FilecoinTransfersMeasureableGasValue, FilecoinTransfersMeasureableGasLimit, FilecoinTransfersMeasureableGas:
		return true
	}
	return false
}

func (e FilecoinTransfersMeasureable) String() string {
	return string(e)
}

func (e *FilecoinTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilecoinTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilecoinTransfersMeasureable", str)
	}
	return nil
}

func (e FilecoinTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FlowDirection string

const (
	// Inbound transfers
	FlowDirectionInbound FlowDirection = "inbound"
	// Outbound transfers
	FlowDirectionOutbound FlowDirection = "outbound"
)

var AllFlowDirection = []FlowDirection{
	FlowDirectionInbound,
	FlowDirectionOutbound,
}

func (e FlowDirection) IsValid() bool {
	switch e {
	case FlowDirectionInbound, FlowDirectionOutbound:
		return true
	}
	return false
}

func (e FlowDirection) String() string {
	return string(e)
}

func (e *FlowDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FlowDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FlowDirection", str)
	}
	return nil
}

func (e FlowDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyArgumentsMeasureable string

const (
	// Date
	HarmonyArgumentsMeasureableDate HarmonyArgumentsMeasureable = "date"
	// Time
	HarmonyArgumentsMeasureableTime HarmonyArgumentsMeasureable = "time"
	// Block hash
	HarmonyArgumentsMeasureableBlockHash HarmonyArgumentsMeasureable = "block_hash"
	// Address of the sender
	HarmonyArgumentsMeasureableSender HarmonyArgumentsMeasureable = "sender"
	// Address of  the receive
	HarmonyArgumentsMeasureableReceiver HarmonyArgumentsMeasureable = "receiver"
	// Address of the smart contract
	HarmonyArgumentsMeasureableSmartContractAddress HarmonyArgumentsMeasureable = "smart_contract_address"
	// Id of the smart contract
	HarmonyArgumentsMeasureableSmartContractID HarmonyArgumentsMeasureable = "smart_contract_id"
	// Signature
	HarmonyArgumentsMeasureableSignature HarmonyArgumentsMeasureable = "signature"
	// Name of the signature
	HarmonyArgumentsMeasureableSignatureName HarmonyArgumentsMeasureable = "signature_name"
	// Hash of the signature
	HarmonyArgumentsMeasureableSignatureHash HarmonyArgumentsMeasureable = "signature_hash"
)

var AllHarmonyArgumentsMeasureable = []HarmonyArgumentsMeasureable{
	HarmonyArgumentsMeasureableDate,
	HarmonyArgumentsMeasureableTime,
	HarmonyArgumentsMeasureableBlockHash,
	HarmonyArgumentsMeasureableSender,
	HarmonyArgumentsMeasureableReceiver,
	HarmonyArgumentsMeasureableSmartContractAddress,
	HarmonyArgumentsMeasureableSmartContractID,
	HarmonyArgumentsMeasureableSignature,
	HarmonyArgumentsMeasureableSignatureName,
	HarmonyArgumentsMeasureableSignatureHash,
}

func (e HarmonyArgumentsMeasureable) IsValid() bool {
	switch e {
	case HarmonyArgumentsMeasureableDate, HarmonyArgumentsMeasureableTime, HarmonyArgumentsMeasureableBlockHash, HarmonyArgumentsMeasureableSender, HarmonyArgumentsMeasureableReceiver, HarmonyArgumentsMeasureableSmartContractAddress, HarmonyArgumentsMeasureableSmartContractID, HarmonyArgumentsMeasureableSignature, HarmonyArgumentsMeasureableSignatureName, HarmonyArgumentsMeasureableSignatureHash:
		return true
	}
	return false
}

func (e HarmonyArgumentsMeasureable) String() string {
	return string(e)
}

func (e *HarmonyArgumentsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyArgumentsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyArgumentsMeasureable", str)
	}
	return nil
}

func (e HarmonyArgumentsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyArgumentsUniq string

const (
	// Unique time
	HarmonyArgumentsUniqTimes HarmonyArgumentsUniq = "times"
	// Unique date count
	HarmonyArgumentsUniqDates HarmonyArgumentsUniq = "dates"
	// Unique ledger count
	HarmonyArgumentsUniqLedger HarmonyArgumentsUniq = "ledger"
	// Unique block hash count
	HarmonyArgumentsUniqBlockHash HarmonyArgumentsUniq = "block_hash"
	// Unique smart contract address
	HarmonyArgumentsUniqSmartContractAddress HarmonyArgumentsUniq = "smart_contract_address"
	// Unique address of the sender
	HarmonyArgumentsUniqSender HarmonyArgumentsUniq = "sender"
	// Unique address of the receiver
	HarmonyArgumentsUniqReceiver HarmonyArgumentsUniq = "receiver"
)

var AllHarmonyArgumentsUniq = []HarmonyArgumentsUniq{
	HarmonyArgumentsUniqTimes,
	HarmonyArgumentsUniqDates,
	HarmonyArgumentsUniqLedger,
	HarmonyArgumentsUniqBlockHash,
	HarmonyArgumentsUniqSmartContractAddress,
	HarmonyArgumentsUniqSender,
	HarmonyArgumentsUniqReceiver,
}

func (e HarmonyArgumentsUniq) IsValid() bool {
	switch e {
	case HarmonyArgumentsUniqTimes, HarmonyArgumentsUniqDates, HarmonyArgumentsUniqLedger, HarmonyArgumentsUniqBlockHash, HarmonyArgumentsUniqSmartContractAddress, HarmonyArgumentsUniqSender, HarmonyArgumentsUniqReceiver:
		return true
	}
	return false
}

func (e HarmonyArgumentsUniq) String() string {
	return string(e)
}

func (e *HarmonyArgumentsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyArgumentsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyArgumentsUniq", str)
	}
	return nil
}

func (e HarmonyArgumentsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyBlocksMeasureable string

const (
	// Date
	HarmonyBlocksMeasureableDate HarmonyBlocksMeasureable = "date"
	// Time
	HarmonyBlocksMeasureableTime HarmonyBlocksMeasureable = "time"
	// Gas limit
	HarmonyBlocksMeasureableGasLimit HarmonyBlocksMeasureable = "gas_limit"
	// Gas Used
	HarmonyBlocksMeasureableGasUsed HarmonyBlocksMeasureable = "gas_used"
	// Block hash
	HarmonyBlocksMeasureableBlockHash HarmonyBlocksMeasureable = "block_hash"
	// Parent hash
	HarmonyBlocksMeasureableParetHash HarmonyBlocksMeasureable = "paret_hash"
)

var AllHarmonyBlocksMeasureable = []HarmonyBlocksMeasureable{
	HarmonyBlocksMeasureableDate,
	HarmonyBlocksMeasureableTime,
	HarmonyBlocksMeasureableGasLimit,
	HarmonyBlocksMeasureableGasUsed,
	HarmonyBlocksMeasureableBlockHash,
	HarmonyBlocksMeasureableParetHash,
}

func (e HarmonyBlocksMeasureable) IsValid() bool {
	switch e {
	case HarmonyBlocksMeasureableDate, HarmonyBlocksMeasureableTime, HarmonyBlocksMeasureableGasLimit, HarmonyBlocksMeasureableGasUsed, HarmonyBlocksMeasureableBlockHash, HarmonyBlocksMeasureableParetHash:
		return true
	}
	return false
}

func (e HarmonyBlocksMeasureable) String() string {
	return string(e)
}

func (e *HarmonyBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyBlocksMeasureable", str)
	}
	return nil
}

func (e HarmonyBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyBlocksUniq string

const (
	// Unique time
	HarmonyBlocksUniqTimes HarmonyBlocksUniq = "times"
	// Unique date count
	HarmonyBlocksUniqDates HarmonyBlocksUniq = "dates"
	// Unique ledger count
	HarmonyBlocksUniqLedger HarmonyBlocksUniq = "ledger"
	// Unique block hash count
	HarmonyBlocksUniqBlockHash HarmonyBlocksUniq = "block_hash"
	// Unique parent hash count
	HarmonyBlocksUniqParentHash HarmonyBlocksUniq = "parent_hash"
	// Unique miner count
	HarmonyBlocksUniqMiner HarmonyBlocksUniq = "miner"
	// Unique mix hash count
	HarmonyBlocksUniqMixHash HarmonyBlocksUniq = "mix_hash"
	// Unique state root count
	HarmonyBlocksUniqStateRoot HarmonyBlocksUniq = "state_root"
	// Unique receipts root count
	HarmonyBlocksUniqReceiptsRoot HarmonyBlocksUniq = "receipts_root"
	// Unique transactions root count
	HarmonyBlocksUniqTransactionsRoot HarmonyBlocksUniq = "transactions_root"
)

var AllHarmonyBlocksUniq = []HarmonyBlocksUniq{
	HarmonyBlocksUniqTimes,
	HarmonyBlocksUniqDates,
	HarmonyBlocksUniqLedger,
	HarmonyBlocksUniqBlockHash,
	HarmonyBlocksUniqParentHash,
	HarmonyBlocksUniqMiner,
	HarmonyBlocksUniqMixHash,
	HarmonyBlocksUniqStateRoot,
	HarmonyBlocksUniqReceiptsRoot,
	HarmonyBlocksUniqTransactionsRoot,
}

func (e HarmonyBlocksUniq) IsValid() bool {
	switch e {
	case HarmonyBlocksUniqTimes, HarmonyBlocksUniqDates, HarmonyBlocksUniqLedger, HarmonyBlocksUniqBlockHash, HarmonyBlocksUniqParentHash, HarmonyBlocksUniqMiner, HarmonyBlocksUniqMixHash, HarmonyBlocksUniqStateRoot, HarmonyBlocksUniqReceiptsRoot, HarmonyBlocksUniqTransactionsRoot:
		return true
	}
	return false
}

func (e HarmonyBlocksUniq) String() string {
	return string(e)
}

func (e *HarmonyBlocksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyBlocksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyBlocksUniq", str)
	}
	return nil
}

func (e HarmonyBlocksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyEventsMeasureable string

const (
	// Date
	HarmonyEventsMeasureableDate HarmonyEventsMeasureable = "date"
	// Time
	HarmonyEventsMeasureableTime HarmonyEventsMeasureable = "time"
	// Block
	HarmonyEventsMeasureableBlock HarmonyEventsMeasureable = "block"
	// Transaction hash
	HarmonyEventsMeasureableTxHash HarmonyEventsMeasureable = "tx_hash"
	// Action From
	HarmonyEventsMeasureableTxFrom HarmonyEventsMeasureable = "tx_from"
	// Action To
	HarmonyEventsMeasureableTxTo HarmonyEventsMeasureable = "tx_to"
	// Smart Contract
	HarmonyEventsMeasureableSmartContract HarmonyEventsMeasureable = "smart_contract"
	// Smart Contract Method Signature
	HarmonyEventsMeasureableSignature HarmonyEventsMeasureable = "signature"
	// Smart Contract Method Name
	HarmonyEventsMeasureableSignatureName HarmonyEventsMeasureable = "signature_name"
	// Smart Contract Method Signature Hash
	HarmonyEventsMeasureableSignatureHash HarmonyEventsMeasureable = "signature_hash"
)

var AllHarmonyEventsMeasureable = []HarmonyEventsMeasureable{
	HarmonyEventsMeasureableDate,
	HarmonyEventsMeasureableTime,
	HarmonyEventsMeasureableBlock,
	HarmonyEventsMeasureableTxHash,
	HarmonyEventsMeasureableTxFrom,
	HarmonyEventsMeasureableTxTo,
	HarmonyEventsMeasureableSmartContract,
	HarmonyEventsMeasureableSignature,
	HarmonyEventsMeasureableSignatureName,
	HarmonyEventsMeasureableSignatureHash,
}

func (e HarmonyEventsMeasureable) IsValid() bool {
	switch e {
	case HarmonyEventsMeasureableDate, HarmonyEventsMeasureableTime, HarmonyEventsMeasureableBlock, HarmonyEventsMeasureableTxHash, HarmonyEventsMeasureableTxFrom, HarmonyEventsMeasureableTxTo, HarmonyEventsMeasureableSmartContract, HarmonyEventsMeasureableSignature, HarmonyEventsMeasureableSignatureName, HarmonyEventsMeasureableSignatureHash:
		return true
	}
	return false
}

func (e HarmonyEventsMeasureable) String() string {
	return string(e)
}

func (e *HarmonyEventsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyEventsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyEventsMeasureable", str)
	}
	return nil
}

func (e HarmonyEventsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyNetwork string

const (
	// Harmony Mainnat
	HarmonyNetworkHarmony HarmonyNetwork = "harmony"
	// Harmony Testnet
	HarmonyNetworkHarmonyTestnet HarmonyNetwork = "harmony_testnet"
)

var AllHarmonyNetwork = []HarmonyNetwork{
	HarmonyNetworkHarmony,
	HarmonyNetworkHarmonyTestnet,
}

func (e HarmonyNetwork) IsValid() bool {
	switch e {
	case HarmonyNetworkHarmony, HarmonyNetworkHarmonyTestnet:
		return true
	}
	return false
}

func (e HarmonyNetwork) String() string {
	return string(e)
}

func (e *HarmonyNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyNetwork", str)
	}
	return nil
}

func (e HarmonyNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonySmartContractCallsMeasureable string

const (
	// Date
	HarmonySmartContractCallsMeasureableDate HarmonySmartContractCallsMeasureable = "date"
	// Time
	HarmonySmartContractCallsMeasureableTime HarmonySmartContractCallsMeasureable = "time"
	// Block
	HarmonySmartContractCallsMeasureableBlock HarmonySmartContractCallsMeasureable = "block"
	// Transaction hash
	HarmonySmartContractCallsMeasureableTxHash HarmonySmartContractCallsMeasureable = "tx_hash"
	// Action From
	HarmonySmartContractCallsMeasureableTxFrom HarmonySmartContractCallsMeasureable = "tx_from"
	// Action To
	HarmonySmartContractCallsMeasureableTxTo HarmonySmartContractCallsMeasureable = "tx_to"
	// Smart Contract
	HarmonySmartContractCallsMeasureableSmartContract HarmonySmartContractCallsMeasureable = "smart_contract"
	// Smart Contract Method Name
	HarmonySmartContractCallsMeasureableSignatureName HarmonySmartContractCallsMeasureable = "signature_name"
	// Smart Contract Method Signature
	HarmonySmartContractCallsMeasureableSignature HarmonySmartContractCallsMeasureable = "signature"
	// Smart Contract Method Signature Hash
	HarmonySmartContractCallsMeasureableSignatureHash HarmonySmartContractCallsMeasureable = "signature_hash"
	// Call depth
	HarmonySmartContractCallsMeasureableCallDepth HarmonySmartContractCallsMeasureable = "call_depth"
)

var AllHarmonySmartContractCallsMeasureable = []HarmonySmartContractCallsMeasureable{
	HarmonySmartContractCallsMeasureableDate,
	HarmonySmartContractCallsMeasureableTime,
	HarmonySmartContractCallsMeasureableBlock,
	HarmonySmartContractCallsMeasureableTxHash,
	HarmonySmartContractCallsMeasureableTxFrom,
	HarmonySmartContractCallsMeasureableTxTo,
	HarmonySmartContractCallsMeasureableSmartContract,
	HarmonySmartContractCallsMeasureableSignatureName,
	HarmonySmartContractCallsMeasureableSignature,
	HarmonySmartContractCallsMeasureableSignatureHash,
	HarmonySmartContractCallsMeasureableCallDepth,
}

func (e HarmonySmartContractCallsMeasureable) IsValid() bool {
	switch e {
	case HarmonySmartContractCallsMeasureableDate, HarmonySmartContractCallsMeasureableTime, HarmonySmartContractCallsMeasureableBlock, HarmonySmartContractCallsMeasureableTxHash, HarmonySmartContractCallsMeasureableTxFrom, HarmonySmartContractCallsMeasureableTxTo, HarmonySmartContractCallsMeasureableSmartContract, HarmonySmartContractCallsMeasureableSignatureName, HarmonySmartContractCallsMeasureableSignature, HarmonySmartContractCallsMeasureableSignatureHash, HarmonySmartContractCallsMeasureableCallDepth:
		return true
	}
	return false
}

func (e HarmonySmartContractCallsMeasureable) String() string {
	return string(e)
}

func (e *HarmonySmartContractCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonySmartContractCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonySmartContractCallsMeasureable", str)
	}
	return nil
}

func (e HarmonySmartContractCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonySmartContractCallsUniq string

const (
	// Unique callers count
	HarmonySmartContractCallsUniqTxTo HarmonySmartContractCallsUniq = "tx_to"
	// Unique transaction senders
	HarmonySmartContractCallsUniqTxFrom HarmonySmartContractCallsUniq = "tx_from"
	// Unique transactions count
	HarmonySmartContractCallsUniqTxs HarmonySmartContractCallsUniq = "txs"
	// Unique smart contracts count
	HarmonySmartContractCallsUniqSmartContracts HarmonySmartContractCallsUniq = "smart_contracts"
	// Unique smart contract methods count
	HarmonySmartContractCallsUniqSmartContractMethods HarmonySmartContractCallsUniq = "smart_contract_methods"
	// Unique blocks
	HarmonySmartContractCallsUniqBlocks HarmonySmartContractCallsUniq = "blocks"
	// Unique date count
	HarmonySmartContractCallsUniqDates HarmonySmartContractCallsUniq = "dates"
)

var AllHarmonySmartContractCallsUniq = []HarmonySmartContractCallsUniq{
	HarmonySmartContractCallsUniqTxTo,
	HarmonySmartContractCallsUniqTxFrom,
	HarmonySmartContractCallsUniqTxs,
	HarmonySmartContractCallsUniqSmartContracts,
	HarmonySmartContractCallsUniqSmartContractMethods,
	HarmonySmartContractCallsUniqBlocks,
	HarmonySmartContractCallsUniqDates,
}

func (e HarmonySmartContractCallsUniq) IsValid() bool {
	switch e {
	case HarmonySmartContractCallsUniqTxTo, HarmonySmartContractCallsUniqTxFrom, HarmonySmartContractCallsUniqTxs, HarmonySmartContractCallsUniqSmartContracts, HarmonySmartContractCallsUniqSmartContractMethods, HarmonySmartContractCallsUniqBlocks, HarmonySmartContractCallsUniqDates:
		return true
	}
	return false
}

func (e HarmonySmartContractCallsUniq) String() string {
	return string(e)
}

func (e *HarmonySmartContractCallsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonySmartContractCallsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonySmartContractCallsUniq", str)
	}
	return nil
}

func (e HarmonySmartContractCallsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyStakingTransactionsMeasureable string

const (
	// Date
	HarmonyStakingTransactionsMeasureableDate HarmonyStakingTransactionsMeasureable = "date"
	// Time
	HarmonyStakingTransactionsMeasureableTime HarmonyStakingTransactionsMeasureable = "time"
	// Transaction Hash
	HarmonyStakingTransactionsMeasureableTransactionHash HarmonyStakingTransactionsMeasureable = "transaction_hash"
	// Gas price provided by the sender
	HarmonyStakingTransactionsMeasureableGasPrice HarmonyStakingTransactionsMeasureable = "gas_price"
	// Validator Address
	HarmonyStakingTransactionsMeasureableValidatorAddress HarmonyStakingTransactionsMeasureable = "validator_address"
	// Deligator Address
	HarmonyStakingTransactionsMeasureableDeligatorAddress HarmonyStakingTransactionsMeasureable = "deligator_address"
	// Value transferred in ATTO
	HarmonyStakingTransactionsMeasureableValue HarmonyStakingTransactionsMeasureable = "value"
	// Gas price provided by the sender
	HarmonyStakingTransactionsMeasureableGasPrice HarmonyStakingTransactionsMeasureable = "gasPrice"
	// Gas provided by the sender
	HarmonyStakingTransactionsMeasureableGas HarmonyStakingTransactionsMeasureable = "gas"
)

var AllHarmonyStakingTransactionsMeasureable = []HarmonyStakingTransactionsMeasureable{
	HarmonyStakingTransactionsMeasureableDate,
	HarmonyStakingTransactionsMeasureableTime,
	HarmonyStakingTransactionsMeasureableTransactionHash,
	HarmonyStakingTransactionsMeasureableGasPrice,
	HarmonyStakingTransactionsMeasureableValidatorAddress,
	HarmonyStakingTransactionsMeasureableDeligatorAddress,
	HarmonyStakingTransactionsMeasureableValue,
	HarmonyStakingTransactionsMeasureableGasPrice,
	HarmonyStakingTransactionsMeasureableGas,
}

func (e HarmonyStakingTransactionsMeasureable) IsValid() bool {
	switch e {
	case HarmonyStakingTransactionsMeasureableDate, HarmonyStakingTransactionsMeasureableTime, HarmonyStakingTransactionsMeasureableTransactionHash, HarmonyStakingTransactionsMeasureableGasPrice, HarmonyStakingTransactionsMeasureableValidatorAddress, HarmonyStakingTransactionsMeasureableDeligatorAddress, HarmonyStakingTransactionsMeasureableValue, HarmonyStakingTransactionsMeasureableGasPrice, HarmonyStakingTransactionsMeasureableGas:
		return true
	}
	return false
}

func (e HarmonyStakingTransactionsMeasureable) String() string {
	return string(e)
}

func (e *HarmonyStakingTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyStakingTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyStakingTransactionsMeasureable", str)
	}
	return nil
}

func (e HarmonyStakingTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyStakingTransactionsUniq string

const (
	// Unique time
	HarmonyStakingTransactionsUniqTimes HarmonyStakingTransactionsUniq = "times"
	// Unique date count
	HarmonyStakingTransactionsUniqDates HarmonyStakingTransactionsUniq = "dates"
	// Unique block
	HarmonyStakingTransactionsUniqLedger HarmonyStakingTransactionsUniq = "ledger"
	// Unique address validator
	HarmonyStakingTransactionsUniqValidatorAddress HarmonyStakingTransactionsUniq = "validator_address"
	// Unique delegator validator
	HarmonyStakingTransactionsUniqDelegatorAddress HarmonyStakingTransactionsUniq = "delegator_address"
)

var AllHarmonyStakingTransactionsUniq = []HarmonyStakingTransactionsUniq{
	HarmonyStakingTransactionsUniqTimes,
	HarmonyStakingTransactionsUniqDates,
	HarmonyStakingTransactionsUniqLedger,
	HarmonyStakingTransactionsUniqValidatorAddress,
	HarmonyStakingTransactionsUniqDelegatorAddress,
}

func (e HarmonyStakingTransactionsUniq) IsValid() bool {
	switch e {
	case HarmonyStakingTransactionsUniqTimes, HarmonyStakingTransactionsUniqDates, HarmonyStakingTransactionsUniqLedger, HarmonyStakingTransactionsUniqValidatorAddress, HarmonyStakingTransactionsUniqDelegatorAddress:
		return true
	}
	return false
}

func (e HarmonyStakingTransactionsUniq) String() string {
	return string(e)
}

func (e *HarmonyStakingTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyStakingTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyStakingTransactionsUniq", str)
	}
	return nil
}

func (e HarmonyStakingTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyTransactionsMeasureable string

const (
	// Date
	HarmonyTransactionsMeasureableDate HarmonyTransactionsMeasureable = "date"
	// Time
	HarmonyTransactionsMeasureableTime HarmonyTransactionsMeasureable = "time"
	// Transaction Hash
	HarmonyTransactionsMeasureableTransactionHash HarmonyTransactionsMeasureable = "transaction_hash"
	// Gas price provided by the sender
	HarmonyTransactionsMeasureableGasPrice HarmonyTransactionsMeasureable = "gas_price"
	// Validator Address
	HarmonyTransactionsMeasureableSender HarmonyTransactionsMeasureable = "sender"
	// Deligator Address
	HarmonyTransactionsMeasureableReciever HarmonyTransactionsMeasureable = "reciever"
	// Value transferred in ATTO
	HarmonyTransactionsMeasureableValue HarmonyTransactionsMeasureable = "value"
	// Gas price provided by the sender
	HarmonyTransactionsMeasureableGasPrice HarmonyTransactionsMeasureable = "gasPrice"
	// Gas value provided by the sender
	HarmonyTransactionsMeasureableGasValue HarmonyTransactionsMeasureable = "gasValue"
	// Gas provided by the sender
	HarmonyTransactionsMeasureableGas HarmonyTransactionsMeasureable = "gas"
)

var AllHarmonyTransactionsMeasureable = []HarmonyTransactionsMeasureable{
	HarmonyTransactionsMeasureableDate,
	HarmonyTransactionsMeasureableTime,
	HarmonyTransactionsMeasureableTransactionHash,
	HarmonyTransactionsMeasureableGasPrice,
	HarmonyTransactionsMeasureableSender,
	HarmonyTransactionsMeasureableReciever,
	HarmonyTransactionsMeasureableValue,
	HarmonyTransactionsMeasureableGasPrice,
	HarmonyTransactionsMeasureableGasValue,
	HarmonyTransactionsMeasureableGas,
}

func (e HarmonyTransactionsMeasureable) IsValid() bool {
	switch e {
	case HarmonyTransactionsMeasureableDate, HarmonyTransactionsMeasureableTime, HarmonyTransactionsMeasureableTransactionHash, HarmonyTransactionsMeasureableGasPrice, HarmonyTransactionsMeasureableSender, HarmonyTransactionsMeasureableReciever, HarmonyTransactionsMeasureableValue, HarmonyTransactionsMeasureableGasPrice, HarmonyTransactionsMeasureableGasValue, HarmonyTransactionsMeasureableGas:
		return true
	}
	return false
}

func (e HarmonyTransactionsMeasureable) String() string {
	return string(e)
}

func (e *HarmonyTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyTransactionsMeasureable", str)
	}
	return nil
}

func (e HarmonyTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyTransactionsUniq string

const (
	// Unique time
	HarmonyTransactionsUniqTimes HarmonyTransactionsUniq = "times"
	// Unique date count
	HarmonyTransactionsUniqDates HarmonyTransactionsUniq = "dates"
	// Unique block
	HarmonyTransactionsUniqLedger HarmonyTransactionsUniq = "ledger"
	// Unique sender
	HarmonyTransactionsUniqSender HarmonyTransactionsUniq = "sender"
	// Unique reciever
	HarmonyTransactionsUniqReciever HarmonyTransactionsUniq = "reciever"
)

var AllHarmonyTransactionsUniq = []HarmonyTransactionsUniq{
	HarmonyTransactionsUniqTimes,
	HarmonyTransactionsUniqDates,
	HarmonyTransactionsUniqLedger,
	HarmonyTransactionsUniqSender,
	HarmonyTransactionsUniqReciever,
}

func (e HarmonyTransactionsUniq) IsValid() bool {
	switch e {
	case HarmonyTransactionsUniqTimes, HarmonyTransactionsUniqDates, HarmonyTransactionsUniqLedger, HarmonyTransactionsUniqSender, HarmonyTransactionsUniqReciever:
		return true
	}
	return false
}

func (e HarmonyTransactionsUniq) String() string {
	return string(e)
}

func (e *HarmonyTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyTransactionsUniq", str)
	}
	return nil
}

func (e HarmonyTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyTransfersMeasureable string

const (
	// Date
	HarmonyTransfersMeasureableDate HarmonyTransfersMeasureable = "date"
	// Time
	HarmonyTransfersMeasureableTime HarmonyTransfersMeasureable = "time"
	// Transaction Hash
	HarmonyTransfersMeasureableTransactionHash HarmonyTransfersMeasureable = "transaction_hash"
	// Gas price provided by the sender
	HarmonyTransfersMeasureableGasPrice HarmonyTransfersMeasureable = "gas_price"
	// Validator Address
	HarmonyTransfersMeasureableSender HarmonyTransfersMeasureable = "sender"
	// Value transferred in ATTO
	HarmonyTransfersMeasureableValue HarmonyTransfersMeasureable = "value"
	// Gas price provided by the sender
	HarmonyTransfersMeasureableGasPrice HarmonyTransfersMeasureable = "gasPrice"
	// Gas value provided by the sender
	HarmonyTransfersMeasureableGasValue HarmonyTransfersMeasureable = "gasValue"
	// Gas provided by the sender
	HarmonyTransfersMeasureableGas HarmonyTransfersMeasureable = "gas"
)

var AllHarmonyTransfersMeasureable = []HarmonyTransfersMeasureable{
	HarmonyTransfersMeasureableDate,
	HarmonyTransfersMeasureableTime,
	HarmonyTransfersMeasureableTransactionHash,
	HarmonyTransfersMeasureableGasPrice,
	HarmonyTransfersMeasureableSender,
	HarmonyTransfersMeasureableValue,
	HarmonyTransfersMeasureableGasPrice,
	HarmonyTransfersMeasureableGasValue,
	HarmonyTransfersMeasureableGas,
}

func (e HarmonyTransfersMeasureable) IsValid() bool {
	switch e {
	case HarmonyTransfersMeasureableDate, HarmonyTransfersMeasureableTime, HarmonyTransfersMeasureableTransactionHash, HarmonyTransfersMeasureableGasPrice, HarmonyTransfersMeasureableSender, HarmonyTransfersMeasureableValue, HarmonyTransfersMeasureableGasPrice, HarmonyTransfersMeasureableGasValue, HarmonyTransfersMeasureableGas:
		return true
	}
	return false
}

func (e HarmonyTransfersMeasureable) String() string {
	return string(e)
}

func (e *HarmonyTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyTransfersMeasureable", str)
	}
	return nil
}

func (e HarmonyTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HarmonyTransfersUniq string

const (
	// Unique time
	HarmonyTransfersUniqTimes HarmonyTransfersUniq = "times"
	// Unique date count
	HarmonyTransfersUniqDates HarmonyTransfersUniq = "dates"
	// Unique block
	HarmonyTransfersUniqLedger HarmonyTransfersUniq = "ledger"
	// Unique sender
	HarmonyTransfersUniqSender HarmonyTransfersUniq = "sender"
	// Unique transfer from
	HarmonyTransfersUniqTransferFrom HarmonyTransfersUniq = "transfer_from"
	// Unique transfer to
	HarmonyTransfersUniqTransferTo HarmonyTransfersUniq = "transfer_to"
)

var AllHarmonyTransfersUniq = []HarmonyTransfersUniq{
	HarmonyTransfersUniqTimes,
	HarmonyTransfersUniqDates,
	HarmonyTransfersUniqLedger,
	HarmonyTransfersUniqSender,
	HarmonyTransfersUniqTransferFrom,
	HarmonyTransfersUniqTransferTo,
}

func (e HarmonyTransfersUniq) IsValid() bool {
	switch e {
	case HarmonyTransfersUniqTimes, HarmonyTransfersUniqDates, HarmonyTransfersUniqLedger, HarmonyTransfersUniqSender, HarmonyTransfersUniqTransferFrom, HarmonyTransfersUniqTransferTo:
		return true
	}
	return false
}

func (e HarmonyTransfersUniq) String() string {
	return string(e)
}

func (e *HarmonyTransfersUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HarmonyTransfersUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HarmonyTransfersUniq", str)
	}
	return nil
}

func (e HarmonyTransfersUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaArgumentsMeasureable string

const (
	// Date
	HederaArgumentsMeasureableDate HederaArgumentsMeasureable = "date"
	// Time
	HederaArgumentsMeasureableTime HederaArgumentsMeasureable = "time"
	// Valid start
	HederaArgumentsMeasureableValidStart HederaArgumentsMeasureable = "valid_start"
	// Valid duration
	HederaArgumentsMeasureableValidDuration HederaArgumentsMeasureable = "valid_duration"
	// Transaction Hash
	HederaArgumentsMeasureableTransactionHash HederaArgumentsMeasureable = "transaction_hash"
	// Max Fee
	HederaArgumentsMeasureableMaxFee HederaArgumentsMeasureable = "max_fee"
	// Charged Fee
	HederaArgumentsMeasureableTransactionFee HederaArgumentsMeasureable = "transaction_fee"
)

var AllHederaArgumentsMeasureable = []HederaArgumentsMeasureable{
	HederaArgumentsMeasureableDate,
	HederaArgumentsMeasureableTime,
	HederaArgumentsMeasureableValidStart,
	HederaArgumentsMeasureableValidDuration,
	HederaArgumentsMeasureableTransactionHash,
	HederaArgumentsMeasureableMaxFee,
	HederaArgumentsMeasureableTransactionFee,
}

func (e HederaArgumentsMeasureable) IsValid() bool {
	switch e {
	case HederaArgumentsMeasureableDate, HederaArgumentsMeasureableTime, HederaArgumentsMeasureableValidStart, HederaArgumentsMeasureableValidDuration, HederaArgumentsMeasureableTransactionHash, HederaArgumentsMeasureableMaxFee, HederaArgumentsMeasureableTransactionFee:
		return true
	}
	return false
}

func (e HederaArgumentsMeasureable) String() string {
	return string(e)
}

func (e *HederaArgumentsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaArgumentsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaArgumentsMeasureable", str)
	}
	return nil
}

func (e HederaArgumentsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaArgumentsUniq string

const (
	// Unique time
	HederaArgumentsUniqTimes HederaArgumentsUniq = "times"
	// Unique date count
	HederaArgumentsUniqDates HederaArgumentsUniq = "dates"
	// Unique consensus time
	HederaArgumentsUniqConsensusTimes HederaArgumentsUniq = "consensus_times"
	// Unique payer account
	HederaArgumentsUniqPayerAccount HederaArgumentsUniq = "payer_account"
	// Unique node account
	HederaArgumentsUniqNodeAccount HederaArgumentsUniq = "node_account"
	// Unique node account
	HederaArgumentsUniqSmartContractEntity HederaArgumentsUniq = "smart_contract_entity"
	// Unique initial balance
	HederaArgumentsUniqInitialBalance HederaArgumentsUniq = "initial_balance"
)

var AllHederaArgumentsUniq = []HederaArgumentsUniq{
	HederaArgumentsUniqTimes,
	HederaArgumentsUniqDates,
	HederaArgumentsUniqConsensusTimes,
	HederaArgumentsUniqPayerAccount,
	HederaArgumentsUniqNodeAccount,
	HederaArgumentsUniqSmartContractEntity,
	HederaArgumentsUniqInitialBalance,
}

func (e HederaArgumentsUniq) IsValid() bool {
	switch e {
	case HederaArgumentsUniqTimes, HederaArgumentsUniqDates, HederaArgumentsUniqConsensusTimes, HederaArgumentsUniqPayerAccount, HederaArgumentsUniqNodeAccount, HederaArgumentsUniqSmartContractEntity, HederaArgumentsUniqInitialBalance:
		return true
	}
	return false
}

func (e HederaArgumentsUniq) String() string {
	return string(e)
}

func (e *HederaArgumentsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaArgumentsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaArgumentsUniq", str)
	}
	return nil
}

func (e HederaArgumentsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaCallsMeasureable string

const (
	// Date
	HederaCallsMeasureableDate HederaCallsMeasureable = "date"
	// Time
	HederaCallsMeasureableTime HederaCallsMeasureable = "time"
	// Valid start
	HederaCallsMeasureableValidStart HederaCallsMeasureable = "valid_start"
	// Valid duration
	HederaCallsMeasureableValidDuration HederaCallsMeasureable = "valid_duration"
	// Transaction Hash
	HederaCallsMeasureableTransactionHash HederaCallsMeasureable = "transaction_hash"
	// Max Fee
	HederaCallsMeasureableMaxFee HederaCallsMeasureable = "max_fee"
	// Charged Fee
	HederaCallsMeasureableTransactionFee HederaCallsMeasureable = "transaction_fee"
)

var AllHederaCallsMeasureable = []HederaCallsMeasureable{
	HederaCallsMeasureableDate,
	HederaCallsMeasureableTime,
	HederaCallsMeasureableValidStart,
	HederaCallsMeasureableValidDuration,
	HederaCallsMeasureableTransactionHash,
	HederaCallsMeasureableMaxFee,
	HederaCallsMeasureableTransactionFee,
}

func (e HederaCallsMeasureable) IsValid() bool {
	switch e {
	case HederaCallsMeasureableDate, HederaCallsMeasureableTime, HederaCallsMeasureableValidStart, HederaCallsMeasureableValidDuration, HederaCallsMeasureableTransactionHash, HederaCallsMeasureableMaxFee, HederaCallsMeasureableTransactionFee:
		return true
	}
	return false
}

func (e HederaCallsMeasureable) String() string {
	return string(e)
}

func (e *HederaCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaCallsMeasureable", str)
	}
	return nil
}

func (e HederaCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaCallsUniq string

const (
	// Unique time
	HederaCallsUniqTimes HederaCallsUniq = "times"
	// Unique date count
	HederaCallsUniqDates HederaCallsUniq = "dates"
	// Unique consensus time
	HederaCallsUniqConsensusTimes HederaCallsUniq = "consensus_times"
	// Unique payer account
	HederaCallsUniqPayerAccount HederaCallsUniq = "payer_account"
	// Unique node account
	HederaCallsUniqNodeAccount HederaCallsUniq = "node_account"
	// Unique node account
	HederaCallsUniqSmartContractEntity HederaCallsUniq = "smart_contract_entity"
	// Unique initial balance
	HederaCallsUniqInitialBalance HederaCallsUniq = "initial_balance"
)

var AllHederaCallsUniq = []HederaCallsUniq{
	HederaCallsUniqTimes,
	HederaCallsUniqDates,
	HederaCallsUniqConsensusTimes,
	HederaCallsUniqPayerAccount,
	HederaCallsUniqNodeAccount,
	HederaCallsUniqSmartContractEntity,
	HederaCallsUniqInitialBalance,
}

func (e HederaCallsUniq) IsValid() bool {
	switch e {
	case HederaCallsUniqTimes, HederaCallsUniqDates, HederaCallsUniqConsensusTimes, HederaCallsUniqPayerAccount, HederaCallsUniqNodeAccount, HederaCallsUniqSmartContractEntity, HederaCallsUniqInitialBalance:
		return true
	}
	return false
}

func (e HederaCallsUniq) String() string {
	return string(e)
}

func (e *HederaCallsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaCallsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaCallsUniq", str)
	}
	return nil
}

func (e HederaCallsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaInputMeasureable string

const (
	// Date
	HederaInputMeasureableDate HederaInputMeasureable = "date"
	// Time
	HederaInputMeasureableTime HederaInputMeasureable = "time"
	// Valid start
	HederaInputMeasureableValidStart HederaInputMeasureable = "valid_start"
	// Valid duration
	HederaInputMeasureableValidDuration HederaInputMeasureable = "valid_duration"
	// Transaction Hash
	HederaInputMeasureableTransactionHash HederaInputMeasureable = "transaction_hash"
	// Max Fee
	HederaInputMeasureableMaxFee HederaInputMeasureable = "max_fee"
	// Charged Fee
	HederaInputMeasureableTransactionFee HederaInputMeasureable = "transaction_fee"
	// Amount
	HederaInputMeasureableAmount HederaInputMeasureable = "amount"
)

var AllHederaInputMeasureable = []HederaInputMeasureable{
	HederaInputMeasureableDate,
	HederaInputMeasureableTime,
	HederaInputMeasureableValidStart,
	HederaInputMeasureableValidDuration,
	HederaInputMeasureableTransactionHash,
	HederaInputMeasureableMaxFee,
	HederaInputMeasureableTransactionFee,
	HederaInputMeasureableAmount,
}

func (e HederaInputMeasureable) IsValid() bool {
	switch e {
	case HederaInputMeasureableDate, HederaInputMeasureableTime, HederaInputMeasureableValidStart, HederaInputMeasureableValidDuration, HederaInputMeasureableTransactionHash, HederaInputMeasureableMaxFee, HederaInputMeasureableTransactionFee, HederaInputMeasureableAmount:
		return true
	}
	return false
}

func (e HederaInputMeasureable) String() string {
	return string(e)
}

func (e *HederaInputMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaInputMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaInputMeasureable", str)
	}
	return nil
}

func (e HederaInputMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaInputsUniq string

const (
	// Unique time
	HederaInputsUniqTimes HederaInputsUniq = "times"
	// Unique date count
	HederaInputsUniqDates HederaInputsUniq = "dates"
	// Unique consensus time
	HederaInputsUniqConsensusTimes HederaInputsUniq = "consensus_times"
	// Unique payer account
	HederaInputsUniqPayerAccount HederaInputsUniq = "payer_account"
	// Unique node account
	HederaInputsUniqNodeAccount HederaInputsUniq = "node_account"
	// Unique entity id
	HederaInputsUniqEntityID HederaInputsUniq = "entity_id"
	// Unique entity type
	HederaInputsUniqEntityType HederaInputsUniq = "entity_type"
	// Unique initial balance
	HederaInputsUniqInitialBalance HederaInputsUniq = "initial_balance"
)

var AllHederaInputsUniq = []HederaInputsUniq{
	HederaInputsUniqTimes,
	HederaInputsUniqDates,
	HederaInputsUniqConsensusTimes,
	HederaInputsUniqPayerAccount,
	HederaInputsUniqNodeAccount,
	HederaInputsUniqEntityID,
	HederaInputsUniqEntityType,
	HederaInputsUniqInitialBalance,
}

func (e HederaInputsUniq) IsValid() bool {
	switch e {
	case HederaInputsUniqTimes, HederaInputsUniqDates, HederaInputsUniqConsensusTimes, HederaInputsUniqPayerAccount, HederaInputsUniqNodeAccount, HederaInputsUniqEntityID, HederaInputsUniqEntityType, HederaInputsUniqInitialBalance:
		return true
	}
	return false
}

func (e HederaInputsUniq) String() string {
	return string(e)
}

func (e *HederaInputsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaInputsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaInputsUniq", str)
	}
	return nil
}

func (e HederaInputsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaMessageMeasureable string

const (
	// Date
	HederaMessageMeasureableDate HederaMessageMeasureable = "date"
	// Time
	HederaMessageMeasureableTime HederaMessageMeasureable = "time"
	// Valid start
	HederaMessageMeasureableValidStart HederaMessageMeasureable = "valid_start"
	// Valid duration
	HederaMessageMeasureableValidDuration HederaMessageMeasureable = "valid_duration"
	// Transaction Hash
	HederaMessageMeasureableTransactionHash HederaMessageMeasureable = "transaction_hash"
	// Max Fee
	HederaMessageMeasureableMaxFee HederaMessageMeasureable = "max_fee"
	// Charged Fee
	HederaMessageMeasureableTransactionFee HederaMessageMeasureable = "transaction_fee"
)

var AllHederaMessageMeasureable = []HederaMessageMeasureable{
	HederaMessageMeasureableDate,
	HederaMessageMeasureableTime,
	HederaMessageMeasureableValidStart,
	HederaMessageMeasureableValidDuration,
	HederaMessageMeasureableTransactionHash,
	HederaMessageMeasureableMaxFee,
	HederaMessageMeasureableTransactionFee,
}

func (e HederaMessageMeasureable) IsValid() bool {
	switch e {
	case HederaMessageMeasureableDate, HederaMessageMeasureableTime, HederaMessageMeasureableValidStart, HederaMessageMeasureableValidDuration, HederaMessageMeasureableTransactionHash, HederaMessageMeasureableMaxFee, HederaMessageMeasureableTransactionFee:
		return true
	}
	return false
}

func (e HederaMessageMeasureable) String() string {
	return string(e)
}

func (e *HederaMessageMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaMessageMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaMessageMeasureable", str)
	}
	return nil
}

func (e HederaMessageMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaMessagesUniq string

const (
	// Unique time
	HederaMessagesUniqTimes HederaMessagesUniq = "times"
	// Unique date count
	HederaMessagesUniqDates HederaMessagesUniq = "dates"
	// Unique consensus time
	HederaMessagesUniqConsensusTimes HederaMessagesUniq = "consensus_times"
	// Unique payer account
	HederaMessagesUniqPayerAccount HederaMessagesUniq = "payer_account"
	// Unique node account
	HederaMessagesUniqNodeAccount HederaMessagesUniq = "node_account"
	// Unique entity id
	HederaMessagesUniqEntityID HederaMessagesUniq = "entity_id"
	// Unique entity type
	HederaMessagesUniqEntityType HederaMessagesUniq = "entity_type"
	// Unique initial balance
	HederaMessagesUniqInitialBalance HederaMessagesUniq = "initial_balance"
)

var AllHederaMessagesUniq = []HederaMessagesUniq{
	HederaMessagesUniqTimes,
	HederaMessagesUniqDates,
	HederaMessagesUniqConsensusTimes,
	HederaMessagesUniqPayerAccount,
	HederaMessagesUniqNodeAccount,
	HederaMessagesUniqEntityID,
	HederaMessagesUniqEntityType,
	HederaMessagesUniqInitialBalance,
}

func (e HederaMessagesUniq) IsValid() bool {
	switch e {
	case HederaMessagesUniqTimes, HederaMessagesUniqDates, HederaMessagesUniqConsensusTimes, HederaMessagesUniqPayerAccount, HederaMessagesUniqNodeAccount, HederaMessagesUniqEntityID, HederaMessagesUniqEntityType, HederaMessagesUniqInitialBalance:
		return true
	}
	return false
}

func (e HederaMessagesUniq) String() string {
	return string(e)
}

func (e *HederaMessagesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaMessagesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaMessagesUniq", str)
	}
	return nil
}

func (e HederaMessagesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaNetwork string

const (
	// The Hedera mainnet
	HederaNetworkHedera HederaNetwork = "hedera"
	// The Hedera testnets
	HederaNetworkHederaTestnets HederaNetwork = "hedera_testnets"
)

var AllHederaNetwork = []HederaNetwork{
	HederaNetworkHedera,
	HederaNetworkHederaTestnets,
}

func (e HederaNetwork) IsValid() bool {
	switch e {
	case HederaNetworkHedera, HederaNetworkHederaTestnets:
		return true
	}
	return false
}

func (e HederaNetwork) String() string {
	return string(e)
}

func (e *HederaNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaNetwork", str)
	}
	return nil
}

func (e HederaNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaOutputMeasureable string

const (
	// Date
	HederaOutputMeasureableDate HederaOutputMeasureable = "date"
	// Time
	HederaOutputMeasureableTime HederaOutputMeasureable = "time"
	// Valid start
	HederaOutputMeasureableValidStart HederaOutputMeasureable = "valid_start"
	// Valid duration
	HederaOutputMeasureableValidDuration HederaOutputMeasureable = "valid_duration"
	// Transaction Hash
	HederaOutputMeasureableTransactionHash HederaOutputMeasureable = "transaction_hash"
	// Max Fee
	HederaOutputMeasureableMaxFee HederaOutputMeasureable = "max_fee"
	// Charged Fee
	HederaOutputMeasureableTransactionFee HederaOutputMeasureable = "transaction_fee"
	// Amount
	HederaOutputMeasureableAmount HederaOutputMeasureable = "amount"
)

var AllHederaOutputMeasureable = []HederaOutputMeasureable{
	HederaOutputMeasureableDate,
	HederaOutputMeasureableTime,
	HederaOutputMeasureableValidStart,
	HederaOutputMeasureableValidDuration,
	HederaOutputMeasureableTransactionHash,
	HederaOutputMeasureableMaxFee,
	HederaOutputMeasureableTransactionFee,
	HederaOutputMeasureableAmount,
}

func (e HederaOutputMeasureable) IsValid() bool {
	switch e {
	case HederaOutputMeasureableDate, HederaOutputMeasureableTime, HederaOutputMeasureableValidStart, HederaOutputMeasureableValidDuration, HederaOutputMeasureableTransactionHash, HederaOutputMeasureableMaxFee, HederaOutputMeasureableTransactionFee, HederaOutputMeasureableAmount:
		return true
	}
	return false
}

func (e HederaOutputMeasureable) String() string {
	return string(e)
}

func (e *HederaOutputMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaOutputMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaOutputMeasureable", str)
	}
	return nil
}

func (e HederaOutputMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaOutputUniq string

const (
	// Unique time
	HederaOutputUniqTimes HederaOutputUniq = "times"
	// Unique date count
	HederaOutputUniqDates HederaOutputUniq = "dates"
	// Unique consensus time
	HederaOutputUniqConsensusTimes HederaOutputUniq = "consensus_times"
	// Unique Transfer entity
	HederaOutputUniqTransferEntity HederaOutputUniq = "transfer_entity"
	// Unique payer account
	HederaOutputUniqPayerAccount HederaOutputUniq = "payer_account"
	// Unique node account
	HederaOutputUniqNodeAccount HederaOutputUniq = "node_account"
	// Unique entity id
	HederaOutputUniqEntityID HederaOutputUniq = "entity_id"
	// Unique entity type
	HederaOutputUniqEntityType HederaOutputUniq = "entity_type"
	// Unique initial balance
	HederaOutputUniqInitialBalance HederaOutputUniq = "initial_balance"
)

var AllHederaOutputUniq = []HederaOutputUniq{
	HederaOutputUniqTimes,
	HederaOutputUniqDates,
	HederaOutputUniqConsensusTimes,
	HederaOutputUniqTransferEntity,
	HederaOutputUniqPayerAccount,
	HederaOutputUniqNodeAccount,
	HederaOutputUniqEntityID,
	HederaOutputUniqEntityType,
	HederaOutputUniqInitialBalance,
}

func (e HederaOutputUniq) IsValid() bool {
	switch e {
	case HederaOutputUniqTimes, HederaOutputUniqDates, HederaOutputUniqConsensusTimes, HederaOutputUniqTransferEntity, HederaOutputUniqPayerAccount, HederaOutputUniqNodeAccount, HederaOutputUniqEntityID, HederaOutputUniqEntityType, HederaOutputUniqInitialBalance:
		return true
	}
	return false
}

func (e HederaOutputUniq) String() string {
	return string(e)
}

func (e *HederaOutputUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaOutputUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaOutputUniq", str)
	}
	return nil
}

func (e HederaOutputUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaTransactionMeasureable string

const (
	// Date
	HederaTransactionMeasureableDate HederaTransactionMeasureable = "date"
	// Time
	HederaTransactionMeasureableTime HederaTransactionMeasureable = "time"
	// Valid start
	HederaTransactionMeasureableValidStart HederaTransactionMeasureable = "valid_start"
	// Valid duration
	HederaTransactionMeasureableValidDuration HederaTransactionMeasureable = "valid_duration"
	// Transaction Hash
	HederaTransactionMeasureableTransactionHash HederaTransactionMeasureable = "transaction_hash"
	// Max Fee
	HederaTransactionMeasureableMaxFee HederaTransactionMeasureable = "max_fee"
	// Charged Fee
	HederaTransactionMeasureableTransactionFee HederaTransactionMeasureable = "transaction_fee"
)

var AllHederaTransactionMeasureable = []HederaTransactionMeasureable{
	HederaTransactionMeasureableDate,
	HederaTransactionMeasureableTime,
	HederaTransactionMeasureableValidStart,
	HederaTransactionMeasureableValidDuration,
	HederaTransactionMeasureableTransactionHash,
	HederaTransactionMeasureableMaxFee,
	HederaTransactionMeasureableTransactionFee,
}

func (e HederaTransactionMeasureable) IsValid() bool {
	switch e {
	case HederaTransactionMeasureableDate, HederaTransactionMeasureableTime, HederaTransactionMeasureableValidStart, HederaTransactionMeasureableValidDuration, HederaTransactionMeasureableTransactionHash, HederaTransactionMeasureableMaxFee, HederaTransactionMeasureableTransactionFee:
		return true
	}
	return false
}

func (e HederaTransactionMeasureable) String() string {
	return string(e)
}

func (e *HederaTransactionMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaTransactionMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaTransactionMeasureable", str)
	}
	return nil
}

func (e HederaTransactionMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HederaTransactionsUniq string

const (
	// Unique time
	HederaTransactionsUniqTimes HederaTransactionsUniq = "times"
	// Unique date count
	HederaTransactionsUniqDates HederaTransactionsUniq = "dates"
	// Unique consensus time
	HederaTransactionsUniqConsensusTimes HederaTransactionsUniq = "consensus_times"
	// Unique transaction type
	HederaTransactionsUniqTransactionType HederaTransactionsUniq = "transaction_type"
	// Unique payer account
	HederaTransactionsUniqPayerAccount HederaTransactionsUniq = "payer_account"
	// Unique node account
	HederaTransactionsUniqNodeAccount HederaTransactionsUniq = "node_account"
	// Unique entity id
	HederaTransactionsUniqEntityID HederaTransactionsUniq = "entity_id"
	// Unique entity type
	HederaTransactionsUniqEntityType HederaTransactionsUniq = "entity_type"
	// Unique initial balance
	HederaTransactionsUniqInitialBalance HederaTransactionsUniq = "initial_balance"
)

var AllHederaTransactionsUniq = []HederaTransactionsUniq{
	HederaTransactionsUniqTimes,
	HederaTransactionsUniqDates,
	HederaTransactionsUniqConsensusTimes,
	HederaTransactionsUniqTransactionType,
	HederaTransactionsUniqPayerAccount,
	HederaTransactionsUniqNodeAccount,
	HederaTransactionsUniqEntityID,
	HederaTransactionsUniqEntityType,
	HederaTransactionsUniqInitialBalance,
}

func (e HederaTransactionsUniq) IsValid() bool {
	switch e {
	case HederaTransactionsUniqTimes, HederaTransactionsUniqDates, HederaTransactionsUniqConsensusTimes, HederaTransactionsUniqTransactionType, HederaTransactionsUniqPayerAccount, HederaTransactionsUniqNodeAccount, HederaTransactionsUniqEntityID, HederaTransactionsUniqEntityType, HederaTransactionsUniqInitialBalance:
		return true
	}
	return false
}

func (e HederaTransactionsUniq) String() string {
	return string(e)
}

func (e *HederaTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HederaTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HederaTransactionsUniq", str)
	}
	return nil
}

func (e HederaTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraBlockUniq string

const (
	// Proposer
	LibraBlockUniqProposer LibraBlockUniq = "proposer"
	// Unique date count
	LibraBlockUniqDates LibraBlockUniq = "dates"
)

var AllLibraBlockUniq = []LibraBlockUniq{
	LibraBlockUniqProposer,
	LibraBlockUniqDates,
}

func (e LibraBlockUniq) IsValid() bool {
	switch e {
	case LibraBlockUniqProposer, LibraBlockUniqDates:
		return true
	}
	return false
}

func (e LibraBlockUniq) String() string {
	return string(e)
}

func (e *LibraBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraBlockUniq", str)
	}
	return nil
}

func (e LibraBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraBlocksMeasureable string

const (
	// Date
	LibraBlocksMeasureableDate LibraBlocksMeasureable = "date"
	// Time
	LibraBlocksMeasureableTime LibraBlocksMeasureable = "time"
	// Block round
	LibraBlocksMeasureableBlock LibraBlocksMeasureable = "block"
	// Version
	LibraBlocksMeasureableVersion LibraBlocksMeasureable = "version"
	// Proposer
	LibraBlocksMeasureableProposer LibraBlocksMeasureable = "proposer"
	// Gas Used
	LibraBlocksMeasureableGasUsed LibraBlocksMeasureable = "gas_used"
)

var AllLibraBlocksMeasureable = []LibraBlocksMeasureable{
	LibraBlocksMeasureableDate,
	LibraBlocksMeasureableTime,
	LibraBlocksMeasureableBlock,
	LibraBlocksMeasureableVersion,
	LibraBlocksMeasureableProposer,
	LibraBlocksMeasureableGasUsed,
}

func (e LibraBlocksMeasureable) IsValid() bool {
	switch e {
	case LibraBlocksMeasureableDate, LibraBlocksMeasureableTime, LibraBlocksMeasureableBlock, LibraBlocksMeasureableVersion, LibraBlocksMeasureableProposer, LibraBlocksMeasureableGasUsed:
		return true
	}
	return false
}

func (e LibraBlocksMeasureable) String() string {
	return string(e)
}

func (e *LibraBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraBlocksMeasureable", str)
	}
	return nil
}

func (e LibraBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraCoinpathMeasureable string

const (
	// Time
	LibraCoinpathMeasureableTime LibraCoinpathMeasureable = "time"
	// Block
	LibraCoinpathMeasureableBlock LibraCoinpathMeasureable = "block"
	// Version
	LibraCoinpathMeasureableVersion LibraCoinpathMeasureable = "version"
	// Sender
	LibraCoinpathMeasureableSender LibraCoinpathMeasureable = "sender"
	// Receiver
	LibraCoinpathMeasureableReceiver LibraCoinpathMeasureable = "receiver"
	// Depth
	LibraCoinpathMeasureableDepth LibraCoinpathMeasureable = "depth"
)

var AllLibraCoinpathMeasureable = []LibraCoinpathMeasureable{
	LibraCoinpathMeasureableTime,
	LibraCoinpathMeasureableBlock,
	LibraCoinpathMeasureableVersion,
	LibraCoinpathMeasureableSender,
	LibraCoinpathMeasureableReceiver,
	LibraCoinpathMeasureableDepth,
}

func (e LibraCoinpathMeasureable) IsValid() bool {
	switch e {
	case LibraCoinpathMeasureableTime, LibraCoinpathMeasureableBlock, LibraCoinpathMeasureableVersion, LibraCoinpathMeasureableSender, LibraCoinpathMeasureableReceiver, LibraCoinpathMeasureableDepth:
		return true
	}
	return false
}

func (e LibraCoinpathMeasureable) String() string {
	return string(e)
}

func (e *LibraCoinpathMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraCoinpathMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraCoinpathMeasureable", str)
	}
	return nil
}

func (e LibraCoinpathMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraMintsMeasureable string

const (
	// Date
	LibraMintsMeasureableDate LibraMintsMeasureable = "date"
	// Time
	LibraMintsMeasureableTime LibraMintsMeasureable = "time"
	// Block
	LibraMintsMeasureableBlock LibraMintsMeasureable = "block"
	// Version
	LibraMintsMeasureableVersion LibraMintsMeasureable = "version"
	// Mint version hash
	LibraMintsMeasureableVersionHash LibraMintsMeasureable = "version_hash"
	// Amount
	LibraMintsMeasureableAmount LibraMintsMeasureable = "amount"
	// Minter
	LibraMintsMeasureableMinter LibraMintsMeasureable = "minter"
	// Currency symbol
	LibraMintsMeasureableCurrencySymbol LibraMintsMeasureable = "currency_symbol"
)

var AllLibraMintsMeasureable = []LibraMintsMeasureable{
	LibraMintsMeasureableDate,
	LibraMintsMeasureableTime,
	LibraMintsMeasureableBlock,
	LibraMintsMeasureableVersion,
	LibraMintsMeasureableVersionHash,
	LibraMintsMeasureableAmount,
	LibraMintsMeasureableMinter,
	LibraMintsMeasureableCurrencySymbol,
}

func (e LibraMintsMeasureable) IsValid() bool {
	switch e {
	case LibraMintsMeasureableDate, LibraMintsMeasureableTime, LibraMintsMeasureableBlock, LibraMintsMeasureableVersion, LibraMintsMeasureableVersionHash, LibraMintsMeasureableAmount, LibraMintsMeasureableMinter, LibraMintsMeasureableCurrencySymbol:
		return true
	}
	return false
}

func (e LibraMintsMeasureable) String() string {
	return string(e)
}

func (e *LibraMintsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraMintsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraMintsMeasureable", str)
	}
	return nil
}

func (e LibraMintsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraMintsUniq string

const (
	// Unique blocks
	LibraMintsUniqBlocks LibraMintsUniq = "blocks"
	// Unique versions
	LibraMintsUniqVersions LibraMintsUniq = "versions"
	// Unique date count
	LibraMintsUniqDates LibraMintsUniq = "dates"
	// Unique minters
	LibraMintsUniqMinters LibraMintsUniq = "minters"
	// Unique currencies
	LibraMintsUniqCurrencies LibraMintsUniq = "currencies"
)

var AllLibraMintsUniq = []LibraMintsUniq{
	LibraMintsUniqBlocks,
	LibraMintsUniqVersions,
	LibraMintsUniqDates,
	LibraMintsUniqMinters,
	LibraMintsUniqCurrencies,
}

func (e LibraMintsUniq) IsValid() bool {
	switch e {
	case LibraMintsUniqBlocks, LibraMintsUniqVersions, LibraMintsUniqDates, LibraMintsUniqMinters, LibraMintsUniqCurrencies:
		return true
	}
	return false
}

func (e LibraMintsUniq) String() string {
	return string(e)
}

func (e *LibraMintsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraMintsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraMintsUniq", str)
	}
	return nil
}

func (e LibraMintsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraTransactionsMeasureable string

const (
	// Date
	LibraTransactionsMeasureableDate LibraTransactionsMeasureable = "date"
	// Time
	LibraTransactionsMeasureableTime LibraTransactionsMeasureable = "time"
	// Block
	LibraTransactionsMeasureableBlock LibraTransactionsMeasureable = "block"
	// Version
	LibraTransactionsMeasureableVersion LibraTransactionsMeasureable = "version"
	// Transaction Sender
	LibraTransactionsMeasureableTxSender LibraTransactionsMeasureable = "tx_sender"
	// Script Hash
	LibraTransactionsMeasureableScriptHash LibraTransactionsMeasureable = "script_hash"
	// Gas price
	LibraTransactionsMeasureableGasPrice LibraTransactionsMeasureable = "gas_price"
	// Gas used
	LibraTransactionsMeasureableGas LibraTransactionsMeasureable = "gas"
)

var AllLibraTransactionsMeasureable = []LibraTransactionsMeasureable{
	LibraTransactionsMeasureableDate,
	LibraTransactionsMeasureableTime,
	LibraTransactionsMeasureableBlock,
	LibraTransactionsMeasureableVersion,
	LibraTransactionsMeasureableTxSender,
	LibraTransactionsMeasureableScriptHash,
	LibraTransactionsMeasureableGasPrice,
	LibraTransactionsMeasureableGas,
}

func (e LibraTransactionsMeasureable) IsValid() bool {
	switch e {
	case LibraTransactionsMeasureableDate, LibraTransactionsMeasureableTime, LibraTransactionsMeasureableBlock, LibraTransactionsMeasureableVersion, LibraTransactionsMeasureableTxSender, LibraTransactionsMeasureableScriptHash, LibraTransactionsMeasureableGasPrice, LibraTransactionsMeasureableGas:
		return true
	}
	return false
}

func (e LibraTransactionsMeasureable) String() string {
	return string(e)
}

func (e *LibraTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraTransactionsMeasureable", str)
	}
	return nil
}

func (e LibraTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraTransactionsUniq string

const (
	// Unique blocks
	LibraTransactionsUniqBlocks LibraTransactionsUniq = "blocks"
	// Unique versions
	LibraTransactionsUniqVersions LibraTransactionsUniq = "versions"
	// Unique date count
	LibraTransactionsUniqDates LibraTransactionsUniq = "dates"
	// Unique transaction senders
	LibraTransactionsUniqSenders LibraTransactionsUniq = "senders"
	// Unique transaction script hashes
	LibraTransactionsUniqScripts LibraTransactionsUniq = "scripts"
)

var AllLibraTransactionsUniq = []LibraTransactionsUniq{
	LibraTransactionsUniqBlocks,
	LibraTransactionsUniqVersions,
	LibraTransactionsUniqDates,
	LibraTransactionsUniqSenders,
	LibraTransactionsUniqScripts,
}

func (e LibraTransactionsUniq) IsValid() bool {
	switch e {
	case LibraTransactionsUniqBlocks, LibraTransactionsUniqVersions, LibraTransactionsUniqDates, LibraTransactionsUniqSenders, LibraTransactionsUniqScripts:
		return true
	}
	return false
}

func (e LibraTransactionsUniq) String() string {
	return string(e)
}

func (e *LibraTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraTransactionsUniq", str)
	}
	return nil
}

func (e LibraTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LibraTransfersMeasureable string

const (
	// Date
	LibraTransfersMeasureableDate LibraTransfersMeasureable = "date"
	// Time
	LibraTransfersMeasureableTime LibraTransfersMeasureable = "time"
	// Block
	LibraTransfersMeasureableHeight LibraTransfersMeasureable = "height"
	// Version
	LibraTransfersMeasureableVersion LibraTransfersMeasureable = "version"
	// Version hash
	LibraTransfersMeasureableVersionHash LibraTransfersMeasureable = "version_hash"
	// Amount
	LibraTransfersMeasureableAmount LibraTransfersMeasureable = "amount"
	// Transfer Sender
	LibraTransfersMeasureableTxSender LibraTransfersMeasureable = "tx_sender"
	// Sender
	LibraTransfersMeasureableSender LibraTransfersMeasureable = "sender"
	// Receiver
	LibraTransfersMeasureableReceiver LibraTransfersMeasureable = "receiver"
	// Script Hash
	LibraTransfersMeasureableScriptHash LibraTransfersMeasureable = "script_hash"
	// Currency symbol
	LibraTransfersMeasureableCurrencySymbol LibraTransfersMeasureable = "currency_symbol"
	// Gas value
	LibraTransfersMeasureableGasValue LibraTransfersMeasureable = "gas_value"
	// Gas price
	LibraTransfersMeasureableGasPrice LibraTransfersMeasureable = "gas_price"
	// Gas used
	LibraTransfersMeasureableGas LibraTransfersMeasureable = "gas"
)

var AllLibraTransfersMeasureable = []LibraTransfersMeasureable{
	LibraTransfersMeasureableDate,
	LibraTransfersMeasureableTime,
	LibraTransfersMeasureableHeight,
	LibraTransfersMeasureableVersion,
	LibraTransfersMeasureableVersionHash,
	LibraTransfersMeasureableAmount,
	LibraTransfersMeasureableTxSender,
	LibraTransfersMeasureableSender,
	LibraTransfersMeasureableReceiver,
	LibraTransfersMeasureableScriptHash,
	LibraTransfersMeasureableCurrencySymbol,
	LibraTransfersMeasureableGasValue,
	LibraTransfersMeasureableGasPrice,
	LibraTransfersMeasureableGas,
}

func (e LibraTransfersMeasureable) IsValid() bool {
	switch e {
	case LibraTransfersMeasureableDate, LibraTransfersMeasureableTime, LibraTransfersMeasureableHeight, LibraTransfersMeasureableVersion, LibraTransfersMeasureableVersionHash, LibraTransfersMeasureableAmount, LibraTransfersMeasureableTxSender, LibraTransfersMeasureableSender, LibraTransfersMeasureableReceiver, LibraTransfersMeasureableScriptHash, LibraTransfersMeasureableCurrencySymbol, LibraTransfersMeasureableGasValue, LibraTransfersMeasureableGasPrice, LibraTransfersMeasureableGas:
		return true
	}
	return false
}

func (e LibraTransfersMeasureable) String() string {
	return string(e)
}

func (e *LibraTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LibraTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LibraTransfersMeasureable", str)
	}
	return nil
}

func (e LibraTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Network string

const (
	// Ethereum Mainnet
	NetworkEthereum Network = "ethereum"
	// Ethereum Classic
	NetworkEthclassic Network = "ethclassic"
	// Ethereum Classic ( no reorg from block 10904146)
	NetworkEthclassicReorg Network = "ethclassic_reorg"
	// Binance DEX
	NetworkBinance Network = "binance"
	// Celo Alfajores Testnet
	NetworkCeloAlfajores Network = "celo_alfajores"
	// Celo Baklava Testnet
	NetworkCeloBaklava Network = "celo_baklava"
	// Celo RC1
	NetworkCeloRc1 Network = "celo_rc1"
	// Bitcoin ( BTC )
	NetworkBitcoin Network = "bitcoin"
	// Bitcoin Cash ( BCH )
	NetworkBitcash Network = "bitcash"
	// Bitcoin SV ( BSV )
	NetworkBitcoinsv Network = "bitcoinsv"
	// Litecoin ( LTC )
	NetworkLitecoin Network = "litecoin"
	// Dash ( DASH )
	NetworkDash Network = "dash"
	// Dogecoin ( DOGE )
	NetworkDogecoin Network = "dogecoin"
	// Cardano ( ADA )
	NetworkCardano Network = "cardano"
	// Zcash ( ZEC )
	NetworkZcash Network = "zcash"
	// Algorand Mainnet (ALGO)
	NetworkAlgorand Network = "algorand"
	// Algorand Testnet
	NetworkAlgorandTestnet Network = "algorand_testnet"
	// Algorand Betanet
	NetworkAlgorandBetanet Network = "algorand_betanet"
	// Conflux Oceanus
	NetworkConfluxOceanus Network = "conflux_oceanus"
	// Conflux Tethys
	NetworkConfluxTethys Network = "conflux_tethys"
	// Libra Testnet
	NetworkLibraTestnet Network = "libra_testnet"
	// Diem Testnet
	NetworkDiemTestnet Network = "diem_testnet"
	// EOS Mainnet
	NetworkEos Network = "eos"
	// TRON Mainnet
	NetworkTron Network = "tron"
	// Binance Smart Chain Mainnet
	NetworkBsc Network = "bsc"
	// Binance Smart Chain Testnet
	NetworkBscTestnet Network = "bsc_testnet"
	// Goerli Ethereum Testnet
	NetworkGoerli Network = "goerli"
	// Beacon Chain Ethereum 2.0
	NetworkEth2 Network = "eth2"
	// Medalla Ethereum 2.0 Beacon Testnet
	NetworkMedalla Network = "medalla"
	// Filecoin Mainnet
	NetworkFilecoin Network = "filecoin"
	// Hedera Hashgraph
	NetworkHedera Network = "hedera"
	// Solana Mainnet
	NetworkSolana Network = "solana"
	// Matic (Polygon) Mainnet
	NetworkMatic Network = "matic"
	// Velas Mainnet
	NetworkVelas Network = "velas"
	// Velas Testnet
	NetworkVelasTestnet Network = "velas_testnet"
	// Klaytn Mainnet
	NetworkKlaytn Network = "klaytn"
	// Elrond Mainnet
	NetworkElrond Network = "elrond"
)

var AllNetwork = []Network{
	NetworkEthereum,
	NetworkEthclassic,
	NetworkEthclassicReorg,
	NetworkBinance,
	NetworkCeloAlfajores,
	NetworkCeloBaklava,
	NetworkCeloRc1,
	NetworkBitcoin,
	NetworkBitcash,
	NetworkBitcoinsv,
	NetworkLitecoin,
	NetworkDash,
	NetworkDogecoin,
	NetworkCardano,
	NetworkZcash,
	NetworkAlgorand,
	NetworkAlgorandTestnet,
	NetworkAlgorandBetanet,
	NetworkConfluxOceanus,
	NetworkConfluxTethys,
	NetworkLibraTestnet,
	NetworkDiemTestnet,
	NetworkEos,
	NetworkTron,
	NetworkBsc,
	NetworkBscTestnet,
	NetworkGoerli,
	NetworkEth2,
	NetworkMedalla,
	NetworkFilecoin,
	NetworkHedera,
	NetworkSolana,
	NetworkMatic,
	NetworkVelas,
	NetworkVelasTestnet,
	NetworkKlaytn,
	NetworkElrond,
}

func (e Network) IsValid() bool {
	switch e {
	case NetworkEthereum, NetworkEthclassic, NetworkEthclassicReorg, NetworkBinance, NetworkCeloAlfajores, NetworkCeloBaklava, NetworkCeloRc1, NetworkBitcoin, NetworkBitcash, NetworkBitcoinsv, NetworkLitecoin, NetworkDash, NetworkDogecoin, NetworkCardano, NetworkZcash, NetworkAlgorand, NetworkAlgorandTestnet, NetworkAlgorandBetanet, NetworkConfluxOceanus, NetworkConfluxTethys, NetworkLibraTestnet, NetworkDiemTestnet, NetworkEos, NetworkTron, NetworkBsc, NetworkBscTestnet, NetworkGoerli, NetworkEth2, NetworkMedalla, NetworkFilecoin, NetworkHedera, NetworkSolana, NetworkMatic, NetworkVelas, NetworkVelasTestnet, NetworkKlaytn, NetworkElrond:
		return true
	}
	return false
}

func (e Network) String() string {
	return string(e)
}

func (e *Network) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Network(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Network", str)
	}
	return nil
}

func (e Network) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PriceAggregateFunction string

const (
	// Maximum
	PriceAggregateFunctionMaximum PriceAggregateFunction = "maximum"
	// Minimum
	PriceAggregateFunctionMinimum PriceAggregateFunction = "minimum"
	// Aggregated over interval
	PriceAggregateFunctionSum PriceAggregateFunction = "sum"
	// Average
	PriceAggregateFunctionAverage PriceAggregateFunction = "average"
	// Median
	PriceAggregateFunctionMedian PriceAggregateFunction = "median"
	// Any value
	PriceAggregateFunctionAny PriceAggregateFunction = "any"
	// Last value
	PriceAggregateFunctionAnyLast PriceAggregateFunction = "anyLast"
)

var AllPriceAggregateFunction = []PriceAggregateFunction{
	PriceAggregateFunctionMaximum,
	PriceAggregateFunctionMinimum,
	PriceAggregateFunctionSum,
	PriceAggregateFunctionAverage,
	PriceAggregateFunctionMedian,
	PriceAggregateFunctionAny,
	PriceAggregateFunctionAnyLast,
}

func (e PriceAggregateFunction) IsValid() bool {
	switch e {
	case PriceAggregateFunctionMaximum, PriceAggregateFunctionMinimum, PriceAggregateFunctionSum, PriceAggregateFunctionAverage, PriceAggregateFunctionMedian, PriceAggregateFunctionAny, PriceAggregateFunctionAnyLast:
		return true
	}
	return false
}

func (e PriceAggregateFunction) String() string {
	return string(e)
}

func (e *PriceAggregateFunction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceAggregateFunction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceAggregateFunction", str)
	}
	return nil
}

func (e PriceAggregateFunction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Protocol string

const (
	// Ethereum
	ProtocolEthereum Protocol = "ethereum"
	// Binance DEX
	ProtocolBinance Protocol = "binance"
	// Bitcoin
	ProtocolBitcoin Protocol = "bitcoin"
	// Algorand
	ProtocolAlgorand Protocol = "algorand"
	// Libra
	ProtocolLibra Protocol = "libra"
	// EOS
	ProtocolEos Protocol = "eos"
	// Tron
	ProtocolTron Protocol = "tron"
	// Filecoin
	ProtocolFilecoin Protocol = "filecoin"
	// Hedera Hashgraph
	ProtocolHedera Protocol = "hedera"
	// Solana
	ProtocolSolana Protocol = "solana"
	// Cardano
	ProtocolCardano Protocol = "cardano"
	// Elrond
	ProtocolElrond Protocol = "elrond"
)

var AllProtocol = []Protocol{
	ProtocolEthereum,
	ProtocolBinance,
	ProtocolBitcoin,
	ProtocolAlgorand,
	ProtocolLibra,
	ProtocolEos,
	ProtocolTron,
	ProtocolFilecoin,
	ProtocolHedera,
	ProtocolSolana,
	ProtocolCardano,
	ProtocolElrond,
}

func (e Protocol) IsValid() bool {
	switch e {
	case ProtocolEthereum, ProtocolBinance, ProtocolBitcoin, ProtocolAlgorand, ProtocolLibra, ProtocolEos, ProtocolTron, ProtocolFilecoin, ProtocolHedera, ProtocolSolana, ProtocolCardano, ProtocolElrond:
		return true
	}
	return false
}

func (e Protocol) String() string {
	return string(e)
}

func (e *Protocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Protocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Protocol", str)
	}
	return nil
}

func (e Protocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleAccountRootsUniq string

const (
	// Unique time
	RippleAccountRootsUniqTimes RippleAccountRootsUniq = "times"
	// Unique date count
	RippleAccountRootsUniqDates RippleAccountRootsUniq = "dates"
	// Unique Number of block in the blockchains
	RippleAccountRootsUniqBlockHeight RippleAccountRootsUniq = "block_height"
	// Unique currencies
	RippleAccountRootsUniqCurrencies RippleAccountRootsUniq = "currencies"
	// Unique sender
	RippleAccountRootsUniqSender RippleAccountRootsUniq = "sender"
)

var AllRippleAccountRootsUniq = []RippleAccountRootsUniq{
	RippleAccountRootsUniqTimes,
	RippleAccountRootsUniqDates,
	RippleAccountRootsUniqBlockHeight,
	RippleAccountRootsUniqCurrencies,
	RippleAccountRootsUniqSender,
}

func (e RippleAccountRootsUniq) IsValid() bool {
	switch e {
	case RippleAccountRootsUniqTimes, RippleAccountRootsUniqDates, RippleAccountRootsUniqBlockHeight, RippleAccountRootsUniqCurrencies, RippleAccountRootsUniqSender:
		return true
	}
	return false
}

func (e RippleAccountRootsUniq) String() string {
	return string(e)
}

func (e *RippleAccountRootsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleAccountRootsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleAccountRootsUniq", str)
	}
	return nil
}

func (e RippleAccountRootsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleBalancesMeasureable string

const (
	// Date
	RippleBalancesMeasureableDate RippleBalancesMeasureable = "date"
	// Time
	RippleBalancesMeasureableTime RippleBalancesMeasureable = "time"
	// Transaction Hash
	RippleBalancesMeasureableTransactionHash RippleBalancesMeasureable = "transaction_hash"
	// Transaction Sender
	RippleBalancesMeasureableTransactionSender RippleBalancesMeasureable = "transaction_sender"
	// Account
	RippleBalancesMeasureableAccount RippleBalancesMeasureable = "account"
	// Balance
	RippleBalancesMeasureableBalance RippleBalancesMeasureable = "balance"
)

var AllRippleBalancesMeasureable = []RippleBalancesMeasureable{
	RippleBalancesMeasureableDate,
	RippleBalancesMeasureableTime,
	RippleBalancesMeasureableTransactionHash,
	RippleBalancesMeasureableTransactionSender,
	RippleBalancesMeasureableAccount,
	RippleBalancesMeasureableBalance,
}

func (e RippleBalancesMeasureable) IsValid() bool {
	switch e {
	case RippleBalancesMeasureableDate, RippleBalancesMeasureableTime, RippleBalancesMeasureableTransactionHash, RippleBalancesMeasureableTransactionSender, RippleBalancesMeasureableAccount, RippleBalancesMeasureableBalance:
		return true
	}
	return false
}

func (e RippleBalancesMeasureable) String() string {
	return string(e)
}

func (e *RippleBalancesMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleBalancesMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleBalancesMeasureable", str)
	}
	return nil
}

func (e RippleBalancesMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleBalancesUniq string

const (
	// Unique time
	RippleBalancesUniqTimes RippleBalancesUniq = "times"
	// Unique date count
	RippleBalancesUniqDates RippleBalancesUniq = "dates"
	// Unique ledger count
	RippleBalancesUniqLedger RippleBalancesUniq = "ledger"
	// Unique transaction hash count
	RippleBalancesUniqTransactionHash RippleBalancesUniq = "transactionHash"
	// Unique transaction sender count
	RippleBalancesUniqTransactionSender RippleBalancesUniq = "transactionSender"
	// Unique account count
	RippleBalancesUniqAccount RippleBalancesUniq = "account"
	// Unique issuer count
	RippleBalancesUniqIssuer RippleBalancesUniq = "issuer"
)

var AllRippleBalancesUniq = []RippleBalancesUniq{
	RippleBalancesUniqTimes,
	RippleBalancesUniqDates,
	RippleBalancesUniqLedger,
	RippleBalancesUniqTransactionHash,
	RippleBalancesUniqTransactionSender,
	RippleBalancesUniqAccount,
	RippleBalancesUniqIssuer,
}

func (e RippleBalancesUniq) IsValid() bool {
	switch e {
	case RippleBalancesUniqTimes, RippleBalancesUniqDates, RippleBalancesUniqLedger, RippleBalancesUniqTransactionHash, RippleBalancesUniqTransactionSender, RippleBalancesUniqAccount, RippleBalancesUniqIssuer:
		return true
	}
	return false
}

func (e RippleBalancesUniq) String() string {
	return string(e)
}

func (e *RippleBalancesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleBalancesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleBalancesUniq", str)
	}
	return nil
}

func (e RippleBalancesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleBlocksMeasureable string

const (
	// Date
	RippleBlocksMeasureableDate RippleBlocksMeasureable = "date"
	// Time
	RippleBlocksMeasureableTime RippleBlocksMeasureable = "time"
	// Block number
	RippleBlocksMeasureableLedger RippleBlocksMeasureable = "ledger"
	// This serves as a unique identifier for this ledger and all its contents
	RippleBlocksMeasureableLedgerHash RippleBlocksMeasureable = "ledger_hash"
	// The total number of drops of XRP owned by accounts in the ledger
	RippleBlocksMeasureableTotalCoins RippleBlocksMeasureable = "total_coins"
	// Hash of this ledger`s state tree information
	RippleBlocksMeasureableAccountHash RippleBlocksMeasureable = "account_hash"
)

var AllRippleBlocksMeasureable = []RippleBlocksMeasureable{
	RippleBlocksMeasureableDate,
	RippleBlocksMeasureableTime,
	RippleBlocksMeasureableLedger,
	RippleBlocksMeasureableLedgerHash,
	RippleBlocksMeasureableTotalCoins,
	RippleBlocksMeasureableAccountHash,
}

func (e RippleBlocksMeasureable) IsValid() bool {
	switch e {
	case RippleBlocksMeasureableDate, RippleBlocksMeasureableTime, RippleBlocksMeasureableLedger, RippleBlocksMeasureableLedgerHash, RippleBlocksMeasureableTotalCoins, RippleBlocksMeasureableAccountHash:
		return true
	}
	return false
}

func (e RippleBlocksMeasureable) String() string {
	return string(e)
}

func (e *RippleBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleBlocksMeasureable", str)
	}
	return nil
}

func (e RippleBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleBlocksUniq string

const (
	// Unique time
	RippleBlocksUniqTimes RippleBlocksUniq = "times"
	// Unique date count
	RippleBlocksUniqDates RippleBlocksUniq = "dates"
	// Unique blocks
	RippleBlocksUniqLedger RippleBlocksUniq = "ledger"
)

var AllRippleBlocksUniq = []RippleBlocksUniq{
	RippleBlocksUniqTimes,
	RippleBlocksUniqDates,
	RippleBlocksUniqLedger,
}

func (e RippleBlocksUniq) IsValid() bool {
	switch e {
	case RippleBlocksUniqTimes, RippleBlocksUniqDates, RippleBlocksUniqLedger:
		return true
	}
	return false
}

func (e RippleBlocksUniq) String() string {
	return string(e)
}

func (e *RippleBlocksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleBlocksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleBlocksUniq", str)
	}
	return nil
}

func (e RippleBlocksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleChecksMeasureable string

const (
	// Date
	RippleChecksMeasureableDate RippleChecksMeasureable = "date"
	// Time
	RippleChecksMeasureableTime RippleChecksMeasureable = "time"
	// Number of block in the blockhains
	RippleChecksMeasureableBlockHeight RippleChecksMeasureable = "block_height"
	// Currency Symbol
	RippleChecksMeasureableCurrencySymbol RippleChecksMeasureable = "currency_symbol"
	// Currency Address
	RippleChecksMeasureableCurrencyAddress RippleChecksMeasureable = "currency_address"
	// The sender of the Check. Cashing the Check debits this address`s balance.
	RippleChecksMeasureableSender RippleChecksMeasureable = "sender"
)

var AllRippleChecksMeasureable = []RippleChecksMeasureable{
	RippleChecksMeasureableDate,
	RippleChecksMeasureableTime,
	RippleChecksMeasureableBlockHeight,
	RippleChecksMeasureableCurrencySymbol,
	RippleChecksMeasureableCurrencyAddress,
	RippleChecksMeasureableSender,
}

func (e RippleChecksMeasureable) IsValid() bool {
	switch e {
	case RippleChecksMeasureableDate, RippleChecksMeasureableTime, RippleChecksMeasureableBlockHeight, RippleChecksMeasureableCurrencySymbol, RippleChecksMeasureableCurrencyAddress, RippleChecksMeasureableSender:
		return true
	}
	return false
}

func (e RippleChecksMeasureable) String() string {
	return string(e)
}

func (e *RippleChecksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleChecksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleChecksMeasureable", str)
	}
	return nil
}

func (e RippleChecksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleChecksUniq string

const (
	// Unique time
	RippleChecksUniqTimes RippleChecksUniq = "times"
	// Unique date count
	RippleChecksUniqDates RippleChecksUniq = "dates"
	// Unique Number of block in the blockchains
	RippleChecksUniqBlockHeight RippleChecksUniq = "block_height"
	// Unique currencies
	RippleChecksUniqCurrencies RippleChecksUniq = "currencies"
	// Unique sender
	RippleChecksUniqSender RippleChecksUniq = "sender"
	// Unique destination
	RippleChecksUniqDestination RippleChecksUniq = "destination"
)

var AllRippleChecksUniq = []RippleChecksUniq{
	RippleChecksUniqTimes,
	RippleChecksUniqDates,
	RippleChecksUniqBlockHeight,
	RippleChecksUniqCurrencies,
	RippleChecksUniqSender,
	RippleChecksUniqDestination,
}

func (e RippleChecksUniq) IsValid() bool {
	switch e {
	case RippleChecksUniqTimes, RippleChecksUniqDates, RippleChecksUniqBlockHeight, RippleChecksUniqCurrencies, RippleChecksUniqSender, RippleChecksUniqDestination:
		return true
	}
	return false
}

func (e RippleChecksUniq) String() string {
	return string(e)
}

func (e *RippleChecksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleChecksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleChecksUniq", str)
	}
	return nil
}

func (e RippleChecksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleEscrowsMeasureable string

const (
	// Date
	RippleEscrowsMeasureableDate RippleEscrowsMeasureable = "date"
	// Time
	RippleEscrowsMeasureableTime RippleEscrowsMeasureable = "time"
	// Number of block in the blockhains
	RippleEscrowsMeasureableBlockHeight RippleEscrowsMeasureable = "block_height"
	// Currency Symbol
	RippleEscrowsMeasureableCurrencySymbol RippleEscrowsMeasureable = "currency_symbol"
	// Currency Address
	RippleEscrowsMeasureableCurrencyAddress RippleEscrowsMeasureable = "currency_address"
	// The address of the owner (sender) of this held payment
	RippleEscrowsMeasureableSender RippleEscrowsMeasureable = "sender"
)

var AllRippleEscrowsMeasureable = []RippleEscrowsMeasureable{
	RippleEscrowsMeasureableDate,
	RippleEscrowsMeasureableTime,
	RippleEscrowsMeasureableBlockHeight,
	RippleEscrowsMeasureableCurrencySymbol,
	RippleEscrowsMeasureableCurrencyAddress,
	RippleEscrowsMeasureableSender,
}

func (e RippleEscrowsMeasureable) IsValid() bool {
	switch e {
	case RippleEscrowsMeasureableDate, RippleEscrowsMeasureableTime, RippleEscrowsMeasureableBlockHeight, RippleEscrowsMeasureableCurrencySymbol, RippleEscrowsMeasureableCurrencyAddress, RippleEscrowsMeasureableSender:
		return true
	}
	return false
}

func (e RippleEscrowsMeasureable) String() string {
	return string(e)
}

func (e *RippleEscrowsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleEscrowsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleEscrowsMeasureable", str)
	}
	return nil
}

func (e RippleEscrowsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleEscrowsUniq string

const (
	// Unique time
	RippleEscrowsUniqTimes RippleEscrowsUniq = "times"
	// Unique date count
	RippleEscrowsUniqDates RippleEscrowsUniq = "dates"
	// Unique Number of block in the blockchains
	RippleEscrowsUniqBlockHeight RippleEscrowsUniq = "block_height"
	// Unique sender
	RippleEscrowsUniqSender RippleEscrowsUniq = "sender"
	// Unique destination
	RippleEscrowsUniqDestination RippleEscrowsUniq = "destination"
)

var AllRippleEscrowsUniq = []RippleEscrowsUniq{
	RippleEscrowsUniqTimes,
	RippleEscrowsUniqDates,
	RippleEscrowsUniqBlockHeight,
	RippleEscrowsUniqSender,
	RippleEscrowsUniqDestination,
}

func (e RippleEscrowsUniq) IsValid() bool {
	switch e {
	case RippleEscrowsUniqTimes, RippleEscrowsUniqDates, RippleEscrowsUniqBlockHeight, RippleEscrowsUniqSender, RippleEscrowsUniqDestination:
		return true
	}
	return false
}

func (e RippleEscrowsUniq) String() string {
	return string(e)
}

func (e *RippleEscrowsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleEscrowsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleEscrowsUniq", str)
	}
	return nil
}

func (e RippleEscrowsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleNetwork string

const (
	// Ripple XRP Ledger
	RippleNetworkRipple RippleNetwork = "ripple"
)

var AllRippleNetwork = []RippleNetwork{
	RippleNetworkRipple,
}

func (e RippleNetwork) IsValid() bool {
	switch e {
	case RippleNetworkRipple:
		return true
	}
	return false
}

func (e RippleNetwork) String() string {
	return string(e)
}

func (e *RippleNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleNetwork", str)
	}
	return nil
}

func (e RippleNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleOffersMeasureable string

const (
	// Date
	RippleOffersMeasureableDate RippleOffersMeasureable = "date"
	// Time
	RippleOffersMeasureableTime RippleOffersMeasureable = "time"
	// Transaction Hash
	RippleOffersMeasureableTransactionHash RippleOffersMeasureable = "transaction_hash"
	// Transaction Sender
	RippleOffersMeasureableTransactionSender RippleOffersMeasureable = "transaction_sender"
	// Transaction Type
	RippleOffersMeasureableTransactionType RippleOffersMeasureable = "transaction_type"
	// Taker Gets Currency Symbol
	RippleOffersMeasureableTakerGetsCurrencySymbol RippleOffersMeasureable = "taker_gets_currency_symbol"
	// Taker Gets Currency Address
	RippleOffersMeasureableTakerGetsCurrencyAddress RippleOffersMeasureable = "taker_gets_currency_address"
	// Taker Pays Currency Symbol
	RippleOffersMeasureableTakerPaysCurrencySymbol RippleOffersMeasureable = "taker_pays_currency_symbol"
	// Taker Pays Currency Address
	RippleOffersMeasureableTakerPaysCurrencyAddress RippleOffersMeasureable = "taker_pays_currency_address"
)

var AllRippleOffersMeasureable = []RippleOffersMeasureable{
	RippleOffersMeasureableDate,
	RippleOffersMeasureableTime,
	RippleOffersMeasureableTransactionHash,
	RippleOffersMeasureableTransactionSender,
	RippleOffersMeasureableTransactionType,
	RippleOffersMeasureableTakerGetsCurrencySymbol,
	RippleOffersMeasureableTakerGetsCurrencyAddress,
	RippleOffersMeasureableTakerPaysCurrencySymbol,
	RippleOffersMeasureableTakerPaysCurrencyAddress,
}

func (e RippleOffersMeasureable) IsValid() bool {
	switch e {
	case RippleOffersMeasureableDate, RippleOffersMeasureableTime, RippleOffersMeasureableTransactionHash, RippleOffersMeasureableTransactionSender, RippleOffersMeasureableTransactionType, RippleOffersMeasureableTakerGetsCurrencySymbol, RippleOffersMeasureableTakerGetsCurrencyAddress, RippleOffersMeasureableTakerPaysCurrencySymbol, RippleOffersMeasureableTakerPaysCurrencyAddress:
		return true
	}
	return false
}

func (e RippleOffersMeasureable) String() string {
	return string(e)
}

func (e *RippleOffersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleOffersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleOffersMeasureable", str)
	}
	return nil
}

func (e RippleOffersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleOffersUniq string

const (
	// Unique time
	RippleOffersUniqTimes RippleOffersUniq = "times"
	// Unique date count
	RippleOffersUniqDates RippleOffersUniq = "dates"
	// Uniq transaction hash
	RippleOffersUniqTransactionHash RippleOffersUniq = "transaction_hash"
	// Uniq transaction sender
	RippleOffersUniqTransactionSender RippleOffersUniq = "transaction_sender"
)

var AllRippleOffersUniq = []RippleOffersUniq{
	RippleOffersUniqTimes,
	RippleOffersUniqDates,
	RippleOffersUniqTransactionHash,
	RippleOffersUniqTransactionSender,
}

func (e RippleOffersUniq) IsValid() bool {
	switch e {
	case RippleOffersUniqTimes, RippleOffersUniqDates, RippleOffersUniqTransactionHash, RippleOffersUniqTransactionSender:
		return true
	}
	return false
}

func (e RippleOffersUniq) String() string {
	return string(e)
}

func (e *RippleOffersUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleOffersUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleOffersUniq", str)
	}
	return nil
}

func (e RippleOffersUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RipplePaymentsMeasureable string

const (
	// Date
	RipplePaymentsMeasureableDate RipplePaymentsMeasureable = "date"
	// Time
	RipplePaymentsMeasureableTime RipplePaymentsMeasureable = "time"
	// Transaction Hash
	RipplePaymentsMeasureableTransactionHash RipplePaymentsMeasureable = "transaction_hash"
	// Transfer From
	RipplePaymentsMeasureableTransferFrom RipplePaymentsMeasureable = "transfer_from"
	// Transfer To
	RipplePaymentsMeasureableTransferTo RipplePaymentsMeasureable = "transfer_to"
	// Amount Value
	RipplePaymentsMeasureableAmountValue RipplePaymentsMeasureable = "amount_value"
	// Amount Currency Symbol
	RipplePaymentsMeasureableAmountCurrencySymbol RipplePaymentsMeasureable = "amount_currency_symbol"
	// Amount Currency Address
	RipplePaymentsMeasureableAmountCurrencyAddress RipplePaymentsMeasureable = "amount_currency_address"
	// Delivered Currency Symbol
	RipplePaymentsMeasureableDeliveredCurrencySymbol RipplePaymentsMeasureable = "delivered_currency_symbol"
	// Delivered Currency Address
	RipplePaymentsMeasureableDeliveredCurrencyAddress RipplePaymentsMeasureable = "delivered_currency_address"
	// Send max Currency Symbol
	RipplePaymentsMeasureableSendMaxCurrencySymbol RipplePaymentsMeasureable = "send_max_currency_symbol"
	// Send max Currency Address
	RipplePaymentsMeasureableSendMaxCurrencyAddress RipplePaymentsMeasureable = "send_max_currency_address"
	// Delivered Min Currency Symbol
	RipplePaymentsMeasureableDeliverMinCurrencySymbol RipplePaymentsMeasureable = "deliver_min_currency_symbol"
	// Delivered Min Currency Address
	RipplePaymentsMeasureableDeliverMinCurrencyAddress RipplePaymentsMeasureable = "deliver_min_currency_address"
)

var AllRipplePaymentsMeasureable = []RipplePaymentsMeasureable{
	RipplePaymentsMeasureableDate,
	RipplePaymentsMeasureableTime,
	RipplePaymentsMeasureableTransactionHash,
	RipplePaymentsMeasureableTransferFrom,
	RipplePaymentsMeasureableTransferTo,
	RipplePaymentsMeasureableAmountValue,
	RipplePaymentsMeasureableAmountCurrencySymbol,
	RipplePaymentsMeasureableAmountCurrencyAddress,
	RipplePaymentsMeasureableDeliveredCurrencySymbol,
	RipplePaymentsMeasureableDeliveredCurrencyAddress,
	RipplePaymentsMeasureableSendMaxCurrencySymbol,
	RipplePaymentsMeasureableSendMaxCurrencyAddress,
	RipplePaymentsMeasureableDeliverMinCurrencySymbol,
	RipplePaymentsMeasureableDeliverMinCurrencyAddress,
}

func (e RipplePaymentsMeasureable) IsValid() bool {
	switch e {
	case RipplePaymentsMeasureableDate, RipplePaymentsMeasureableTime, RipplePaymentsMeasureableTransactionHash, RipplePaymentsMeasureableTransferFrom, RipplePaymentsMeasureableTransferTo, RipplePaymentsMeasureableAmountValue, RipplePaymentsMeasureableAmountCurrencySymbol, RipplePaymentsMeasureableAmountCurrencyAddress, RipplePaymentsMeasureableDeliveredCurrencySymbol, RipplePaymentsMeasureableDeliveredCurrencyAddress, RipplePaymentsMeasureableSendMaxCurrencySymbol, RipplePaymentsMeasureableSendMaxCurrencyAddress, RipplePaymentsMeasureableDeliverMinCurrencySymbol, RipplePaymentsMeasureableDeliverMinCurrencyAddress:
		return true
	}
	return false
}

func (e RipplePaymentsMeasureable) String() string {
	return string(e)
}

func (e *RipplePaymentsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RipplePaymentsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RipplePaymentsMeasureable", str)
	}
	return nil
}

func (e RipplePaymentsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RipplePaymentsUniq string

const (
	// Unique time
	RipplePaymentsUniqTimes RipplePaymentsUniq = "times"
	// Unique date count
	RipplePaymentsUniqDates RipplePaymentsUniq = "dates"
	// Unique blocks
	RipplePaymentsUniqLedger RipplePaymentsUniq = "ledger"
	// Unique transfer from
	RipplePaymentsUniqTransferFrom RipplePaymentsUniq = "transfer_from"
	// Unique transfer to
	RipplePaymentsUniqTransferTo RipplePaymentsUniq = "transfer_to"
)

var AllRipplePaymentsUniq = []RipplePaymentsUniq{
	RipplePaymentsUniqTimes,
	RipplePaymentsUniqDates,
	RipplePaymentsUniqLedger,
	RipplePaymentsUniqTransferFrom,
	RipplePaymentsUniqTransferTo,
}

func (e RipplePaymentsUniq) IsValid() bool {
	switch e {
	case RipplePaymentsUniqTimes, RipplePaymentsUniqDates, RipplePaymentsUniqLedger, RipplePaymentsUniqTransferFrom, RipplePaymentsUniqTransferTo:
		return true
	}
	return false
}

func (e RipplePaymentsUniq) String() string {
	return string(e)
}

func (e *RipplePaymentsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RipplePaymentsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RipplePaymentsUniq", str)
	}
	return nil
}

func (e RipplePaymentsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleRippleStatesMeasureable string

const (
	// Date
	RippleRippleStatesMeasureableDate RippleRippleStatesMeasureable = "date"
	// Time
	RippleRippleStatesMeasureableTime RippleRippleStatesMeasureable = "time"
	// Number of block in the blockhains
	RippleRippleStatesMeasureableBlockHeight RippleRippleStatesMeasureable = "block_height"
	// Currency Symbol
	RippleRippleStatesMeasureableCurrencySymbol RippleRippleStatesMeasureable = "currency_symbol"
	// Currency Address
	RippleRippleStatesMeasureableCurrencyAddress RippleRippleStatesMeasureable = "currency_address"
	// The address of the owner (sender) of this held payment
	RippleRippleStatesMeasureableSender RippleRippleStatesMeasureable = "sender"
	// Low Account
	RippleRippleStatesMeasureableLowAccount RippleRippleStatesMeasureable = "low_account"
	// High Account
	RippleRippleStatesMeasureableHighAccount RippleRippleStatesMeasureable = "high_account"
)

var AllRippleRippleStatesMeasureable = []RippleRippleStatesMeasureable{
	RippleRippleStatesMeasureableDate,
	RippleRippleStatesMeasureableTime,
	RippleRippleStatesMeasureableBlockHeight,
	RippleRippleStatesMeasureableCurrencySymbol,
	RippleRippleStatesMeasureableCurrencyAddress,
	RippleRippleStatesMeasureableSender,
	RippleRippleStatesMeasureableLowAccount,
	RippleRippleStatesMeasureableHighAccount,
}

func (e RippleRippleStatesMeasureable) IsValid() bool {
	switch e {
	case RippleRippleStatesMeasureableDate, RippleRippleStatesMeasureableTime, RippleRippleStatesMeasureableBlockHeight, RippleRippleStatesMeasureableCurrencySymbol, RippleRippleStatesMeasureableCurrencyAddress, RippleRippleStatesMeasureableSender, RippleRippleStatesMeasureableLowAccount, RippleRippleStatesMeasureableHighAccount:
		return true
	}
	return false
}

func (e RippleRippleStatesMeasureable) String() string {
	return string(e)
}

func (e *RippleRippleStatesMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleRippleStatesMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleRippleStatesMeasureable", str)
	}
	return nil
}

func (e RippleRippleStatesMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleRippleStatesUniq string

const (
	// Unique time
	RippleRippleStatesUniqTimes RippleRippleStatesUniq = "times"
	// Unique date count
	RippleRippleStatesUniqDates RippleRippleStatesUniq = "dates"
	// Unique Number of block in the blockchains
	RippleRippleStatesUniqBlockHeight RippleRippleStatesUniq = "block_height"
	// Unique currencies
	RippleRippleStatesUniqCurrencies RippleRippleStatesUniq = "currencies"
	// Unique sender
	RippleRippleStatesUniqSender RippleRippleStatesUniq = "sender"
	// Unique Lower Account
	RippleRippleStatesUniqLowerAccount RippleRippleStatesUniq = "lower_account"
	// Unique High Account
	RippleRippleStatesUniqHighAccount RippleRippleStatesUniq = "high_account"
)

var AllRippleRippleStatesUniq = []RippleRippleStatesUniq{
	RippleRippleStatesUniqTimes,
	RippleRippleStatesUniqDates,
	RippleRippleStatesUniqBlockHeight,
	RippleRippleStatesUniqCurrencies,
	RippleRippleStatesUniqSender,
	RippleRippleStatesUniqLowerAccount,
	RippleRippleStatesUniqHighAccount,
}

func (e RippleRippleStatesUniq) IsValid() bool {
	switch e {
	case RippleRippleStatesUniqTimes, RippleRippleStatesUniqDates, RippleRippleStatesUniqBlockHeight, RippleRippleStatesUniqCurrencies, RippleRippleStatesUniqSender, RippleRippleStatesUniqLowerAccount, RippleRippleStatesUniqHighAccount:
		return true
	}
	return false
}

func (e RippleRippleStatesUniq) String() string {
	return string(e)
}

func (e *RippleRippleStatesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleRippleStatesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleRippleStatesUniq", str)
	}
	return nil
}

func (e RippleRippleStatesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleTransactionsMeasureable string

const (
	// Date
	RippleTransactionsMeasureableDate RippleTransactionsMeasureable = "date"
	// Time
	RippleTransactionsMeasureableTime RippleTransactionsMeasureable = "time"
	// Transaction Hash
	RippleTransactionsMeasureableTransactionHash RippleTransactionsMeasureable = "transaction_hash"
	// Transaction Fee
	RippleTransactionsMeasureableTransactionFee RippleTransactionsMeasureable = "transaction_fee"
	// Transaction sender
	RippleTransactionsMeasureableSender RippleTransactionsMeasureable = "sender"
)

var AllRippleTransactionsMeasureable = []RippleTransactionsMeasureable{
	RippleTransactionsMeasureableDate,
	RippleTransactionsMeasureableTime,
	RippleTransactionsMeasureableTransactionHash,
	RippleTransactionsMeasureableTransactionFee,
	RippleTransactionsMeasureableSender,
}

func (e RippleTransactionsMeasureable) IsValid() bool {
	switch e {
	case RippleTransactionsMeasureableDate, RippleTransactionsMeasureableTime, RippleTransactionsMeasureableTransactionHash, RippleTransactionsMeasureableTransactionFee, RippleTransactionsMeasureableSender:
		return true
	}
	return false
}

func (e RippleTransactionsMeasureable) String() string {
	return string(e)
}

func (e *RippleTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleTransactionsMeasureable", str)
	}
	return nil
}

func (e RippleTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleTransactionsUniq string

const (
	// Unique time
	RippleTransactionsUniqTimes RippleTransactionsUniq = "times"
	// Unique date count
	RippleTransactionsUniqDates RippleTransactionsUniq = "dates"
	// Unique sender count
	RippleTransactionsUniqSender RippleTransactionsUniq = "sender"
	// Unique ledger count
	RippleTransactionsUniqLedger RippleTransactionsUniq = "ledger"
)

var AllRippleTransactionsUniq = []RippleTransactionsUniq{
	RippleTransactionsUniqTimes,
	RippleTransactionsUniqDates,
	RippleTransactionsUniqSender,
	RippleTransactionsUniqLedger,
}

func (e RippleTransactionsUniq) IsValid() bool {
	switch e {
	case RippleTransactionsUniqTimes, RippleTransactionsUniqDates, RippleTransactionsUniqSender, RippleTransactionsUniqLedger:
		return true
	}
	return false
}

func (e RippleTransactionsUniq) String() string {
	return string(e)
}

func (e *RippleTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleTransactionsUniq", str)
	}
	return nil
}

func (e RippleTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleTransfersMeasureable string

const (
	// Date
	RippleTransfersMeasureableDate RippleTransfersMeasureable = "date"
	// Time
	RippleTransfersMeasureableTime RippleTransfersMeasureable = "time"
	// Number of block in the blockhains
	RippleTransfersMeasureableBlockHeight RippleTransfersMeasureable = "block_height"
	// Currency Symbol of the money sender`s transfer
	RippleTransfersMeasureableCurrencyFromSymbol RippleTransfersMeasureable = "currency_from_symbol"
	// Currency Address of the money sender`s transfer
	RippleTransfersMeasureableCurrencyFromAddress RippleTransfersMeasureable = "currency_from_address"
	// Currency Symbol of the money receiver`s transfer
	RippleTransfersMeasureableCurrencyToSymbol RippleTransfersMeasureable = "currency_to_symbol"
	// Currency Address of the money receiver`s trasfer
	RippleTransfersMeasureableCurrencyToAddress RippleTransfersMeasureable = "currency_to_address"
	// The sender of the payment
	RippleTransfersMeasureableSender RippleTransfersMeasureable = "sender"
	// Transfer From
	RippleTransfersMeasureableTransferFrom RippleTransfersMeasureable = "transfer_from"
	// Transfer To
	RippleTransfersMeasureableTransferTo RippleTransfersMeasureable = "transfer_to"
	// Value From
	RippleTransfersMeasureableValueFrom RippleTransfersMeasureable = "value_from"
	// Value To
	RippleTransfersMeasureableValueTo RippleTransfersMeasureable = "value_to"
)

var AllRippleTransfersMeasureable = []RippleTransfersMeasureable{
	RippleTransfersMeasureableDate,
	RippleTransfersMeasureableTime,
	RippleTransfersMeasureableBlockHeight,
	RippleTransfersMeasureableCurrencyFromSymbol,
	RippleTransfersMeasureableCurrencyFromAddress,
	RippleTransfersMeasureableCurrencyToSymbol,
	RippleTransfersMeasureableCurrencyToAddress,
	RippleTransfersMeasureableSender,
	RippleTransfersMeasureableTransferFrom,
	RippleTransfersMeasureableTransferTo,
	RippleTransfersMeasureableValueFrom,
	RippleTransfersMeasureableValueTo,
}

func (e RippleTransfersMeasureable) IsValid() bool {
	switch e {
	case RippleTransfersMeasureableDate, RippleTransfersMeasureableTime, RippleTransfersMeasureableBlockHeight, RippleTransfersMeasureableCurrencyFromSymbol, RippleTransfersMeasureableCurrencyFromAddress, RippleTransfersMeasureableCurrencyToSymbol, RippleTransfersMeasureableCurrencyToAddress, RippleTransfersMeasureableSender, RippleTransfersMeasureableTransferFrom, RippleTransfersMeasureableTransferTo, RippleTransfersMeasureableValueFrom, RippleTransfersMeasureableValueTo:
		return true
	}
	return false
}

func (e RippleTransfersMeasureable) String() string {
	return string(e)
}

func (e *RippleTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleTransfersMeasureable", str)
	}
	return nil
}

func (e RippleTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleTransfersUniq string

const (
	// Unique time
	RippleTransfersUniqTimes RippleTransfersUniq = "times"
	// Unique date count
	RippleTransfersUniqDates RippleTransfersUniq = "dates"
	// Unique Number of block in the blockchains
	RippleTransfersUniqBlockHeight RippleTransfersUniq = "block_height"
	// Unique currencies
	RippleTransfersUniqCurrencies RippleTransfersUniq = "currencies"
	// Unique sender
	RippleTransfersUniqSender RippleTransfersUniq = "sender"
	// Unique destination
	RippleTransfersUniqDestination RippleTransfersUniq = "destination"
)

var AllRippleTransfersUniq = []RippleTransfersUniq{
	RippleTransfersUniqTimes,
	RippleTransfersUniqDates,
	RippleTransfersUniqBlockHeight,
	RippleTransfersUniqCurrencies,
	RippleTransfersUniqSender,
	RippleTransfersUniqDestination,
}

func (e RippleTransfersUniq) IsValid() bool {
	switch e {
	case RippleTransfersUniqTimes, RippleTransfersUniqDates, RippleTransfersUniqBlockHeight, RippleTransfersUniqCurrencies, RippleTransfersUniqSender, RippleTransfersUniqDestination:
		return true
	}
	return false
}

func (e RippleTransfersUniq) String() string {
	return string(e)
}

func (e *RippleTransfersUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleTransfersUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleTransfersUniq", str)
	}
	return nil
}

func (e RippleTransfersUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RippleccountRootsMeasureable string

const (
	// Date
	RippleccountRootsMeasureableDate RippleccountRootsMeasureable = "date"
	// Time
	RippleccountRootsMeasureableTime RippleccountRootsMeasureable = "time"
	// Number of block in the blockhains
	RippleccountRootsMeasureableBlockHeight RippleccountRootsMeasureable = "block_height"
	// The identifying (classic) address of this account.
	RippleccountRootsMeasureableAccount RippleccountRootsMeasureable = "account"
)

var AllRippleccountRootsMeasureable = []RippleccountRootsMeasureable{
	RippleccountRootsMeasureableDate,
	RippleccountRootsMeasureableTime,
	RippleccountRootsMeasureableBlockHeight,
	RippleccountRootsMeasureableAccount,
}

func (e RippleccountRootsMeasureable) IsValid() bool {
	switch e {
	case RippleccountRootsMeasureableDate, RippleccountRootsMeasureableTime, RippleccountRootsMeasureableBlockHeight, RippleccountRootsMeasureableAccount:
		return true
	}
	return false
}

func (e RippleccountRootsMeasureable) String() string {
	return string(e)
}

func (e *RippleccountRootsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RippleccountRootsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RippleccountRootsMeasureable", str)
	}
	return nil
}

func (e RippleccountRootsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScriptTypeSelectorSelector string

const (
	// Unknown Transaction
	ScriptTypeSelectorSelectorUnknownTransaction ScriptTypeSelectorSelector = "unknown_transaction"
	// Peer-to-peer
	ScriptTypeSelectorSelectorPeerToPeerTransaction ScriptTypeSelectorSelector = "peer_to_peer_transaction"
)

var AllScriptTypeSelectorSelector = []ScriptTypeSelectorSelector{
	ScriptTypeSelectorSelectorUnknownTransaction,
	ScriptTypeSelectorSelectorPeerToPeerTransaction,
}

func (e ScriptTypeSelectorSelector) IsValid() bool {
	switch e {
	case ScriptTypeSelectorSelectorUnknownTransaction, ScriptTypeSelectorSelectorPeerToPeerTransaction:
		return true
	}
	return false
}

func (e ScriptTypeSelectorSelector) String() string {
	return string(e)
}

func (e *ScriptTypeSelectorSelector) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScriptTypeSelectorSelector(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScriptTypeSelectorSelector", str)
	}
	return nil
}

func (e ScriptTypeSelectorSelector) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SignatureTypeSelector string

const (
	// Smart contract method
	SignatureTypeSelectorFunction SignatureTypeSelector = "Function"
	// Smart contract event
	SignatureTypeSelectorEvent SignatureTypeSelector = "Event"
)

var AllSignatureTypeSelector = []SignatureTypeSelector{
	SignatureTypeSelectorFunction,
	SignatureTypeSelectorEvent,
}

func (e SignatureTypeSelector) IsValid() bool {
	switch e {
	case SignatureTypeSelectorFunction, SignatureTypeSelectorEvent:
		return true
	}
	return false
}

func (e SignatureTypeSelector) String() string {
	return string(e)
}

func (e *SignatureTypeSelector) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SignatureTypeSelector(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SignatureTypeSelector", str)
	}
	return nil
}

func (e SignatureTypeSelector) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SmartContractArgumentsUniq string

const (
	// Unique signatures count
	SmartContractArgumentsUniqSignatures SmartContractArgumentsUniq = "signatures"
	// Unique values
	SmartContractArgumentsUniqValues SmartContractArgumentsUniq = "values"
	// Calls or events
	SmartContractArgumentsUniqCalls SmartContractArgumentsUniq = "calls"
	// Unique transactions count
	SmartContractArgumentsUniqTxs SmartContractArgumentsUniq = "txs"
	// Unique transaction senders
	SmartContractArgumentsUniqSenders SmartContractArgumentsUniq = "senders"
	// Unique callers count
	SmartContractArgumentsUniqCallers SmartContractArgumentsUniq = "callers"
	// Unique smart contracts count
	SmartContractArgumentsUniqSmartContracts SmartContractArgumentsUniq = "smart_contracts"
	// Unique blocks
	SmartContractArgumentsUniqBlocks SmartContractArgumentsUniq = "blocks"
	// Unique date count
	SmartContractArgumentsUniqDates SmartContractArgumentsUniq = "dates"
)

var AllSmartContractArgumentsUniq = []SmartContractArgumentsUniq{
	SmartContractArgumentsUniqSignatures,
	SmartContractArgumentsUniqValues,
	SmartContractArgumentsUniqCalls,
	SmartContractArgumentsUniqTxs,
	SmartContractArgumentsUniqSenders,
	SmartContractArgumentsUniqCallers,
	SmartContractArgumentsUniqSmartContracts,
	SmartContractArgumentsUniqBlocks,
	SmartContractArgumentsUniqDates,
}

func (e SmartContractArgumentsUniq) IsValid() bool {
	switch e {
	case SmartContractArgumentsUniqSignatures, SmartContractArgumentsUniqValues, SmartContractArgumentsUniqCalls, SmartContractArgumentsUniqTxs, SmartContractArgumentsUniqSenders, SmartContractArgumentsUniqCallers, SmartContractArgumentsUniqSmartContracts, SmartContractArgumentsUniqBlocks, SmartContractArgumentsUniqDates:
		return true
	}
	return false
}

func (e SmartContractArgumentsUniq) String() string {
	return string(e)
}

func (e *SmartContractArgumentsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SmartContractArgumentsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SmartContractArgumentsUniq", str)
	}
	return nil
}

func (e SmartContractArgumentsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SmartContractCallsUniq string

const (
	// Calls
	SmartContractCallsUniqCalls SmartContractCallsUniq = "calls"
	// Unique transactions count
	SmartContractCallsUniqTxs SmartContractCallsUniq = "txs"
	// Unique transaction senders
	SmartContractCallsUniqSenders SmartContractCallsUniq = "senders"
	// Unique callers count
	SmartContractCallsUniqCallers SmartContractCallsUniq = "callers"
	// Unique smart contracts count
	SmartContractCallsUniqSmartContracts SmartContractCallsUniq = "smart_contracts"
	// Unique smart contract methods count
	SmartContractCallsUniqSmartContractMethods SmartContractCallsUniq = "smart_contract_methods"
	// Unique blocks
	SmartContractCallsUniqBlocks SmartContractCallsUniq = "blocks"
	// Unique date count
	SmartContractCallsUniqDates SmartContractCallsUniq = "dates"
)

var AllSmartContractCallsUniq = []SmartContractCallsUniq{
	SmartContractCallsUniqCalls,
	SmartContractCallsUniqTxs,
	SmartContractCallsUniqSenders,
	SmartContractCallsUniqCallers,
	SmartContractCallsUniqSmartContracts,
	SmartContractCallsUniqSmartContractMethods,
	SmartContractCallsUniqBlocks,
	SmartContractCallsUniqDates,
}

func (e SmartContractCallsUniq) IsValid() bool {
	switch e {
	case SmartContractCallsUniqCalls, SmartContractCallsUniqTxs, SmartContractCallsUniqSenders, SmartContractCallsUniqCallers, SmartContractCallsUniqSmartContracts, SmartContractCallsUniqSmartContractMethods, SmartContractCallsUniqBlocks, SmartContractCallsUniqDates:
		return true
	}
	return false
}

func (e SmartContractCallsUniq) String() string {
	return string(e)
}

func (e *SmartContractCallsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SmartContractCallsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SmartContractCallsUniq", str)
	}
	return nil
}

func (e SmartContractCallsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SmartContractEventsUniq string

const (
	// Unique callers count
	SmartContractEventsUniqTxTo SmartContractEventsUniq = "tx_to"
	// Unique transaction senders
	SmartContractEventsUniqTxFrom SmartContractEventsUniq = "tx_from"
	// Unique transactions count
	SmartContractEventsUniqTxs SmartContractEventsUniq = "txs"
	// Unique smart contracts count
	SmartContractEventsUniqSmartContracts SmartContractEventsUniq = "smart_contracts"
	// Unique smart contract methods count
	SmartContractEventsUniqSmartContractMethods SmartContractEventsUniq = "smart_contract_methods"
	// Unique blocks
	SmartContractEventsUniqBlocks SmartContractEventsUniq = "blocks"
	// Unique date count
	SmartContractEventsUniqDates SmartContractEventsUniq = "dates"
)

var AllSmartContractEventsUniq = []SmartContractEventsUniq{
	SmartContractEventsUniqTxTo,
	SmartContractEventsUniqTxFrom,
	SmartContractEventsUniqTxs,
	SmartContractEventsUniqSmartContracts,
	SmartContractEventsUniqSmartContractMethods,
	SmartContractEventsUniqBlocks,
	SmartContractEventsUniqDates,
}

func (e SmartContractEventsUniq) IsValid() bool {
	switch e {
	case SmartContractEventsUniqTxTo, SmartContractEventsUniqTxFrom, SmartContractEventsUniqTxs, SmartContractEventsUniqSmartContracts, SmartContractEventsUniqSmartContractMethods, SmartContractEventsUniqBlocks, SmartContractEventsUniqDates:
		return true
	}
	return false
}

func (e SmartContractEventsUniq) String() string {
	return string(e)
}

func (e *SmartContractEventsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SmartContractEventsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SmartContractEventsUniq", str)
	}
	return nil
}

func (e SmartContractEventsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SmartContractType string

const (
	// Not A Smart contract
	SmartContractTypeNone SmartContractType = "None"
	// General Purpose Smart contract
	SmartContractTypeGeneric SmartContractType = "Generic"
	// Smart contract for token derivatives
	SmartContractTypeMarginPositionToken SmartContractType = "MarginPositionToken"
	// Multi signature wallet
	SmartContractTypeMultisig SmartContractType = "Multisig"
	// Token
	SmartContractTypeToken SmartContractType = "Token"
	// Token Sale
	SmartContractTypeTokenSale SmartContractType = "TokenSale"
	// Decentralized exchange
	SmartContractTypeDex SmartContractType = "DEX"
	// Transaction Execution Approval Language
	SmartContractTypeTeal SmartContractType = "TEAL"
)

var AllSmartContractType = []SmartContractType{
	SmartContractTypeNone,
	SmartContractTypeGeneric,
	SmartContractTypeMarginPositionToken,
	SmartContractTypeMultisig,
	SmartContractTypeToken,
	SmartContractTypeTokenSale,
	SmartContractTypeDex,
	SmartContractTypeTeal,
}

func (e SmartContractType) IsValid() bool {
	switch e {
	case SmartContractTypeNone, SmartContractTypeGeneric, SmartContractTypeMarginPositionToken, SmartContractTypeMultisig, SmartContractTypeToken, SmartContractTypeTokenSale, SmartContractTypeDex, SmartContractTypeTeal:
		return true
	}
	return false
}

func (e SmartContractType) String() string {
	return string(e)
}

func (e *SmartContractType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SmartContractType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SmartContractType", str)
	}
	return nil
}

func (e SmartContractType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaBlockMeasureable string

const (
	// Date
	SolanaBlockMeasureableDate SolanaBlockMeasureable = "date"
	// Time
	SolanaBlockMeasureableTime SolanaBlockMeasureable = "time"
	// Hash of the the block
	SolanaBlockMeasureableBlockHash SolanaBlockMeasureable = "block_hash"
	// Number of block in the blockhains
	SolanaBlockMeasureableHeight SolanaBlockMeasureable = "height"
	// The block hash of this block`s parent
	SolanaBlockMeasureablePreviousBlockHash SolanaBlockMeasureable = "previous_block_hash"
	// Number of reward lamports credited or debited by the account
	SolanaBlockMeasureableRewards SolanaBlockMeasureable = "rewards"
	// The slot index of this block`s parent
	SolanaBlockMeasureableParentSlot SolanaBlockMeasureable = "parent_slot"
	// Count of transactions in this block
	SolanaBlockMeasureableTransactionCount SolanaBlockMeasureable = "transaction_count"
)

var AllSolanaBlockMeasureable = []SolanaBlockMeasureable{
	SolanaBlockMeasureableDate,
	SolanaBlockMeasureableTime,
	SolanaBlockMeasureableBlockHash,
	SolanaBlockMeasureableHeight,
	SolanaBlockMeasureablePreviousBlockHash,
	SolanaBlockMeasureableRewards,
	SolanaBlockMeasureableParentSlot,
	SolanaBlockMeasureableTransactionCount,
}

func (e SolanaBlockMeasureable) IsValid() bool {
	switch e {
	case SolanaBlockMeasureableDate, SolanaBlockMeasureableTime, SolanaBlockMeasureableBlockHash, SolanaBlockMeasureableHeight, SolanaBlockMeasureablePreviousBlockHash, SolanaBlockMeasureableRewards, SolanaBlockMeasureableParentSlot, SolanaBlockMeasureableTransactionCount:
		return true
	}
	return false
}

func (e SolanaBlockMeasureable) String() string {
	return string(e)
}

func (e *SolanaBlockMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaBlockMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaBlockMeasureable", str)
	}
	return nil
}

func (e SolanaBlockMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaBlockRewardMeasureable string

const (
	// Date
	SolanaBlockRewardMeasureableDate SolanaBlockRewardMeasureable = "date"
	// Time
	SolanaBlockRewardMeasureableTime SolanaBlockRewardMeasureable = "time"
	// Hash of the the block
	SolanaBlockRewardMeasureableBlockHash SolanaBlockRewardMeasureable = "block_hash"
	// Number of block in the blockhains
	SolanaBlockRewardMeasureableHeight SolanaBlockRewardMeasureable = "height"
	// The block hash of this block`s parent
	SolanaBlockRewardMeasureablePreviousBlockHash SolanaBlockRewardMeasureable = "previous_block_hash"
	// Number of reward lamports credited or debited by the account
	SolanaBlockRewardMeasureableAmount SolanaBlockRewardMeasureable = "amount"
	// The slot index of this block`s parent
	SolanaBlockRewardMeasureableParentSlot SolanaBlockRewardMeasureable = "parent_slot"
	// Account balances after the transaction was processed
	SolanaBlockRewardMeasureablePostBalance SolanaBlockRewardMeasureable = "post_balance"
	// Account
	SolanaBlockRewardMeasureableAccount SolanaBlockRewardMeasureable = "account"
)

var AllSolanaBlockRewardMeasureable = []SolanaBlockRewardMeasureable{
	SolanaBlockRewardMeasureableDate,
	SolanaBlockRewardMeasureableTime,
	SolanaBlockRewardMeasureableBlockHash,
	SolanaBlockRewardMeasureableHeight,
	SolanaBlockRewardMeasureablePreviousBlockHash,
	SolanaBlockRewardMeasureableAmount,
	SolanaBlockRewardMeasureableParentSlot,
	SolanaBlockRewardMeasureablePostBalance,
	SolanaBlockRewardMeasureableAccount,
}

func (e SolanaBlockRewardMeasureable) IsValid() bool {
	switch e {
	case SolanaBlockRewardMeasureableDate, SolanaBlockRewardMeasureableTime, SolanaBlockRewardMeasureableBlockHash, SolanaBlockRewardMeasureableHeight, SolanaBlockRewardMeasureablePreviousBlockHash, SolanaBlockRewardMeasureableAmount, SolanaBlockRewardMeasureableParentSlot, SolanaBlockRewardMeasureablePostBalance, SolanaBlockRewardMeasureableAccount:
		return true
	}
	return false
}

func (e SolanaBlockRewardMeasureable) String() string {
	return string(e)
}

func (e *SolanaBlockRewardMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaBlockRewardMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaBlockRewardMeasureable", str)
	}
	return nil
}

func (e SolanaBlockRewardMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaBlockRewardUniq string

const (
	// Unique time
	SolanaBlockRewardUniqTimes SolanaBlockRewardUniq = "times"
	// Unique date count
	SolanaBlockRewardUniqDates SolanaBlockRewardUniq = "dates"
	// Unique hash of the the block
	SolanaBlockRewardUniqBlockHash SolanaBlockRewardUniq = "block_hash"
	// Unique accounts
	SolanaBlockRewardUniqAccount SolanaBlockRewardUniq = "account"
	// Unique currencies
	SolanaBlockRewardUniqCurrencies SolanaBlockRewardUniq = "currencies"
)

var AllSolanaBlockRewardUniq = []SolanaBlockRewardUniq{
	SolanaBlockRewardUniqTimes,
	SolanaBlockRewardUniqDates,
	SolanaBlockRewardUniqBlockHash,
	SolanaBlockRewardUniqAccount,
	SolanaBlockRewardUniqCurrencies,
}

func (e SolanaBlockRewardUniq) IsValid() bool {
	switch e {
	case SolanaBlockRewardUniqTimes, SolanaBlockRewardUniqDates, SolanaBlockRewardUniqBlockHash, SolanaBlockRewardUniqAccount, SolanaBlockRewardUniqCurrencies:
		return true
	}
	return false
}

func (e SolanaBlockRewardUniq) String() string {
	return string(e)
}

func (e *SolanaBlockRewardUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaBlockRewardUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaBlockRewardUniq", str)
	}
	return nil
}

func (e SolanaBlockRewardUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaBlockUniq string

const (
	// Unique time
	SolanaBlockUniqTimes SolanaBlockUniq = "times"
	// Unique date count
	SolanaBlockUniqDates SolanaBlockUniq = "dates"
	// Unique Number of block in the blockchains
	SolanaBlockUniqHeight SolanaBlockUniq = "height"
)

var AllSolanaBlockUniq = []SolanaBlockUniq{
	SolanaBlockUniqTimes,
	SolanaBlockUniqDates,
	SolanaBlockUniqHeight,
}

func (e SolanaBlockUniq) IsValid() bool {
	switch e {
	case SolanaBlockUniqTimes, SolanaBlockUniqDates, SolanaBlockUniqHeight:
		return true
	}
	return false
}

func (e SolanaBlockUniq) String() string {
	return string(e)
}

func (e *SolanaBlockUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaBlockUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaBlockUniq", str)
	}
	return nil
}

func (e SolanaBlockUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaInstructionAccountMeasureable string

const (
	// Date
	SolanaInstructionAccountMeasureableDate SolanaInstructionAccountMeasureable = "date"
	// Time
	SolanaInstructionAccountMeasureableTime SolanaInstructionAccountMeasureable = "time"
	// Hash of the the block
	SolanaInstructionAccountMeasureableBlockHash SolanaInstructionAccountMeasureable = "block_hash"
	// Number of block in the blockhains
	SolanaInstructionAccountMeasureableHeight SolanaInstructionAccountMeasureable = "height"
	// The block hash of this block`s parent
	SolanaInstructionAccountMeasureablePreviousBlockHash SolanaInstructionAccountMeasureable = "previous_block_hash"
	// Transaction Hash
	SolanaInstructionAccountMeasureableSignature SolanaInstructionAccountMeasureable = "signature"
)

var AllSolanaInstructionAccountMeasureable = []SolanaInstructionAccountMeasureable{
	SolanaInstructionAccountMeasureableDate,
	SolanaInstructionAccountMeasureableTime,
	SolanaInstructionAccountMeasureableBlockHash,
	SolanaInstructionAccountMeasureableHeight,
	SolanaInstructionAccountMeasureablePreviousBlockHash,
	SolanaInstructionAccountMeasureableSignature,
}

func (e SolanaInstructionAccountMeasureable) IsValid() bool {
	switch e {
	case SolanaInstructionAccountMeasureableDate, SolanaInstructionAccountMeasureableTime, SolanaInstructionAccountMeasureableBlockHash, SolanaInstructionAccountMeasureableHeight, SolanaInstructionAccountMeasureablePreviousBlockHash, SolanaInstructionAccountMeasureableSignature:
		return true
	}
	return false
}

func (e SolanaInstructionAccountMeasureable) String() string {
	return string(e)
}

func (e *SolanaInstructionAccountMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaInstructionAccountMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaInstructionAccountMeasureable", str)
	}
	return nil
}

func (e SolanaInstructionAccountMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaInstructionAccountUniq string

const (
	// Unique time
	SolanaInstructionAccountUniqTimes SolanaInstructionAccountUniq = "times"
	// Unique date count
	SolanaInstructionAccountUniqDates SolanaInstructionAccountUniq = "dates"
	// Number of block in the blockchains
	SolanaInstructionAccountUniqHeight SolanaInstructionAccountUniq = "height"
	// Transaction Hash
	SolanaInstructionAccountUniqSignature SolanaInstructionAccountUniq = "signature"
	// Account name
	SolanaInstructionAccountUniqAccountName SolanaInstructionAccountUniq = "account_name"
)

var AllSolanaInstructionAccountUniq = []SolanaInstructionAccountUniq{
	SolanaInstructionAccountUniqTimes,
	SolanaInstructionAccountUniqDates,
	SolanaInstructionAccountUniqHeight,
	SolanaInstructionAccountUniqSignature,
	SolanaInstructionAccountUniqAccountName,
}

func (e SolanaInstructionAccountUniq) IsValid() bool {
	switch e {
	case SolanaInstructionAccountUniqTimes, SolanaInstructionAccountUniqDates, SolanaInstructionAccountUniqHeight, SolanaInstructionAccountUniqSignature, SolanaInstructionAccountUniqAccountName:
		return true
	}
	return false
}

func (e SolanaInstructionAccountUniq) String() string {
	return string(e)
}

func (e *SolanaInstructionAccountUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaInstructionAccountUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaInstructionAccountUniq", str)
	}
	return nil
}

func (e SolanaInstructionAccountUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaInstructionMeasureable string

const (
	// Date
	SolanaInstructionMeasureableDate SolanaInstructionMeasureable = "date"
	// Time
	SolanaInstructionMeasureableTime SolanaInstructionMeasureable = "time"
	// Hash of the the block
	SolanaInstructionMeasureableBlockHash SolanaInstructionMeasureable = "block_hash"
	// Number of block in the blockhains
	SolanaInstructionMeasureableHeight SolanaInstructionMeasureable = "height"
	// The block hash of this block`s parent
	SolanaInstructionMeasureablePreviousBlockHash SolanaInstructionMeasureable = "previous_block_hash"
	// Transaction Hash
	SolanaInstructionMeasureableSignature SolanaInstructionMeasureable = "signature"
	// Transaction Fee
	SolanaInstructionMeasureableFee SolanaInstructionMeasureable = "fee"
)

var AllSolanaInstructionMeasureable = []SolanaInstructionMeasureable{
	SolanaInstructionMeasureableDate,
	SolanaInstructionMeasureableTime,
	SolanaInstructionMeasureableBlockHash,
	SolanaInstructionMeasureableHeight,
	SolanaInstructionMeasureablePreviousBlockHash,
	SolanaInstructionMeasureableSignature,
	SolanaInstructionMeasureableFee,
}

func (e SolanaInstructionMeasureable) IsValid() bool {
	switch e {
	case SolanaInstructionMeasureableDate, SolanaInstructionMeasureableTime, SolanaInstructionMeasureableBlockHash, SolanaInstructionMeasureableHeight, SolanaInstructionMeasureablePreviousBlockHash, SolanaInstructionMeasureableSignature, SolanaInstructionMeasureableFee:
		return true
	}
	return false
}

func (e SolanaInstructionMeasureable) String() string {
	return string(e)
}

func (e *SolanaInstructionMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaInstructionMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaInstructionMeasureable", str)
	}
	return nil
}

func (e SolanaInstructionMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaInstructionUniq string

const (
	// Unique time
	SolanaInstructionUniqTimes SolanaInstructionUniq = "times"
	// Unique date count
	SolanaInstructionUniqDates SolanaInstructionUniq = "dates"
	// Number of block in the blockchains
	SolanaInstructionUniqHeight SolanaInstructionUniq = "height"
	// Transaction Hash
	SolanaInstructionUniqSignature SolanaInstructionUniq = "signature"
)

var AllSolanaInstructionUniq = []SolanaInstructionUniq{
	SolanaInstructionUniqTimes,
	SolanaInstructionUniqDates,
	SolanaInstructionUniqHeight,
	SolanaInstructionUniqSignature,
}

func (e SolanaInstructionUniq) IsValid() bool {
	switch e {
	case SolanaInstructionUniqTimes, SolanaInstructionUniqDates, SolanaInstructionUniqHeight, SolanaInstructionUniqSignature:
		return true
	}
	return false
}

func (e SolanaInstructionUniq) String() string {
	return string(e)
}

func (e *SolanaInstructionUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaInstructionUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaInstructionUniq", str)
	}
	return nil
}

func (e SolanaInstructionUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaNetwork string

const (
	// Solana Mainnat
	SolanaNetworkSolana SolanaNetwork = "solana"
)

var AllSolanaNetwork = []SolanaNetwork{
	SolanaNetworkSolana,
}

func (e SolanaNetwork) IsValid() bool {
	switch e {
	case SolanaNetworkSolana:
		return true
	}
	return false
}

func (e SolanaNetwork) String() string {
	return string(e)
}

func (e *SolanaNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaNetwork", str)
	}
	return nil
}

func (e SolanaNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaRewardType string

const (
	// fee type
	SolanaRewardTypeFee SolanaRewardType = "Fee"
	// rent type
	SolanaRewardTypeRent SolanaRewardType = "Rent"
	// voing type
	SolanaRewardTypeVoting SolanaRewardType = "Voting"
	// staking type
	SolanaRewardTypeStaking SolanaRewardType = "Staking"
)

var AllSolanaRewardType = []SolanaRewardType{
	SolanaRewardTypeFee,
	SolanaRewardTypeRent,
	SolanaRewardTypeVoting,
	SolanaRewardTypeStaking,
}

func (e SolanaRewardType) IsValid() bool {
	switch e {
	case SolanaRewardTypeFee, SolanaRewardTypeRent, SolanaRewardTypeVoting, SolanaRewardTypeStaking:
		return true
	}
	return false
}

func (e SolanaRewardType) String() string {
	return string(e)
}

func (e *SolanaRewardType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaRewardType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaRewardType", str)
	}
	return nil
}

func (e SolanaRewardType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaTransactionMeasureable string

const (
	// Date
	SolanaTransactionMeasureableDate SolanaTransactionMeasureable = "date"
	// Time
	SolanaTransactionMeasureableTime SolanaTransactionMeasureable = "time"
	// Hash of the the block
	SolanaTransactionMeasureableBlockHash SolanaTransactionMeasureable = "block_hash"
	// Number of block in the blockhains
	SolanaTransactionMeasureableHeight SolanaTransactionMeasureable = "height"
	// The block hash of this block`s parent
	SolanaTransactionMeasureablePreviousBlockHash SolanaTransactionMeasureable = "previous_block_hash"
	// The slot index of this block`s parent
	SolanaTransactionMeasureableParentSlot SolanaTransactionMeasureable = "parent_slot"
	// Transaction Hash
	SolanaTransactionMeasureableSignature SolanaTransactionMeasureable = "signature"
	// Transaction Fee
	SolanaTransactionMeasureableFee SolanaTransactionMeasureable = "fee"
	// Transaction Fee
	SolanaTransactionMeasureableTransactionFee SolanaTransactionMeasureable = "transaction_fee"
)

var AllSolanaTransactionMeasureable = []SolanaTransactionMeasureable{
	SolanaTransactionMeasureableDate,
	SolanaTransactionMeasureableTime,
	SolanaTransactionMeasureableBlockHash,
	SolanaTransactionMeasureableHeight,
	SolanaTransactionMeasureablePreviousBlockHash,
	SolanaTransactionMeasureableParentSlot,
	SolanaTransactionMeasureableSignature,
	SolanaTransactionMeasureableFee,
	SolanaTransactionMeasureableTransactionFee,
}

func (e SolanaTransactionMeasureable) IsValid() bool {
	switch e {
	case SolanaTransactionMeasureableDate, SolanaTransactionMeasureableTime, SolanaTransactionMeasureableBlockHash, SolanaTransactionMeasureableHeight, SolanaTransactionMeasureablePreviousBlockHash, SolanaTransactionMeasureableParentSlot, SolanaTransactionMeasureableSignature, SolanaTransactionMeasureableFee, SolanaTransactionMeasureableTransactionFee:
		return true
	}
	return false
}

func (e SolanaTransactionMeasureable) String() string {
	return string(e)
}

func (e *SolanaTransactionMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaTransactionMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaTransactionMeasureable", str)
	}
	return nil
}

func (e SolanaTransactionMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaTransactionUniq string

const (
	// Unique time
	SolanaTransactionUniqTimes SolanaTransactionUniq = "times"
	// Unique date count
	SolanaTransactionUniqDates SolanaTransactionUniq = "dates"
	// Number of block in the blockchains
	SolanaTransactionUniqHeight SolanaTransactionUniq = "height"
	// Transaction Hash
	SolanaTransactionUniqSignature SolanaTransactionUniq = "signature"
	// Accounts` public key
	SolanaTransactionUniqSigner SolanaTransactionUniq = "signer"
)

var AllSolanaTransactionUniq = []SolanaTransactionUniq{
	SolanaTransactionUniqTimes,
	SolanaTransactionUniqDates,
	SolanaTransactionUniqHeight,
	SolanaTransactionUniqSignature,
	SolanaTransactionUniqSigner,
}

func (e SolanaTransactionUniq) IsValid() bool {
	switch e {
	case SolanaTransactionUniqTimes, SolanaTransactionUniqDates, SolanaTransactionUniqHeight, SolanaTransactionUniqSignature, SolanaTransactionUniqSigner:
		return true
	}
	return false
}

func (e SolanaTransactionUniq) String() string {
	return string(e)
}

func (e *SolanaTransactionUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaTransactionUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaTransactionUniq", str)
	}
	return nil
}

func (e SolanaTransactionUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaTransferMeasureable string

const (
	// Date
	SolanaTransferMeasureableDate SolanaTransferMeasureable = "date"
	// Time
	SolanaTransferMeasureableTime SolanaTransferMeasureable = "time"
	// Hash of the the block
	SolanaTransferMeasureableBlockHash SolanaTransferMeasureable = "block_hash"
	// Number of block in the blockhains
	SolanaTransferMeasureableHeight SolanaTransferMeasureable = "height"
	// The block hash of this block`s parent
	SolanaTransferMeasureablePreviousBlockHash SolanaTransferMeasureable = "previous_block_hash"
	// Transaction Hash
	SolanaTransferMeasureableSignature SolanaTransferMeasureable = "signature"
	// Transaction Fee
	SolanaTransferMeasureableFeePayer SolanaTransferMeasureable = "fee_payer"
	// Transfer Type
	SolanaTransferMeasureableTransferType SolanaTransferMeasureable = "transfer_type"
	// Amount Transfer
	SolanaTransferMeasureableAmount SolanaTransferMeasureable = "amount"
)

var AllSolanaTransferMeasureable = []SolanaTransferMeasureable{
	SolanaTransferMeasureableDate,
	SolanaTransferMeasureableTime,
	SolanaTransferMeasureableBlockHash,
	SolanaTransferMeasureableHeight,
	SolanaTransferMeasureablePreviousBlockHash,
	SolanaTransferMeasureableSignature,
	SolanaTransferMeasureableFeePayer,
	SolanaTransferMeasureableTransferType,
	SolanaTransferMeasureableAmount,
}

func (e SolanaTransferMeasureable) IsValid() bool {
	switch e {
	case SolanaTransferMeasureableDate, SolanaTransferMeasureableTime, SolanaTransferMeasureableBlockHash, SolanaTransferMeasureableHeight, SolanaTransferMeasureablePreviousBlockHash, SolanaTransferMeasureableSignature, SolanaTransferMeasureableFeePayer, SolanaTransferMeasureableTransferType, SolanaTransferMeasureableAmount:
		return true
	}
	return false
}

func (e SolanaTransferMeasureable) String() string {
	return string(e)
}

func (e *SolanaTransferMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaTransferMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaTransferMeasureable", str)
	}
	return nil
}

func (e SolanaTransferMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaTransferType string

const (
	// Transfer
	SolanaTransferTypeTransfer SolanaTransferType = "transfer"
	// Self
	SolanaTransferTypeSelf SolanaTransferType = "self"
	// Mint
	SolanaTransferTypeMint SolanaTransferType = "mint"
	// Create Account
	SolanaTransferTypeCreateAccount SolanaTransferType = "create_account"
	// Close Account
	SolanaTransferTypeCloseAccount SolanaTransferType = "close_account"
	// Rent Exemption
	SolanaTransferTypeRentExemption SolanaTransferType = "rent_exemption"
	// Stake
	SolanaTransferTypeStake SolanaTransferType = "stake"
	// Stake Withdraw
	SolanaTransferTypeStakeWithdraw SolanaTransferType = "stake_withdraw"
	// Trade Unknown
	SolanaTransferTypeTradeUnknown SolanaTransferType = "trade_unknown"
	// Burn
	SolanaTransferTypeBurn SolanaTransferType = "burn"
	// Vote
	SolanaTransferTypeVote SolanaTransferType = "vote"
	// Nonce Withdraw
	SolanaTransferTypeNonceWithdraw SolanaTransferType = "nonce_withdraw"
)

var AllSolanaTransferType = []SolanaTransferType{
	SolanaTransferTypeTransfer,
	SolanaTransferTypeSelf,
	SolanaTransferTypeMint,
	SolanaTransferTypeCreateAccount,
	SolanaTransferTypeCloseAccount,
	SolanaTransferTypeRentExemption,
	SolanaTransferTypeStake,
	SolanaTransferTypeStakeWithdraw,
	SolanaTransferTypeTradeUnknown,
	SolanaTransferTypeBurn,
	SolanaTransferTypeVote,
	SolanaTransferTypeNonceWithdraw,
}

func (e SolanaTransferType) IsValid() bool {
	switch e {
	case SolanaTransferTypeTransfer, SolanaTransferTypeSelf, SolanaTransferTypeMint, SolanaTransferTypeCreateAccount, SolanaTransferTypeCloseAccount, SolanaTransferTypeRentExemption, SolanaTransferTypeStake, SolanaTransferTypeStakeWithdraw, SolanaTransferTypeTradeUnknown, SolanaTransferTypeBurn, SolanaTransferTypeVote, SolanaTransferTypeNonceWithdraw:
		return true
	}
	return false
}

func (e SolanaTransferType) String() string {
	return string(e)
}

func (e *SolanaTransferType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaTransferType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaTransferType", str)
	}
	return nil
}

func (e SolanaTransferType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SolanaTransferUniq string

const (
	// Unique time
	SolanaTransferUniqTimes SolanaTransferUniq = "times"
	// Unique date count
	SolanaTransferUniqDates SolanaTransferUniq = "dates"
	// Number of block in the blockchains
	SolanaTransferUniqHeight SolanaTransferUniq = "height"
	// Transaction Hash
	SolanaTransferUniqSignature SolanaTransferUniq = "signature"
	// Transfer From
	SolanaTransferUniqSenderAddress SolanaTransferUniq = "sender_address"
	// Transfer To
	SolanaTransferUniqReceiverAddress SolanaTransferUniq = "receiver_address"
)

var AllSolanaTransferUniq = []SolanaTransferUniq{
	SolanaTransferUniqTimes,
	SolanaTransferUniqDates,
	SolanaTransferUniqHeight,
	SolanaTransferUniqSignature,
	SolanaTransferUniqSenderAddress,
	SolanaTransferUniqReceiverAddress,
}

func (e SolanaTransferUniq) IsValid() bool {
	switch e {
	case SolanaTransferUniqTimes, SolanaTransferUniqDates, SolanaTransferUniqHeight, SolanaTransferUniqSignature, SolanaTransferUniqSenderAddress, SolanaTransferUniqReceiverAddress:
		return true
	}
	return false
}

func (e SolanaTransferUniq) String() string {
	return string(e)
}

func (e *SolanaTransferUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SolanaTransferUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SolanaTransferUniq", str)
	}
	return nil
}

func (e SolanaTransferUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StakingTransactionsTypeEnum string

const (
	StakingTransactionsTypeEnumCreateValidator StakingTransactionsTypeEnum = "CreateValidator"
	StakingTransactionsTypeEnumEditValidator   StakingTransactionsTypeEnum = "EditValidator"
	StakingTransactionsTypeEnumCollectRewards  StakingTransactionsTypeEnum = "CollectRewards"
	StakingTransactionsTypeEnumUndelegate      StakingTransactionsTypeEnum = "Undelegate"
	StakingTransactionsTypeEnumDelegate        StakingTransactionsTypeEnum = "Delegate"
)

var AllStakingTransactionsTypeEnum = []StakingTransactionsTypeEnum{
	StakingTransactionsTypeEnumCreateValidator,
	StakingTransactionsTypeEnumEditValidator,
	StakingTransactionsTypeEnumCollectRewards,
	StakingTransactionsTypeEnumUndelegate,
	StakingTransactionsTypeEnumDelegate,
}

func (e StakingTransactionsTypeEnum) IsValid() bool {
	switch e {
	case StakingTransactionsTypeEnumCreateValidator, StakingTransactionsTypeEnumEditValidator, StakingTransactionsTypeEnumCollectRewards, StakingTransactionsTypeEnumUndelegate, StakingTransactionsTypeEnumDelegate:
		return true
	}
	return false
}

func (e StakingTransactionsTypeEnum) String() string {
	return string(e)
}

func (e *StakingTransactionsTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StakingTransactionsTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StakingTransactionsTypeEnum", str)
	}
	return nil
}

func (e StakingTransactionsTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StellarNetwork string

const (
	// The Stellar Ledger
	StellarNetworkStellar StellarNetwork = "stellar"
)

var AllStellarNetwork = []StellarNetwork{
	StellarNetworkStellar,
}

func (e StellarNetwork) IsValid() bool {
	switch e {
	case StellarNetworkStellar:
		return true
	}
	return false
}

func (e StellarNetwork) String() string {
	return string(e)
}

func (e *StellarNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StellarNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StellarNetwork", str)
	}
	return nil
}

func (e StellarNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StellarTransfersMeasureable string

const (
	// Date
	StellarTransfersMeasureableDate StellarTransfersMeasureable = "date"
	// Time
	StellarTransfersMeasureableTime StellarTransfersMeasureable = "time"
	// Transaction Hash
	StellarTransfersMeasureableTransactionHash StellarTransfersMeasureable = "transaction_hash"
	// Transfer Receiver
	StellarTransfersMeasureableReceiver StellarTransfersMeasureable = "receiver"
	// Transfer Sender
	StellarTransfersMeasureableSender StellarTransfersMeasureable = "sender"
)

var AllStellarTransfersMeasureable = []StellarTransfersMeasureable{
	StellarTransfersMeasureableDate,
	StellarTransfersMeasureableTime,
	StellarTransfersMeasureableTransactionHash,
	StellarTransfersMeasureableReceiver,
	StellarTransfersMeasureableSender,
}

func (e StellarTransfersMeasureable) IsValid() bool {
	switch e {
	case StellarTransfersMeasureableDate, StellarTransfersMeasureableTime, StellarTransfersMeasureableTransactionHash, StellarTransfersMeasureableReceiver, StellarTransfersMeasureableSender:
		return true
	}
	return false
}

func (e StellarTransfersMeasureable) String() string {
	return string(e)
}

func (e *StellarTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StellarTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StellarTransfersMeasureable", str)
	}
	return nil
}

func (e StellarTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StellarTransfersUniq string

const (
	// Unique time
	StellarTransfersUniqTimes StellarTransfersUniq = "times"
	// Unique date count
	StellarTransfersUniqDates StellarTransfersUniq = "dates"
	// Unique date count
	StellarTransfersUniqTransactionHash StellarTransfersUniq = "transaction_hash"
	// Transfer Receiver
	StellarTransfersUniqReceiver StellarTransfersUniq = "receiver"
	// Transfer sender
	StellarTransfersUniqSender StellarTransfersUniq = "sender"
)

var AllStellarTransfersUniq = []StellarTransfersUniq{
	StellarTransfersUniqTimes,
	StellarTransfersUniqDates,
	StellarTransfersUniqTransactionHash,
	StellarTransfersUniqReceiver,
	StellarTransfersUniqSender,
}

func (e StellarTransfersUniq) IsValid() bool {
	switch e {
	case StellarTransfersUniqTimes, StellarTransfersUniqDates, StellarTransfersUniqTransactionHash, StellarTransfersUniqReceiver, StellarTransfersUniqSender:
		return true
	}
	return false
}

func (e StellarTransfersUniq) String() string {
	return string(e)
}

func (e *StellarTransfersUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StellarTransfersUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StellarTransfersUniq", str)
	}
	return nil
}

func (e StellarTransfersUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TradeSide string

const (
	// Buy side
	TradeSideBuy TradeSide = "BUY"
	// Sell side
	TradeSideSell TradeSide = "SELL"
)

var AllTradeSide = []TradeSide{
	TradeSideBuy,
	TradeSideSell,
}

func (e TradeSide) IsValid() bool {
	switch e {
	case TradeSideBuy, TradeSideSell:
		return true
	}
	return false
}

func (e TradeSide) String() string {
	return string(e)
}

func (e *TradeSide) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TradeSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TradeSide", str)
	}
	return nil
}

func (e TradeSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionTypeEnum string

const (
	// Set options on an account
	TransactionTypeEnumAccountSet TransactionTypeEnum = "AccountSet"
	// Delete an account
	TransactionTypeEnumAccountDelete TransactionTypeEnum = "AccountDelete"
	// Cancel a check
	TransactionTypeEnumCheckCancel TransactionTypeEnum = "CheckCancel"
	// Redeem a check
	TransactionTypeEnumCheckCash TransactionTypeEnum = "CheckCash"
	// Create a check
	TransactionTypeEnumCheckCreate TransactionTypeEnum = "CheckCreate"
	// Preauthorizes an account to send payments to this one
	TransactionTypeEnumDepositPreauth TransactionTypeEnum = "DepositPreauth"
	// Reclaim escrowed XRP
	TransactionTypeEnumEscrowCancel TransactionTypeEnum = "EscrowCancel"
	// Create an ascrowed XRP payment
	TransactionTypeEnumEscrowCreate TransactionTypeEnum = "EscrowCreate"
	// Deliver escrowed XRP recipient
	TransactionTypeEnumEscrowFinish TransactionTypeEnum = "EscrowFinish"
	// Withdraw a currency-exchange order
	TransactionTypeEnumOfferCancel TransactionTypeEnum = "OfferCancel"
	// Sibmit an order to exchange currency
	TransactionTypeEnumOfferCreate TransactionTypeEnum = "OfferCreate"
	// Send funds from one account to another
	TransactionTypeEnumPayment TransactionTypeEnum = "Payment"
	// Claim money from a payment channel
	TransactionTypeEnumPaymentChannelClaim TransactionTypeEnum = "PaymentChannelClaim"
	// Open a new payment channel
	TransactionTypeEnumPaymentChannelCreate TransactionTypeEnum = "PaymentChannelCreate"
	// Add more XRP to a payment channel
	TransactionTypeEnumPaymentChannelFund TransactionTypeEnum = "PaymentChannelFund"
	// Add, remove or modify an accounts regular key pair
	TransactionTypeEnumSetRegularKey TransactionTypeEnum = "SetRegularKey"
	// Add, remove, or modify an accounts multi-signing list
	TransactionTypeEnumSignerListSet TransactionTypeEnum = "SignerListSet"
	// Setaside one or more sequence numbers as Tickets
	TransactionTypeEnumTicketCreate TransactionTypeEnum = "TicketCreate"
	// Add or modify a trust line
	TransactionTypeEnumTrustSet TransactionTypeEnum = "TrustSet"
)

var AllTransactionTypeEnum = []TransactionTypeEnum{
	TransactionTypeEnumAccountSet,
	TransactionTypeEnumAccountDelete,
	TransactionTypeEnumCheckCancel,
	TransactionTypeEnumCheckCash,
	TransactionTypeEnumCheckCreate,
	TransactionTypeEnumDepositPreauth,
	TransactionTypeEnumEscrowCancel,
	TransactionTypeEnumEscrowCreate,
	TransactionTypeEnumEscrowFinish,
	TransactionTypeEnumOfferCancel,
	TransactionTypeEnumOfferCreate,
	TransactionTypeEnumPayment,
	TransactionTypeEnumPaymentChannelClaim,
	TransactionTypeEnumPaymentChannelCreate,
	TransactionTypeEnumPaymentChannelFund,
	TransactionTypeEnumSetRegularKey,
	TransactionTypeEnumSignerListSet,
	TransactionTypeEnumTicketCreate,
	TransactionTypeEnumTrustSet,
}

func (e TransactionTypeEnum) IsValid() bool {
	switch e {
	case TransactionTypeEnumAccountSet, TransactionTypeEnumAccountDelete, TransactionTypeEnumCheckCancel, TransactionTypeEnumCheckCash, TransactionTypeEnumCheckCreate, TransactionTypeEnumDepositPreauth, TransactionTypeEnumEscrowCancel, TransactionTypeEnumEscrowCreate, TransactionTypeEnumEscrowFinish, TransactionTypeEnumOfferCancel, TransactionTypeEnumOfferCreate, TransactionTypeEnumPayment, TransactionTypeEnumPaymentChannelClaim, TransactionTypeEnumPaymentChannelCreate, TransactionTypeEnumPaymentChannelFund, TransactionTypeEnumSetRegularKey, TransactionTypeEnumSignerListSet, TransactionTypeEnumTicketCreate, TransactionTypeEnumTrustSet:
		return true
	}
	return false
}

func (e TransactionTypeEnum) String() string {
	return string(e)
}

func (e *TransactionTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionTypeEnum", str)
	}
	return nil
}

func (e TransactionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransferReasonEnum string

const (
	// Transaction
	TransferReasonEnumTransaction TransferReasonEnum = "transaction"
	// Smart Contract Call
	TransferReasonEnumCallResult TransferReasonEnum = "call_result"
	// ESDT Transfer
	TransferReasonEnumEsdtTransfer TransferReasonEnum = "esdt_transfer"
	// NFT Transfer
	TransferReasonEnumNftTransfer TransferReasonEnum = "nft_transfer"
)

var AllTransferReasonEnum = []TransferReasonEnum{
	TransferReasonEnumTransaction,
	TransferReasonEnumCallResult,
	TransferReasonEnumEsdtTransfer,
	TransferReasonEnumNftTransfer,
}

func (e TransferReasonEnum) IsValid() bool {
	switch e {
	case TransferReasonEnumTransaction, TransferReasonEnumCallResult, TransferReasonEnumEsdtTransfer, TransferReasonEnumNftTransfer:
		return true
	}
	return false
}

func (e TransferReasonEnum) String() string {
	return string(e)
}

func (e *TransferReasonEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransferReasonEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransferReasonEnum", str)
	}
	return nil
}

func (e TransferReasonEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransfersUniq string

const (
	// Transfers
	TransfersUniqTransfers TransfersUniq = "transfers"
	// Unique transactions count
	TransfersUniqTxs TransfersUniq = "txs"
	// Unique senders count
	TransfersUniqSenders TransfersUniq = "senders"
	// Unique receivers count
	TransfersUniqReceivers TransfersUniq = "receivers"
	// Unique blocks
	TransfersUniqBlocks TransfersUniq = "blocks"
	// Unique date count
	TransfersUniqDates TransfersUniq = "dates"
	// Unique currencies
	TransfersUniqCurrencies TransfersUniq = "currencies"
)

var AllTransfersUniq = []TransfersUniq{
	TransfersUniqTransfers,
	TransfersUniqTxs,
	TransfersUniqSenders,
	TransfersUniqReceivers,
	TransfersUniqBlocks,
	TransfersUniqDates,
	TransfersUniqCurrencies,
}

func (e TransfersUniq) IsValid() bool {
	switch e {
	case TransfersUniqTransfers, TransfersUniqTxs, TransfersUniqSenders, TransfersUniqReceivers, TransfersUniqBlocks, TransfersUniqDates, TransfersUniqCurrencies:
		return true
	}
	return false
}

func (e TransfersUniq) String() string {
	return string(e)
}

func (e *TransfersUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransfersUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransfersUniq", str)
	}
	return nil
}

func (e TransfersUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronBlocksMeasureable string

const (
	// Date
	TronBlocksMeasureableDate TronBlocksMeasureable = "date"
	// Time
	TronBlocksMeasureableTime TronBlocksMeasureable = "time"
	// Block
	TronBlocksMeasureableBlock TronBlocksMeasureable = "block"
	// Block hash
	TronBlocksMeasureableBlockHash TronBlocksMeasureable = "block_hash"
	// Block Witness address
	TronBlocksMeasureableWitness TronBlocksMeasureable = "witness"
	// Block Version
	TronBlocksMeasureableVersion TronBlocksMeasureable = "version"
)

var AllTronBlocksMeasureable = []TronBlocksMeasureable{
	TronBlocksMeasureableDate,
	TronBlocksMeasureableTime,
	TronBlocksMeasureableBlock,
	TronBlocksMeasureableBlockHash,
	TronBlocksMeasureableWitness,
	TronBlocksMeasureableVersion,
}

func (e TronBlocksMeasureable) IsValid() bool {
	switch e {
	case TronBlocksMeasureableDate, TronBlocksMeasureableTime, TronBlocksMeasureableBlock, TronBlocksMeasureableBlockHash, TronBlocksMeasureableWitness, TronBlocksMeasureableVersion:
		return true
	}
	return false
}

func (e TronBlocksMeasureable) String() string {
	return string(e)
}

func (e *TronBlocksMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronBlocksMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronBlocksMeasureable", str)
	}
	return nil
}

func (e TronBlocksMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronBlocksUniq string

const (
	// Unique witness count
	TronBlocksUniqWitnesses TronBlocksUniq = "witnesses"
	// Unique date count
	TronBlocksUniqDates TronBlocksUniq = "dates"
)

var AllTronBlocksUniq = []TronBlocksUniq{
	TronBlocksUniqWitnesses,
	TronBlocksUniqDates,
}

func (e TronBlocksUniq) IsValid() bool {
	switch e {
	case TronBlocksUniqWitnesses, TronBlocksUniqDates:
		return true
	}
	return false
}

func (e TronBlocksUniq) String() string {
	return string(e)
}

func (e *TronBlocksUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronBlocksUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronBlocksUniq", str)
	}
	return nil
}

func (e TronBlocksUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronCallsMeasureable string

const (
	// Date
	TronCallsMeasureableDate TronCallsMeasureable = "date"
	// Time
	TronCallsMeasureableTime TronCallsMeasureable = "time"
	// Block
	TronCallsMeasureableBlock TronCallsMeasureable = "block"
	// Transaction hash
	TronCallsMeasureableTxHash TronCallsMeasureable = "tx_hash"
	// Action From
	TronCallsMeasureableTxFrom TronCallsMeasureable = "tx_from"
	// Action To
	TronCallsMeasureableTxTo TronCallsMeasureable = "tx_to"
	// Smart Contract
	TronCallsMeasureableSmartContract TronCallsMeasureable = "smart_contract"
	// Smart Contract Method Name
	TronCallsMeasureableSignatureName TronCallsMeasureable = "signature_name"
	// Smart Contract Method Signature
	TronCallsMeasureableSignature TronCallsMeasureable = "signature"
	// Smart Contract Method Signature Hash
	TronCallsMeasureableSignatureHash TronCallsMeasureable = "signature_hash"
	// Call depth
	TronCallsMeasureableCallDepth TronCallsMeasureable = "call_depth"
)

var AllTronCallsMeasureable = []TronCallsMeasureable{
	TronCallsMeasureableDate,
	TronCallsMeasureableTime,
	TronCallsMeasureableBlock,
	TronCallsMeasureableTxHash,
	TronCallsMeasureableTxFrom,
	TronCallsMeasureableTxTo,
	TronCallsMeasureableSmartContract,
	TronCallsMeasureableSignatureName,
	TronCallsMeasureableSignature,
	TronCallsMeasureableSignatureHash,
	TronCallsMeasureableCallDepth,
}

func (e TronCallsMeasureable) IsValid() bool {
	switch e {
	case TronCallsMeasureableDate, TronCallsMeasureableTime, TronCallsMeasureableBlock, TronCallsMeasureableTxHash, TronCallsMeasureableTxFrom, TronCallsMeasureableTxTo, TronCallsMeasureableSmartContract, TronCallsMeasureableSignatureName, TronCallsMeasureableSignature, TronCallsMeasureableSignatureHash, TronCallsMeasureableCallDepth:
		return true
	}
	return false
}

func (e TronCallsMeasureable) String() string {
	return string(e)
}

func (e *TronCallsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronCallsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronCallsMeasureable", str)
	}
	return nil
}

func (e TronCallsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronContractType string

const (
	// Account Create
	TronContractTypeAccountCreate TronContractType = "AccountCreate"
	// Account Permission Update
	TronContractTypeAccountPermissionUpdate TronContractType = "AccountPermissionUpdate"
	// Account Update
	TronContractTypeAccountUpdate TronContractType = "AccountUpdate"
	// Asset Issue
	TronContractTypeAssetIssue TronContractType = "AssetIssue"
	// Clear ABI
	TronContractTypeClearAbi TronContractType = "ClearABI"
	// Create Smart
	TronContractTypeCreateSmart TronContractType = "CreateSmart"
	// Exchange Create
	TronContractTypeExchangeCreate TronContractType = "ExchangeCreate"
	// Exchange Inject
	TronContractTypeExchangeInject TronContractType = "ExchangeInject"
	// Exchange Transaction
	TronContractTypeExchangeTransaction TronContractType = "ExchangeTransaction"
	// Exchange Withdraw
	TronContractTypeExchangeWithdraw TronContractType = "ExchangeWithdraw"
	// Freeze Balance
	TronContractTypeFreezeBalance TronContractType = "FreezeBalance"
	// Participate Asset Issue
	TronContractTypeParticipateAssetIssue TronContractType = "ParticipateAssetIssue"
	// Proposal Approve
	TronContractTypeProposalApprove TronContractType = "ProposalApprove"
	// Proposal Create
	TronContractTypeProposalCreate TronContractType = "ProposalCreate"
	// Proposal Delete
	TronContractTypeProposalDelete TronContractType = "ProposalDelete"
	// Set Account Id
	TronContractTypeSetAccountID TronContractType = "SetAccountId"
	// Transfer
	TronContractTypeTransfer TronContractType = "Transfer"
	// Transfer Asset
	TronContractTypeTransferAsset TronContractType = "TransferAsset"
	// Trigger Smart
	TronContractTypeTriggerSmart TronContractType = "TriggerSmart"
	// Unfreeze Asset
	TronContractTypeUnfreezeAsset TronContractType = "UnfreezeAsset"
	// Unfreeze Balance
	TronContractTypeUnfreezeBalance TronContractType = "UnfreezeBalance"
	// Update Asset
	TronContractTypeUpdateAsset TronContractType = "UpdateAsset"
	// Update Brokerage
	TronContractTypeUpdateBrokerage TronContractType = "UpdateBrokerage"
	// Update Energy Limit
	TronContractTypeUpdateEnergyLimit TronContractType = "UpdateEnergyLimit"
	// Update Setting
	TronContractTypeUpdateSetting TronContractType = "UpdateSetting"
	// Vote Witness
	TronContractTypeVoteWitness TronContractType = "VoteWitness"
	// Withdraw Balance
	TronContractTypeWithdrawBalance TronContractType = "WithdrawBalance"
	// Witness Create
	TronContractTypeWitnessCreate TronContractType = "WitnessCreate"
	// Witness Update
	TronContractTypeWitnessUpdate TronContractType = "WitnessUpdate"
)

var AllTronContractType = []TronContractType{
	TronContractTypeAccountCreate,
	TronContractTypeAccountPermissionUpdate,
	TronContractTypeAccountUpdate,
	TronContractTypeAssetIssue,
	TronContractTypeClearAbi,
	TronContractTypeCreateSmart,
	TronContractTypeExchangeCreate,
	TronContractTypeExchangeInject,
	TronContractTypeExchangeTransaction,
	TronContractTypeExchangeWithdraw,
	TronContractTypeFreezeBalance,
	TronContractTypeParticipateAssetIssue,
	TronContractTypeProposalApprove,
	TronContractTypeProposalCreate,
	TronContractTypeProposalDelete,
	TronContractTypeSetAccountID,
	TronContractTypeTransfer,
	TronContractTypeTransferAsset,
	TronContractTypeTriggerSmart,
	TronContractTypeUnfreezeAsset,
	TronContractTypeUnfreezeBalance,
	TronContractTypeUpdateAsset,
	TronContractTypeUpdateBrokerage,
	TronContractTypeUpdateEnergyLimit,
	TronContractTypeUpdateSetting,
	TronContractTypeVoteWitness,
	TronContractTypeWithdrawBalance,
	TronContractTypeWitnessCreate,
	TronContractTypeWitnessUpdate,
}

func (e TronContractType) IsValid() bool {
	switch e {
	case TronContractTypeAccountCreate, TronContractTypeAccountPermissionUpdate, TronContractTypeAccountUpdate, TronContractTypeAssetIssue, TronContractTypeClearAbi, TronContractTypeCreateSmart, TronContractTypeExchangeCreate, TronContractTypeExchangeInject, TronContractTypeExchangeTransaction, TronContractTypeExchangeWithdraw, TronContractTypeFreezeBalance, TronContractTypeParticipateAssetIssue, TronContractTypeProposalApprove, TronContractTypeProposalCreate, TronContractTypeProposalDelete, TronContractTypeSetAccountID, TronContractTypeTransfer, TronContractTypeTransferAsset, TronContractTypeTriggerSmart, TronContractTypeUnfreezeAsset, TronContractTypeUnfreezeBalance, TronContractTypeUpdateAsset, TronContractTypeUpdateBrokerage, TronContractTypeUpdateEnergyLimit, TronContractTypeUpdateSetting, TronContractTypeVoteWitness, TronContractTypeWithdrawBalance, TronContractTypeWitnessCreate, TronContractTypeWitnessUpdate:
		return true
	}
	return false
}

func (e TronContractType) String() string {
	return string(e)
}

func (e *TronContractType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronContractType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronContractType", str)
	}
	return nil
}

func (e TronContractType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronContractsMeasureable string

const (
	// Date
	TronContractsMeasureableDate TronContractsMeasureable = "date"
	// Time
	TronContractsMeasureableTime TronContractsMeasureable = "time"
	// Block
	TronContractsMeasureableBlock TronContractsMeasureable = "block"
	// Transaction hash
	TronContractsMeasureableTxHash TronContractsMeasureable = "tx_hash"
	// Transaction owner
	TronContractsMeasureableTxOwner TronContractsMeasureable = "tx_owner"
	// Contract
	TronContractsMeasureableContractType TronContractsMeasureable = "contract_type"
)

var AllTronContractsMeasureable = []TronContractsMeasureable{
	TronContractsMeasureableDate,
	TronContractsMeasureableTime,
	TronContractsMeasureableBlock,
	TronContractsMeasureableTxHash,
	TronContractsMeasureableTxOwner,
	TronContractsMeasureableContractType,
}

func (e TronContractsMeasureable) IsValid() bool {
	switch e {
	case TronContractsMeasureableDate, TronContractsMeasureableTime, TronContractsMeasureableBlock, TronContractsMeasureableTxHash, TronContractsMeasureableTxOwner, TronContractsMeasureableContractType:
		return true
	}
	return false
}

func (e TronContractsMeasureable) String() string {
	return string(e)
}

func (e *TronContractsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronContractsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronContractsMeasureable", str)
	}
	return nil
}

func (e TronContractsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronDexTradesMeasureable string

const (
	// Date
	TronDexTradesMeasureableDate TronDexTradesMeasureable = "date"
	// Time
	TronDexTradesMeasureableTime TronDexTradesMeasureable = "time"
	// Block
	TronDexTradesMeasureableBlock TronDexTradesMeasureable = "block"
	// Transaction hash
	TronDexTradesMeasureableTxHash TronDexTradesMeasureable = "tx_hash"
	// Buy Amount
	TronDexTradesMeasureableBuyAmount TronDexTradesMeasureable = "buy_amount"
	// Sell Amount
	TronDexTradesMeasureableSellAmount TronDexTradesMeasureable = "sell_amount"
	// Price
	TronDexTradesMeasureablePrice TronDexTradesMeasureable = "price"
	// Quote Price
	TronDexTradesMeasureableQuotePrice TronDexTradesMeasureable = "quote_price"
	// Maker
	TronDexTradesMeasureableMaker TronDexTradesMeasureable = "maker"
	// Taker
	TronDexTradesMeasureableTaker TronDexTradesMeasureable = "taker"
	// Buy Currency symbol
	TronDexTradesMeasureableBuyCurrencySymbol TronDexTradesMeasureable = "buy_currency_symbol"
	// Buy Token address
	TronDexTradesMeasureableBuyCurrencyAddress TronDexTradesMeasureable = "buy_currency_address"
	// Sell Currency symbol
	TronDexTradesMeasureableSellCurrencySymbol TronDexTradesMeasureable = "sell_currency_symbol"
	// Sell Token address
	TronDexTradesMeasureableSellCurrencyAddress TronDexTradesMeasureable = "sell_currency_address"
)

var AllTronDexTradesMeasureable = []TronDexTradesMeasureable{
	TronDexTradesMeasureableDate,
	TronDexTradesMeasureableTime,
	TronDexTradesMeasureableBlock,
	TronDexTradesMeasureableTxHash,
	TronDexTradesMeasureableBuyAmount,
	TronDexTradesMeasureableSellAmount,
	TronDexTradesMeasureablePrice,
	TronDexTradesMeasureableQuotePrice,
	TronDexTradesMeasureableMaker,
	TronDexTradesMeasureableTaker,
	TronDexTradesMeasureableBuyCurrencySymbol,
	TronDexTradesMeasureableBuyCurrencyAddress,
	TronDexTradesMeasureableSellCurrencySymbol,
	TronDexTradesMeasureableSellCurrencyAddress,
}

func (e TronDexTradesMeasureable) IsValid() bool {
	switch e {
	case TronDexTradesMeasureableDate, TronDexTradesMeasureableTime, TronDexTradesMeasureableBlock, TronDexTradesMeasureableTxHash, TronDexTradesMeasureableBuyAmount, TronDexTradesMeasureableSellAmount, TronDexTradesMeasureablePrice, TronDexTradesMeasureableQuotePrice, TronDexTradesMeasureableMaker, TronDexTradesMeasureableTaker, TronDexTradesMeasureableBuyCurrencySymbol, TronDexTradesMeasureableBuyCurrencyAddress, TronDexTradesMeasureableSellCurrencySymbol, TronDexTradesMeasureableSellCurrencyAddress:
		return true
	}
	return false
}

func (e TronDexTradesMeasureable) String() string {
	return string(e)
}

func (e *TronDexTradesMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronDexTradesMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronDexTradesMeasureable", str)
	}
	return nil
}

func (e TronDexTradesMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronDexTradesUniq string

const (
	// Unique makers count
	TronDexTradesUniqMakers TronDexTradesUniq = "makers"
	// Unique makers count
	TronDexTradesUniqTakers TronDexTradesUniq = "takers"
	// Unique makers & takers count
	TronDexTradesUniqAddress TronDexTradesUniq = "address"
	// Buy currencies count
	TronDexTradesUniqBuyCurrency TronDexTradesUniq = "buy_currency"
	// Sell currencies count
	TronDexTradesUniqSellCurrency TronDexTradesUniq = "sell_currency"
	// Base currencies count
	TronDexTradesUniqBaseCurrency TronDexTradesUniq = "base_currency"
	// Quote currencies count
	TronDexTradesUniqQuoteCurrency TronDexTradesUniq = "quote_currency"
	// Unique blocks
	TronDexTradesUniqBlocks TronDexTradesUniq = "blocks"
	// Unique transactions count
	TronDexTradesUniqTxs TronDexTradesUniq = "txs"
	// Unique date count
	TronDexTradesUniqDates TronDexTradesUniq = "dates"
	// Unique smart contract count
	TronDexTradesUniqSmartContracts TronDexTradesUniq = "smart_contracts"
	// Unique protocols count
	TronDexTradesUniqProtocols TronDexTradesUniq = "protocols"
)

var AllTronDexTradesUniq = []TronDexTradesUniq{
	TronDexTradesUniqMakers,
	TronDexTradesUniqTakers,
	TronDexTradesUniqAddress,
	TronDexTradesUniqBuyCurrency,
	TronDexTradesUniqSellCurrency,
	TronDexTradesUniqBaseCurrency,
	TronDexTradesUniqQuoteCurrency,
	TronDexTradesUniqBlocks,
	TronDexTradesUniqTxs,
	TronDexTradesUniqDates,
	TronDexTradesUniqSmartContracts,
	TronDexTradesUniqProtocols,
}

func (e TronDexTradesUniq) IsValid() bool {
	switch e {
	case TronDexTradesUniqMakers, TronDexTradesUniqTakers, TronDexTradesUniqAddress, TronDexTradesUniqBuyCurrency, TronDexTradesUniqSellCurrency, TronDexTradesUniqBaseCurrency, TronDexTradesUniqQuoteCurrency, TronDexTradesUniqBlocks, TronDexTradesUniqTxs, TronDexTradesUniqDates, TronDexTradesUniqSmartContracts, TronDexTradesUniqProtocols:
		return true
	}
	return false
}

func (e TronDexTradesUniq) String() string {
	return string(e)
}

func (e *TronDexTradesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronDexTradesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronDexTradesUniq", str)
	}
	return nil
}

func (e TronDexTradesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronEventsMeasureable string

const (
	// Date
	TronEventsMeasureableDate TronEventsMeasureable = "date"
	// Time
	TronEventsMeasureableTime TronEventsMeasureable = "time"
	// Block
	TronEventsMeasureableBlock TronEventsMeasureable = "block"
	// Transaction hash
	TronEventsMeasureableTxHash TronEventsMeasureable = "tx_hash"
	// Action From
	TronEventsMeasureableTxFrom TronEventsMeasureable = "tx_from"
	// Action To
	TronEventsMeasureableTxTo TronEventsMeasureable = "tx_to"
	// Smart Contract
	TronEventsMeasureableSmartContract TronEventsMeasureable = "smart_contract"
	// Smart Contract Method Name
	TronEventsMeasureableSignatureName TronEventsMeasureable = "signature_name"
	// Smart Contract Method Signature
	TronEventsMeasureableSignature TronEventsMeasureable = "signature"
	// Smart Contract Method Signature Hash
	TronEventsMeasureableSignatureHash TronEventsMeasureable = "signature_hash"
)

var AllTronEventsMeasureable = []TronEventsMeasureable{
	TronEventsMeasureableDate,
	TronEventsMeasureableTime,
	TronEventsMeasureableBlock,
	TronEventsMeasureableTxHash,
	TronEventsMeasureableTxFrom,
	TronEventsMeasureableTxTo,
	TronEventsMeasureableSmartContract,
	TronEventsMeasureableSignatureName,
	TronEventsMeasureableSignature,
	TronEventsMeasureableSignatureHash,
}

func (e TronEventsMeasureable) IsValid() bool {
	switch e {
	case TronEventsMeasureableDate, TronEventsMeasureableTime, TronEventsMeasureableBlock, TronEventsMeasureableTxHash, TronEventsMeasureableTxFrom, TronEventsMeasureableTxTo, TronEventsMeasureableSmartContract, TronEventsMeasureableSignatureName, TronEventsMeasureableSignature, TronEventsMeasureableSignatureHash:
		return true
	}
	return false
}

func (e TronEventsMeasureable) String() string {
	return string(e)
}

func (e *TronEventsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronEventsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronEventsMeasureable", str)
	}
	return nil
}

func (e TronEventsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronNetwork string

const (
	// TRON mainnet
	TronNetworkTron TronNetwork = "tron"
)

var AllTronNetwork = []TronNetwork{
	TronNetworkTron,
}

func (e TronNetwork) IsValid() bool {
	switch e {
	case TronNetworkTron:
		return true
	}
	return false
}

func (e TronNetwork) String() string {
	return string(e)
}

func (e *TronNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronNetwork", str)
	}
	return nil
}

func (e TronNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronTradesMeasureable string

const (
	// Date
	TronTradesMeasureableDate TronTradesMeasureable = "date"
	// Time
	TronTradesMeasureableTime TronTradesMeasureable = "time"
	// Block
	TronTradesMeasureableBlock TronTradesMeasureable = "block"
	// Transaction hash
	TronTradesMeasureableTxHash TronTradesMeasureable = "tx_hash"
	// Amount Sell
	TronTradesMeasureableAmountSell TronTradesMeasureable = "amount_sell"
	// Amount Sell
	TronTradesMeasureableAmountBuy TronTradesMeasureable = "amount_buy"
	// Buyer
	TronTradesMeasureableBuyer TronTradesMeasureable = "buyer"
	// Seller
	TronTradesMeasureableSeller TronTradesMeasureable = "seller"
	// Buy Currency symbol
	TronTradesMeasureableBuyCurrencySymbol TronTradesMeasureable = "buy_currency_symbol"
	// Buy Currency name
	TronTradesMeasureableBuyCurrencyName TronTradesMeasureable = "buy_currency_name"
	// Buy Token address
	TronTradesMeasureableBuyCurrencyAddress TronTradesMeasureable = "buy_currency_address"
	// Buy Token address
	TronTradesMeasureableBuyTokenID TronTradesMeasureable = "buy_token_id"
	// Buy Token type
	TronTradesMeasureableBuyTokenType TronTradesMeasureable = "buy_token_type"
	// Buy Currency symbol
	TronTradesMeasureableSellCurrencySymbol TronTradesMeasureable = "sell_currency_symbol"
	// Buy Currency name
	TronTradesMeasureableSellCurrencyName TronTradesMeasureable = "sell_currency_name"
	// Buy Token address
	TronTradesMeasureableSellCurrencyAddress TronTradesMeasureable = "sell_currency_address"
	// Buy Token address
	TronTradesMeasureableSellTokenID TronTradesMeasureable = "sell_token_id"
	// Buy Token type
	TronTradesMeasureableSellTokenType TronTradesMeasureable = "sell_token_type"
	// Exchange ID
	TronTradesMeasureableExchangeID TronTradesMeasureable = "exchange_id"
	// Contract Type
	TronTradesMeasureableContractType TronTradesMeasureable = "contract_type"
)

var AllTronTradesMeasureable = []TronTradesMeasureable{
	TronTradesMeasureableDate,
	TronTradesMeasureableTime,
	TronTradesMeasureableBlock,
	TronTradesMeasureableTxHash,
	TronTradesMeasureableAmountSell,
	TronTradesMeasureableAmountBuy,
	TronTradesMeasureableBuyer,
	TronTradesMeasureableSeller,
	TronTradesMeasureableBuyCurrencySymbol,
	TronTradesMeasureableBuyCurrencyName,
	TronTradesMeasureableBuyCurrencyAddress,
	TronTradesMeasureableBuyTokenID,
	TronTradesMeasureableBuyTokenType,
	TronTradesMeasureableSellCurrencySymbol,
	TronTradesMeasureableSellCurrencyName,
	TronTradesMeasureableSellCurrencyAddress,
	TronTradesMeasureableSellTokenID,
	TronTradesMeasureableSellTokenType,
	TronTradesMeasureableExchangeID,
	TronTradesMeasureableContractType,
}

func (e TronTradesMeasureable) IsValid() bool {
	switch e {
	case TronTradesMeasureableDate, TronTradesMeasureableTime, TronTradesMeasureableBlock, TronTradesMeasureableTxHash, TronTradesMeasureableAmountSell, TronTradesMeasureableAmountBuy, TronTradesMeasureableBuyer, TronTradesMeasureableSeller, TronTradesMeasureableBuyCurrencySymbol, TronTradesMeasureableBuyCurrencyName, TronTradesMeasureableBuyCurrencyAddress, TronTradesMeasureableBuyTokenID, TronTradesMeasureableBuyTokenType, TronTradesMeasureableSellCurrencySymbol, TronTradesMeasureableSellCurrencyName, TronTradesMeasureableSellCurrencyAddress, TronTradesMeasureableSellTokenID, TronTradesMeasureableSellTokenType, TronTradesMeasureableExchangeID, TronTradesMeasureableContractType:
		return true
	}
	return false
}

func (e TronTradesMeasureable) String() string {
	return string(e)
}

func (e *TronTradesMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronTradesMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronTradesMeasureable", str)
	}
	return nil
}

func (e TronTradesMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronTradesUniq string

const (
	// Unique blocks
	TronTradesUniqBlocks TronTradesUniq = "blocks"
	// Unique date count
	TronTradesUniqDates TronTradesUniq = "dates"
	// Sellers count
	TronTradesUniqSellers TronTradesUniq = "sellers"
	// Buyers count
	TronTradesUniqBuyers TronTradesUniq = "buyers"
	// Buy currencies
	TronTradesUniqBuyCurrencies TronTradesUniq = "buy_currencies"
	// Sell currencies
	TronTradesUniqSellCurrencies TronTradesUniq = "sell_currencies"
	// Exchange IDs
	TronTradesUniqExchanges TronTradesUniq = "exchanges"
)

var AllTronTradesUniq = []TronTradesUniq{
	TronTradesUniqBlocks,
	TronTradesUniqDates,
	TronTradesUniqSellers,
	TronTradesUniqBuyers,
	TronTradesUniqBuyCurrencies,
	TronTradesUniqSellCurrencies,
	TronTradesUniqExchanges,
}

func (e TronTradesUniq) IsValid() bool {
	switch e {
	case TronTradesUniqBlocks, TronTradesUniqDates, TronTradesUniqSellers, TronTradesUniqBuyers, TronTradesUniqBuyCurrencies, TronTradesUniqSellCurrencies, TronTradesUniqExchanges:
		return true
	}
	return false
}

func (e TronTradesUniq) String() string {
	return string(e)
}

func (e *TronTradesUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronTradesUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronTradesUniq", str)
	}
	return nil
}

func (e TronTradesUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronTransactionsMeasureable string

const (
	// Date
	TronTransactionsMeasureableDate TronTransactionsMeasureable = "date"
	// Time
	TronTransactionsMeasureableTime TronTransactionsMeasureable = "time"
	// Block
	TronTransactionsMeasureableBlock TronTransactionsMeasureable = "block"
	// Transaction hash
	TronTransactionsMeasureableTxHash TronTransactionsMeasureable = "tx_hash"
	// Fee
	TronTransactionsMeasureableFee TronTransactionsMeasureable = "fee"
	// Fee Limit
	TronTransactionsMeasureableFeeLimit TronTransactionsMeasureable = "fee_limit"
	// Energy Fee
	TronTransactionsMeasureableEnergyFee TronTransactionsMeasureable = "energy_fee"
	// Net usage
	TronTransactionsMeasureableNetUsage TronTransactionsMeasureable = "net_usage"
	// Internal transactions count
	TronTransactionsMeasureableInternalTransactionsCount TronTransactionsMeasureable = "internal_transactions_count"
)

var AllTronTransactionsMeasureable = []TronTransactionsMeasureable{
	TronTransactionsMeasureableDate,
	TronTransactionsMeasureableTime,
	TronTransactionsMeasureableBlock,
	TronTransactionsMeasureableTxHash,
	TronTransactionsMeasureableFee,
	TronTransactionsMeasureableFeeLimit,
	TronTransactionsMeasureableEnergyFee,
	TronTransactionsMeasureableNetUsage,
	TronTransactionsMeasureableInternalTransactionsCount,
}

func (e TronTransactionsMeasureable) IsValid() bool {
	switch e {
	case TronTransactionsMeasureableDate, TronTransactionsMeasureableTime, TronTransactionsMeasureableBlock, TronTransactionsMeasureableTxHash, TronTransactionsMeasureableFee, TronTransactionsMeasureableFeeLimit, TronTransactionsMeasureableEnergyFee, TronTransactionsMeasureableNetUsage, TronTransactionsMeasureableInternalTransactionsCount:
		return true
	}
	return false
}

func (e TronTransactionsMeasureable) String() string {
	return string(e)
}

func (e *TronTransactionsMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronTransactionsMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronTransactionsMeasureable", str)
	}
	return nil
}

func (e TronTransactionsMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronTransactionsUniq string

const (
	// Unique blocks
	TronTransactionsUniqBlocks TronTransactionsUniq = "blocks"
	// Unique date count
	TronTransactionsUniqDates TronTransactionsUniq = "dates"
)

var AllTronTransactionsUniq = []TronTransactionsUniq{
	TronTransactionsUniqBlocks,
	TronTransactionsUniqDates,
}

func (e TronTransactionsUniq) IsValid() bool {
	switch e {
	case TronTransactionsUniqBlocks, TronTransactionsUniqDates:
		return true
	}
	return false
}

func (e TronTransactionsUniq) String() string {
	return string(e)
}

func (e *TronTransactionsUniq) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronTransactionsUniq(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronTransactionsUniq", str)
	}
	return nil
}

func (e TronTransactionsUniq) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TronTransfersMeasureable string

const (
	// Date
	TronTransfersMeasureableDate TronTransfersMeasureable = "date"
	// Time
	TronTransfersMeasureableTime TronTransfersMeasureable = "time"
	// Block
	TronTransfersMeasureableBlock TronTransfersMeasureable = "block"
	// Transaction hash
	TronTransfersMeasureableTxHash TronTransfersMeasureable = "tx_hash"
	// Amount
	TronTransfersMeasureableAmount TronTransfersMeasureable = "amount"
	// Sender
	TronTransfersMeasureableSender TronTransfersMeasureable = "sender"
	// Receiver
	TronTransfersMeasureableReceiver TronTransfersMeasureable = "receiver"
	// Currency symbol
	TronTransfersMeasureableCurrencySymbol TronTransfersMeasureable = "currency_symbol"
	// Token address
	TronTransfersMeasureableCurrencyAddress TronTransfersMeasureable = "currency_address"
	// Token ID
	TronTransfersMeasureableTokenID TronTransfersMeasureable = "token_id"
	// Token type
	TronTransfersMeasureableTokenType TronTransfersMeasureable = "token_type"
)

var AllTronTransfersMeasureable = []TronTransfersMeasureable{
	TronTransfersMeasureableDate,
	TronTransfersMeasureableTime,
	TronTransfersMeasureableBlock,
	TronTransfersMeasureableTxHash,
	TronTransfersMeasureableAmount,
	TronTransfersMeasureableSender,
	TronTransfersMeasureableReceiver,
	TronTransfersMeasureableCurrencySymbol,
	TronTransfersMeasureableCurrencyAddress,
	TronTransfersMeasureableTokenID,
	TronTransfersMeasureableTokenType,
}

func (e TronTransfersMeasureable) IsValid() bool {
	switch e {
	case TronTransfersMeasureableDate, TronTransfersMeasureableTime, TronTransfersMeasureableBlock, TronTransfersMeasureableTxHash, TronTransfersMeasureableAmount, TronTransfersMeasureableSender, TronTransfersMeasureableReceiver, TronTransfersMeasureableCurrencySymbol, TronTransfersMeasureableCurrencyAddress, TronTransfersMeasureableTokenID, TronTransfersMeasureableTokenType:
		return true
	}
	return false
}

func (e TronTransfersMeasureable) String() string {
	return string(e)
}

func (e *TronTransfersMeasureable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TronTransfersMeasureable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TronTransfersMeasureable", str)
	}
	return nil
}

func (e TronTransfersMeasureable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
