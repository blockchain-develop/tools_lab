"""Account"""
type Account {
  """Account ID"""
  id: String!

  """Account number, the equivalent of a human-friendly public key"""
  num: Int!

  """Realm number """
  realmId: Int!

  """Shard number"""
  shardId: Int!
}

"""Solana Action"""
type Action {
  name: String!
  type: String!
}

"""Blockchain address"""
type Address {
  """Address"""
  address: String

  """Annotations ( tags ), if exists"""
  annotation: String
}

"""Address selector"""
input AddressSelector {
  """Equal to Address"""
  is: String

  """Not Equal to Address"""
  not: String

  """In the list of Addresses"""
  in: [String!]

  """Not in the list of Addresses"""
  notIn: [String!]
}

"""Address selector"""
input AddressSelectorIn {
  """Equal to Address"""
  is: String

  """In the list of Addresses"""
  in: [String!]
}

"""Blockchain account with address and type"""
type AddressWithAccount {
  """Account ID"""
  account: String!

  """Address"""
  address: String

  """Annotations ( tags ), if exists"""
  annotation: String

  """Account type"""
  type: String!
}

"""Algorand Blockchain"""
type Algorand {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [AlgorandAddressInfo!]!

  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AddressSelector!], caller: [AddressSelector!], reference: [AddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AddressSelector!], argindex: ArgumentIndexSelector, any: [AlgorandArgumentFilter!], options: QueryOptions): [AlgorandArguments!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector, any: [AlgorandBlockFilter!], options: QueryOptions): [AlgorandBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: [AlgorandCurrencySelector!], initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [AlgorandCoinpath!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector, any: [AlgorandSmartContractCallFilter!], options: QueryOptions): [AlgorandSmartContractCalls!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector, any: [AlgorandTransactionFilter!], options: QueryOptions): [AlgorandTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector, any: [AlgorandTransferFilter!], options: QueryOptions): [AlgorandTransfers!]
}

"""Address detailed information for Algorand network"""
type AlgorandAddressInfo {
  """Address"""
  address: Address

  """Current address balance"""
  balance: Float

  """Current pending rewards"""
  pendingRewards: Float

  """Current rewards"""
  rewards: Float

  """Current round"""
  round: String

  """Smart Contract if exists on the address"""
  smartContract: AlgorandSmartContract

  """Current status"""
  status: String
}

input AlgorandArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txType: TxTypeSelector
  txFrom: [AddressSelector!]
  caller: [AddressSelector!]
  reference: [AddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  smartContractAddress: [AddressSelector!]
  argindex: ArgumentIndexSelector
}

"""Arguments of Smart Contract Calls"""
type AlgorandArguments {
  any(of: AlgorandArgumentsMeasureable!): String

  """Sequential index of value in array ( multi-dimensional)"""
  argindex: Int!

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AddressSelector!], caller: [AddressSelector!], reference: [AddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AddressSelector!], argindex: ArgumentIndexSelector): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AddressSelector!], caller: [AddressSelector!], reference: [AddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AddressSelector!], argindex: ArgumentIndexSelector): BigInt

  """Calendar date"""
  date: Date
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  minimum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  note: String
  poolerror: String

  """Smart contract being called"""
  smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [AddressSelector!]): TransactionHashIndex

  """Transaction sender"""
  txSender(txSender: [AddressSelector!]): Address

  """Transaction type in which the transfer happened"""
  txType(txType: [AlgorandTxType!]): AlgorandTxType

  """The Value of argument"""
  value(value: [ArgumentValueSelector!]): String
}

enum AlgorandArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction type"""
  tx_type

  """Transaction Sender"""
  tx_sender

  """Smart Contract"""
  smart_contract

  """Argument value"""
  argument_value

  """Argument index"""
  argument_index
}

input AlgorandBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: [AddressSelector!]
  blockReward: [AmountSelector!]
  nextProtocol: StringIdSelector
  currentProtocol: StringIdSelector
}

"""Blocks in Algorand blockchain"""
type AlgorandBlocks {
  any(of: AlgorandBlocksMeasureable!): String
  count(uniq: AlgorandBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Int
  countBigInt(uniq: AlgorandBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): BigInt
  currentProtocol: String

  """Calendar date"""
  date: Date
  frac: BigInt!

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  minimum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  nextProtocol: String
  nextProtocolApprovals: BigInt
  nextProtocolSwitchOn: BigInt
  nextProtocolVoteBefore: BigInt

  """Previous block hash"""
  previousBlockHash: String!

  """Block proposer"""
  proposer(proposer: [AddressSelector!]): Address
  rate(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  seed: String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  txnRoot: String!
  upgradeApprove: Int
  upgradePropose: String
}

enum AlgorandBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Reward"""
  block_reward

  """Block Proposer"""
  proposer

  """Next protocol approvals"""
  next_protocol_approvals
}

enum AlgorandBlocksUniq {
  """Unique proposer count"""
  proposers

  """Unique date count"""
  dates
}

enum AlgorandCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction type"""
  tx_type

  """Transaction Sender"""
  tx_sender

  """Smart Contract"""
  smart_contract
}

"""Coinpath"""
type AlgorandCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

"""
Currency selector in Algorand blockchain.
  Currency is selected by asset ID. To select ALGO use ID=0
"""
input AlgorandCurrencySelector {
  """Currency is"""
  is: Int

  """Currency not"""
  not: Int

  """Currency in the list"""
  in: [Int!]

  """Currency not in the list"""
  notIn: [Int!]
}

enum AlgorandNetwork {
  """Algorand Mainnet (ALGO)"""
  algorand

  """Algorand Testnet"""
  algorand_testnet

  """Algorand Betanet"""
  algorand_betanet
}

"""Algorand smart contract"""
type AlgorandSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract byte code"""
  bytecode: String

  """Smart Contract Deassembled source code"""
  source: String
}

input AlgorandSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txSender: [AddressSelector!]
  smartContractAddress: [AddressSelector!]
  txType: TxTypeSelector
}

"""Smart Contract Calls"""
type AlgorandSmartContractCalls {
  any(of: AlgorandCallsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector): BigInt

  """Calendar date"""
  date: Date

  """Fee used in transaction call"""
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector): Float
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  minimum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  note: String
  poolerror: String

  """Smart contract being called"""
  smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [AddressSelector!]): TransactionHashIndex

  """Transaction sender"""
  txSender(txSender: [AddressSelector!]): Address

  """Transaction type in which the transfer happened"""
  txType(txType: [AlgorandTxType!]): AlgorandTxType
}

input AlgorandTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AddressSelector!]
  txIndex: TxIndexSelector
  txCurrency: [AlgorandCurrencySelector!]
  txType: TxTypeSelector
  txSubtype: TxSubtypeSelector
}

"""Algorand transaction with attributes"""
type AlgorandTransactionWithAttributes {
  """Block of the Output Transaction for this input"""
  block: Int

  """Transaction fee"""
  fee: Float
  firstRound: Int

  """Transaction rewards ( from ) """
  fromrewards: Float

  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0-based"""
  index: String!
  lastRound: Int
  lease: String
  note: String
  poolerror: String

  """Transfer transaction sender"""
  sender: Address

  """Transaction sub type"""
  subtype: AlgorandTxSubType

  """Transaction type in which the transfer happened"""
  type: AlgorandTxType
}

"""Transactions in Algorand blockchain"""
type AlgorandTransactions {
  any(of: AlgorandTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: AlgorandTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector): Int
  countBigInt(uniq: AlgorandTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector): BigInt

  """Asset related to transaction"""
  currency(txCurrency: [AlgorandCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector): Float
  firstRound: Int
  genesisHash: String
  genesisId: String

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  lastRound: Int
  maximum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  minimum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  note: String
  poolerror: String

  """Transaction sender"""
  sender(txSender: [AddressSelector!]): Address

  """Transaction sub type"""
  subtype(txType: TxSubtypeSelector): AlgorandTxSubType

  """Transaction type"""
  type(txType: TxTypeSelector): AlgorandTxType
}

enum AlgorandTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Fee value"""
  fee

  """Transaction hash"""
  tx_hash

  """Transaction Sender"""
  tx_sender
}

enum AlgorandTransactionsUniq {
  """Unique TX senders count"""
  senders

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique currencies"""
  currencies
}

input AlgorandTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AddressSelector!]
  txIndex: TxIndexSelector
  sender: [AddressSelector!]
  receiver: [AddressSelector!]
  currency: [AlgorandCurrencySelector!]
  amount: [AmountSelector!]
  txType: TxTypeSelector
  transferType: AlgorandTransferTypeSelector
}

enum AlgorandTransferType {
  """Genesis Block"""
  genesis

  """Create Asset"""
  create

  """Send"""
  send

  """Close"""
  close

  """Reward"""
  reward

  """Asset Freeze"""
  freeze

  """Asset Unfreeze"""
  unfreeze
}

"""Select transfers by type"""
input AlgorandTransferTypeSelector {
  """Transfer Type is"""
  is: AlgorandTransferType

  """Transfer Type not"""
  not: AlgorandTransferType

  """Transfer Type in the list"""
  in: [AlgorandTransferType!]

  """Transfer Type not in the list"""
  notIn: [AlgorandTransferType!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type AlgorandTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Float
  any(of: AlgorandTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): BigInt

  """Currency of transfer"""
  currency(currency: [AlgorandCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  firstRound: Int
  lastRound: Int
  maximum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String
  memo: String
  minimum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: [AddressSelector!]): Address

  """Transfer sender"""
  sender(sender: [AddressSelector!]): Address

  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!]): AlgorandTransactionWithAttributes

  """Transfer Type"""
  transferType(transferType: [AlgorandTransferType!]): AlgorandTransferType
}

enum AlgorandTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """TX Sender"""
  tx_sender

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Currency Asset ID"""
  asset_id

  """Transaction type"""
  tx_type

  """Transfer type"""
  transfer_type
}

enum AlgorandTxSubType {
  """Send"""
  send

  """Close"""
  close

  """Create"""
  create

  """Asset Configuration"""
  configure

  """Asset Freeze"""
  freeze

  """Asset Unfreeze"""
  unfreeze

  """Key Reg"""
  keyreg

  """None"""
  none
}

enum AlgorandTxType {
  """Genesis Block"""
  genesis

  """Pay"""
  pay

  """Key Reg"""
  keyreg

  """Asset Configuration"""
  acfg

  """Asset Transfer"""
  axfer

  """Asset Freeze or Unfreeze"""
  afrz

  """Application Call"""
  appl
}

enum AmountAggregateFunction {
  """Maximum"""
  maximum

  """Minimum"""
  minimum

  """Sum (total)"""
  sum

  """Average"""
  average

  """Median"""
  median

  """Unique estimate fast"""
  unique

  """Unique exact"""
  uniqueExact

  """Any value"""
  any

  """Last value"""
  anyLast
}

"""Select by amount"""
input AmountSelector {
  """Amount is"""
  is: Float

  """Amount not"""
  not: Float

  """Amount in the list"""
  in: [Float!]

  """Amount not in the list"""
  notIn: [Float!]

  """Amount greater than"""
  gt: Float

  """Amount less than"""
  lt: Float

  """Amount less or equal than"""
  lteq: Float

  """Amount greater or equal than"""
  gteq: Float

  """Amount in range"""
  between: [Float!]
}

"""Selector of index of argument in call"""
input ArgumentIndexSelector {
  """Tx index is"""
  is: Int

  """Tx index not"""
  not: Int

  """Tx index in the list"""
  in: [Int!]

  """Tx index not in the list"""
  notIn: [Int!]
}

"""Argument of Smart contract method or event"""
type ArgumentName {
  """Name"""
  name: String!

  """Type"""
  type: String!
}

"""Argument name and value of smart contract call or event"""
type ArgumentNameValue {
  """Argument name"""
  argument: String!

  """Argument data type"""
  argumentType: String!

  """Sequential index of value in array ( multi-dimensional)"""
  index: String!

  """Value as String"""
  value: String!
}

"""Selector of argument for smart contract method or event"""
input ArgumentSelector {
  """Argument is"""
  is: String

  """Argument not"""
  not: String

  """Argument in the list"""
  in: [String!]

  """Argument not in the list"""
  notIn: [String!]
}

"""Selector of argument type for smart contract method or event"""
input ArgumentTypeSelector {
  """Argument type is"""
  is: String

  """Argument type not"""
  not: String

  """Argument type in the list"""
  in: [String!]

  """Argument type not in the list"""
  notIn: [String!]
}

"""Argument value of smart contract call or event"""
type ArgumentValue {
  """Value as Address"""
  address: EthereumAddressInfo

  """Value as String"""
  value: String!
}

"""Selector of value of argument for smart contract method or event"""
input ArgumentValueSelector {
  """Value is"""
  is: String

  """Value not"""
  not: String

  """Value in the list"""
  in: [String!]

  """Value not in the list"""
  notIn: [String!]
}

enum BaseCurrencyEnum {
  """Dollar"""
  USD

  """Ethereum"""
  ETH

  """Tether USDT"""
  USDT

  """Bitcoin"""
  BTC
}

"""
Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar BigInt

"""Select by ID with BigInt datatype"""
input BigIntIdSelector {
  """ID is"""
  is: BigInt

  """ID not"""
  not: BigInt

  """ID in the list"""
  in: [BigInt!]

  """ID not in the list"""
  notIn: [BigInt!]

  """ID greater than"""
  gt: BigInt

  """ID less than"""
  lt: BigInt

  """ID less or equal than"""
  lteq: BigInt

  """ID greater or equal than"""
  gteq: BigInt

  """ID in range"""
  between: [BigInt!]
}

"""Binance DEX"""
type Binance {
  """Binance DEX Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector, any: [BinanceBlockFilter!], options: QueryOptions): [BinanceBlock!]

  """Money flow using Coinpath technology"""
  coinpath(sender: BinanceAddressSelector, receiver: BinanceAddressSelector, currency: [BinanceCurrencySelector!], initialAddress: BinanceAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [BinanceCoinpath!]

  """Binance DEX Network Exchange Orders"""
  orders(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!], any: [BinanceOrderFilter!], options: QueryOptions): [BinanceOrders!]

  """Binance DEX Network Trades between currencies"""
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], any: [BinanceTradeFilter!], options: QueryOptions): [BinanceTrades!]

  """Binance DEX Network Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!], any: [BinanceTransactionFilter!], options: QueryOptions): [BinanceTransactions!]

  """Binance DEX Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!], any: [BinanceTransferFilter!], options: QueryOptions): [BinanceTransfers!]
}

"""Binance Address should start with bnb and contain 42 chars."""
input BinanceAddressSelector {
  """Equal to Address"""
  is: String

  """Not Equal to Address"""
  not: String

  """In the list of Addresses"""
  in: String

  """Not in the list of Addresses"""
  notIn: String
}

"""Block"""
type BinanceBlock {
  any(of: BinanceBlocksMeasureable!): String

  """Block ID"""
  blockId(blockId: StringIdSelector): String
  count(uniq: BinanceBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector): Int
  countBigInt(uniq: BinanceBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector): BigInt

  """Calendar date"""
  date: Date

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String
  minimum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Validator consensus pubkey"""
  validatorConsensusPubkey(validatorConsensusPubkey: StringIdSelector): String

  """Validator fee address"""
  validatorFeeAddr(validatorFeeAddr: BinanceAddressSelector): Address

  """Validator moniker"""
  validatorMoniker(validatorMoniker: StringIdSelector): String

  """Validator operator HR address"""
  validatorOperaHrAddress(validatorOperaHrAddress: BinanceAddressSelector): Address

  """Validator operator address"""
  validatorOperatorAddress(validatorOperatorAddress: BinanceAddressSelector): Address
}

input BinanceBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: StringIdSelector
  validatorMoniker: StringIdSelector
  validatorFeeAddr: BinanceAddressSelector
  validatorOperatorAddress: BinanceAddressSelector
  validatorOperahraddress: BinanceAddressSelector
}

enum BinanceBlockUniq {
  """Validator operators"""
  validator_operator_addresses

  """Validator fee addresses"""
  validator_fee_addresses

  """Unique date count"""
  dates
}

enum BinanceBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Validator moniker"""
  validator_moniker
}

"""Coinpath"""
type BinanceCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

"""
Binance token selector by tokenId.
    Native binance token has BNB symbol.
    Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
"""
input BinanceCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

input BinanceOrderFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  orderOwner: [BinanceAddressSelector!]
  orderId: [OrderIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
  orderStatus: [OrderStatusSelector!]
  orderType: [OrderTypeSelector!]
  orderSide: [OrderSideSelector!]
  orderTimeInForce: [OrderTimeInForceSelector!]
}

enum BinanceOrderSide {
  """Sell Side"""
  sell

  """Buy Side"""
  buy
}

enum BinanceOrderStatus {
  """Ack"""
  Ack

  """Canceled"""
  Canceled

  """Fully Fill"""
  FullyFill

  """Partial Fill"""
  PartialFill

  """Expired"""
  Expired

  """Failed Blocking"""
  FailedBlocking

  """Ioc No Fill"""
  IocNoFill

  """Ioc Expire"""
  IocExpire
}

enum BinanceOrderTimeInForce {
  """Good Till Expiry"""
  GTE

  """Immediate Or Cancel"""
  IOC
}

enum BinanceOrderType {
  """Limit Order"""
  LimitOrder
}

"""Binance DEX Order"""
type BinanceOrders {
  any(of: BinanceOrdersMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  """Block where order transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceOrdersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Int
  countBigInt(uniq: BinanceOrdersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): BigInt

  """Calendar date"""
  date: Date
  maximum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String
  minimum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String

  """Order ID"""
  orderId(orderId: [OrderIdSelector!]): String

  """Order owner address"""
  orderOwner(owner: [BinanceAddressSelector!]): Address

  """Order Side"""
  orderSide(orderSide: [OrderSideSelector!]): BinanceOrderSide

  """Order Status"""
  orderStatus(orderStatus: [OrderStatusSelector!]): BinanceOrderStatus

  """Order Time In Force"""
  orderTimeInForce(orderTimeInForce: [OrderTimeInForceSelector!]): BinanceOrderTimeInForce

  """Order Type"""
  orderType(orderType: [OrderTypeSelector!]): BinanceOrderType
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  """Transaction where order created"""
  transaction(txHash: [HashSelector!]): TransactionHash
}

enum BinanceOrdersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Order owner"""
  order_owner

  """Order status"""
  order_status

  """Order ID"""
  order_id

  """Order side"""
  order_side

  """Base currency"""
  base_currency

  """Quote currency"""
  quote_currency

  """Quote Amount"""
  quote_amount

  """Base Amount"""
  base_amount

  """Price"""
  price
}

enum BinanceOrdersUniq {
  """Unique Transactions"""
  txs

  """Unique order owners"""
  owners

  """Unique base currencies"""
  base_currencies

  """Unique quote currencies"""
  quote_currencies

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique order ID count"""
  orders
}

input BinanceTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: [BinanceAddressSelector!]
  seller: [BinanceAddressSelector!]
  sellOrderId: [OrderIdSelector!]
  buyOrderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
}

"""Binance DEX Trades"""
type BinanceTrades {
  any(of: BinanceTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  """Block where trade transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Buy Order ID"""
  buyOrderId(buyOrderId: [OrderIdSelector!]): String

  """Trade buyer address"""
  buyer(buyer: [BinanceAddressSelector!]): Address
  count(uniq: BinanceTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Int
  countBigInt(uniq: BinanceTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): BigInt

  """Calendar date"""
  date: Date
  maximum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  minimum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  """Sell Order ID"""
  sellOrderId(sellOrderId: [OrderIdSelector!]): String

  """Trade seller address"""
  seller(seller: [BinanceAddressSelector!]): Address

  """Trade ID"""
  tradeId(tradeId: [TradeIdSelector!]): String

  """Transaction where trade happened"""
  transaction(txHash: [HashSelector!]): TransactionHashIndex
}

enum BinanceTradesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Buyer"""
  buyer

  """Seller"""
  seller

  """Trade ID"""
  trade_id

  """Buy Order ID"""
  buy_order_id

  """Sell Order ID"""
  sell_order_id

  """Base currency"""
  base_currency

  """Quote currency"""
  quote_currency

  """Quote Amount"""
  quote_amount

  """Base Amount"""
  base_amount

  """Price"""
  price
}

enum BinanceTradesUniq {
  """Trades"""
  trades

  """Sell Orders"""
  sell_orders

  """Buy Orders"""
  buy_orders

  """Unique Transactions"""
  txs

  """Unique buyers count"""
  buyers

  """Unique sellers count"""
  sellers

  """Unique base currencies"""
  base_currencies

  """Unique quote currencies"""
  quote_currencies

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input BinanceTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  transactionType: BinanceTransactionTypeSelector
  proposalId: StringIdSelector
  currency: [BinanceCurrencySelector!]
  transactionCode: IntIdSelector
  transactionSource: IntIdSelector
  deposit: [AmountSelector!]
}

enum BinanceTransactionType {
  """New Order"""
  NEW_ORDER

  """Cancel Order"""
  CANCEL_ORDER

  """Transfer"""
  TRANSFER

  """Vote"""
  VOTE

  """Unfreeze Token"""
  UNFREEZE_TOKEN

  """Burn"""
  BURN

  """Freeze Token"""
  FREEZE_TOKEN

  """Submit Proposal"""
  SUBMIT_PROPOSAL

  """Listing"""
  LISTING

  """Issue"""
  ISSUE

  """Deposit"""
  DEPOSIT

  """Mint"""
  MINT

  """Time Lock"""
  TimeLock

  """Time Unlock"""
  TimeUnlock

  """Time Relock"""
  TimeRelock

  """Set Account Flag"""
  SetAccountFlag

  """Hash Timer Locked Transfer"""
  HTL_TRANSFER

  """Hash Timer Locked Deposit"""
  DEPOSIT_HTL

  """Hash Timer Locked Claim"""
  CLAIM_HTL

  """Hash Timer Locked  Refund"""
  REFUND_HTL

  """Tiny Token Issue"""
  TINY_TOKEN_ISSUE

  """Mini Token Issue"""
  MINI_TOKEN_ISSUE

  """Tiny Token Listing"""
  TINY_TOKEN_LIST

  """Mini Token Listing"""
  MINI_TOKEN_LIST

  """Tiny Token Set URI"""
  TINY_TOKEN_SET_URI

  """Mini Token Set URI"""
  MINI_TOKEN_SET_URI

  """Create sidechain validator"""
  CREATE_SIDECHAIN_VALIDATOR

  """Edit sidechain validator"""
  EDIT_SIDECHAIN_VALIDATOR

  """Delegate for sidechain"""
  SIDECHAIN_DELEGATE

  """ReDelegate for sidechain"""
  SIDECHAIN_REDELEGATE

  """Unbond from sidechain"""
  SIDECHAIN_UNBOND

  """Unjail from sidechain"""
  SIDECHAIN_UNJAIL

  """Side chain submit poroposal"""
  SIDE_SUBMIT_PROPOSAL

  """Side chain deposit"""
  SIDE_DEPOSIT

  """Side chain vote"""
  SIDE_VOTE

  """Cross chain transfer"""
  TRANSFER_OUT

  """Submit evidence"""
  BSC_SUBMIT_EVIDENCE

  """Cross chain claim"""
  CLAIM

  """Bind"""
  BIND

  """UnBind"""
  UNBIND
}

"""Select by transaction type"""
input BinanceTransactionTypeSelector {
  """Transaction Type is"""
  is: BinanceTransactionType

  """Transaction Type not"""
  not: BinanceTransactionType

  """Transaction Type in the list"""
  in: [BinanceTransactionType!]

  """Transaction Type not in the list"""
  notIn: [BinanceTransactionType!]
}

"""Transaction"""
type BinanceTransactions {
  any(of: BinanceTransactionsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!]): Int
  countBigInt(uniq: BinanceTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!]): BigInt

  """Currency issued in transaction"""
  currency(currency: [BinanceCurrencySelector!]): Currency

  """Calendar date"""
  date: Date

  """Deposit amount in transaction"""
  deposit(deposit: [AmountSelector!]): Float

  """Transaction Description"""
  description: String

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """TX index in block, 0 based"""
  index: Int

  """Transaction Log"""
  log: String
  maximum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String

  """Transaction Memo"""
  memo: String
  minimum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String

  """Proposal ID"""
  proposalId(proposalId: [IntIdSelector!]): Int

  """Transaction Type"""
  transactionCode(transactionCode: IntIdSelector): Int

  """Transaction Source"""
  transactionSource(transactionSource: IntIdSelector): TransactionSource

  """Transaction Type"""
  transactionType(transactionType: [BinanceTransactionTypeSelector!]): BinanceTransactionType
}

enum BinanceTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction Source Name"""
  transaction_source_name

  """Transaction Source Code"""
  transaction_source_code

  """Transaction Code"""
  transaction_code

  """Transaction Type"""
  transaction_type

  """Transaction Memo"""
  transaction_memo

  """Currency"""
  currency_symbol
}

enum BinanceTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique transaction source count"""
  transaction_sources
}

input BinanceTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  sender: [BinanceAddressSelector!]
  receiver: [BinanceAddressSelector!]
  currency: [BinanceCurrencySelector!]
  transferType: [BinanceTransferTypeSelector!]
  orderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  amount: [AmountSelector!]
  outputIndex: [OutputIndexSelector!]
}

enum BinanceTransferType {
  """Reward for block"""
  BLOCK_REWARD

  """Burning amount"""
  BURN

  """Claiming Hash Timer Locked Transfer"""
  CLAIM_HTL

  """Deposit for Hash Timer Locked Transfer"""
  DEPOSIT_HTL

  """Fee for DEX orders"""
  DEX_FEE

  """Genesis declaration"""
  GENESIS_DELEGATION

  """Genesis supply declaration"""
  GENESIS_SUPPLY

  """Tiny Token Issue"""
  TINY_TOKEN_ISSUE

  """Mini Token Issue"""
  MINI_TOKEN_ISSUE

  """Hash Timer Locked Transfer"""
  HTL_TRANSFER

  """Issue token"""
  ISSUE

  """Mint token"""
  MINT

  """Trade buy side"""
  TRADE_BUY

  """Trade sell side"""
  TRADE_SELL

  """Transfer"""
  TRANSFER

  """Transaction fee"""
  TX_FEE

  """Create sidechain validator"""
  CREATE_SIDECHAIN_VALIDATOR

  """Edit sidechain validator"""
  EDIT_SIDECHAIN_VALIDATOR

  """Delegate for sidechain"""
  SIDECHAIN_DELEGATE

  """ReDelegate for sidechain"""
  SIDECHAIN_REDELEGATE

  """Unbond from sidechain"""
  SIDECHAIN_UNBOND

  """Side chain submit poroposal"""
  SIDE_SUBMIT_PROPOSAL

  """Side chain deposit"""
  SIDE_DEPOSIT

  """Side chain vote"""
  SIDE_VOTE

  """Cross chain transfer"""
  TRANSFER_OUT

  """Submit evidence"""
  BSC_SUBMIT_EVIDENCE

  """Cross chain claim"""
  CLAIM

  """Bind"""
  BIND

  """UnBind"""
  UNBIND
}

"""Select transfer type(s)"""
input BinanceTransferTypeSelector {
  """Transfer type is"""
  is: BinanceTransferType

  """Transfer type not"""
  not: BinanceTransferType

  """Transfer type in the list"""
  in: [BinanceTransferType!]

  """Transfer type not in the list"""
  notIn: [BinanceTransferType!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type BinanceTransfers {
  """Transfer amount"""
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Float
  any(of: BinanceTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Transfer count"""
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Int

  """Transfer count"""
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): BigInt

  """Currency of transfer"""
  currency(currency: [BinanceCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  maximum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String
  minimum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String

  """Order Id of trade where transfer happened"""
  orderId(orderId: [OrderIdSelector!]): String

  """Index of the output for the transfer, 0-based"""
  outputIndex(outputIndex: [OutputIndexSelector!]): Int

  """Transfer receiver"""
  receiver(receiver: [BinanceAddressSelector!]): Address

  """Transfer sender"""
  sender(sender: [BinanceAddressSelector!]): Address

  """Id of trade where transfer happened"""
  tradeId(tradeId: [TradeIdSelector!]): String

  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!]): TransactionHashIndex

  """Transfer type"""
  transferType(transferType: [BinanceTransferTypeSelector!]): BinanceTransferType
}

enum BinanceTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol
}

"""Bitcoin and other UTXO type blockchains"""
type Bitcoin {
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, transactionCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector, any: [BitcoinBlockFilter!], options: QueryOptions): [BitcoinBlock!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: BitcoinCoinpathOptions): [BitcoinCoinpath!]

  """Blockchain Transaction Inputs"""
  inputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector, any: [BitcoinInputFilter!], options: QueryOptions): [BitcoinTransactionInput!]

  """Blockchain Transaction OmniTransactions"""
  omniTransactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector, any: [BitcoinOmniTransactionsFilter!], options: QueryOptions): [BitcoinOmniTransactiosn!]

  """Blockchain Transaction OmniTransfers"""
  omniTransfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector, any: [BitcoinOmniTransfersFilter!], options: QueryOptions): [BitcoinOmniTransfers!]

  """Blockchain Transaction Outputs"""
  outputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector, any: [BitcoinOutputFilter!], options: QueryOptions): [BitcoinTransactionOutput!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn, any: [BitcoinTransactionFilter!], options: QueryOptions): [BitcoinTransaction!]
}

"""Block"""
type BitcoinBlock {
  any(of: BitcoinBlocksMeasureable!): String

  """Block Hash"""
  blockHash(blockHash: StringIdSelector): String

  """Block size"""
  blockSize(blockSize: IntegerSelector): Int

  """Block stripped size"""
  blockStrippedSize(blockStrippedSize: IntegerSelector): Int

  """Block version"""
  blockVersion(blockVersion: IntegerSelector): Int

  """Block weight"""
  blockWeight(blockWeight: IntegerSelector): Int

  """Block chainwork"""
  chainwork: String
  count(uniq: BitcoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): Int
  countBigInt(uniq: BitcoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): BigInt

  """Calendar date"""
  date: Date

  """Difficulty"""
  difficulty(difficulty: FloatSelector): Float

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  """Block median timestamp"""
  medianTime: DateTime
  minimum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Transaction count in block"""
  transactionCount(transactionCount: IntegerSelector): Int
}

input BitcoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockWeight: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  blockStrippedSize: IntegerSelector
  difficulty: FloatSelector
}

enum BitcoinBlockUniq {
  """Unique date count"""
  dates
}

enum BitcoinBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Tx Count"""
  transaction_count
}

"""Coinpath"""
type BitcoinCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: BitcoinTransactionHashIndexValues

  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

enum BitcoinCoinpathMethod {
  """Tracking money flow by amounts, ignoring coins (default)"""
  moneyflow

  """Tracking coins by UTXO transactions"""
  utxo
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input BitcoinCoinpathOptions {
  """Limit number of results"""
  limit: Int

  """Limit number of results by specific field"""
  limitBy: LimitByOption

  """Offset of results, starting from 0"""
  offset: Int

  """Ordering field(s) for ascending"""
  asc: [String!]

  """Ordering field(s) for descending"""
  desc: [String!]

  """Flow direction"""
  direction: FlowDirection

  """Do not include transactions below this amount"""
  minimumTxAmount: Float

  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int

  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """Invalidating cache seed"""
  seed: Int

  """Method to use coinpath"""
  coinpathMethod: BitcoinCoinpathMethod
}

input BitcoinInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputScriptType: BitcoinInputScriptTypeSelector
  inputValue: FloatSelector
}

enum BitcoinInputScriptType {
  """Input Script Signature"""
  scriptSig

  """Input Script TX Witness Script"""
  txinwitness

  """Input Script Coinbase Script"""
  coinbase
}

"""Selector of input script type"""
input BitcoinInputScriptTypeSelector {
  """Equal to Script Type"""
  is: BitcoinInputScriptType

  """Not Equal to Script Type"""
  not: BitcoinInputScriptType

  """In the list of Script Type"""
  in: [BitcoinInputScriptType!]

  """Not in the list of Script Type"""
  notIn: [BitcoinInputScriptType!]
}

enum BitcoinInputUniq {
  """Unique transactions count"""
  transactions

  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique addresses count"""
  addresses
}

enum BitcoinInputsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Amount"""
  amount

  """Address"""
  address

  """Input index"""
  input_index
}

enum BitcoinNetwork {
  """Bitcoin ( BTC )"""
  bitcoin

  """Bitcoin Cash ( BCH )"""
  bitcash

  """Bitcoin SV ( BSV )"""
  bitcoinsv

  """Litecoin ( LTC )"""
  litecoin

  """Dash ( DASH )"""
  dash

  """Dogecoin ( DOGE )"""
  dogecoin

  """ZCash ( ZCASH )"""
  zcash
}

input BitcoinOmniTransactionsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransactionsMeasureablse {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transactions hash"""
  tx_hash

  """Transactions index"""
  tx_index
}

enum BitcoinOmniTransactionsUniq {
  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique transaction sender"""
  tx_sender
}

"""OmniTransactions"""
type BitcoinOmniTransactiosn {
  any(of: BitcoinOmniTransactionsMeasureablse!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Hash of the block"""
  blockHash(blockHash: HashSelector): String!

  """OmniTransaction s count"""
  count(uniq: BitcoinOmniTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Int

  """OmniTransaction s count"""
  countBigInt(uniq: BitcoinOmniTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): BigInt

  """Calendar date"""
  date: Date

  """Transactions total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Float

  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!

  """OmniTransactions index in block, 0-based"""
  index(txIndex: IntegerSelector): String!

  """Invalid Reason"""
  invalidReason(invalidReason: StringSelector): String!

  """Invalid Reason"""
  json(json: StringSelector): String!
  maximum(of: BitcoinOmniTransactionsMeasureablse!, get: BitcoinOmniTransactionsMeasureablse): String
  minimum(of: BitcoinOmniTransactionsMeasureablse!, get: BitcoinOmniTransactionsMeasureablse): String

  """Transaction Sender"""
  txSender(txSender: HashSelector): String!

  """Type"""
  type(type: StringSelector): String!

  """Type Int"""
  typeInt(typeInt: IntegerSelector): Int!

  """Version"""
  valid(valid: IntegerSelector): Int!

  """Version"""
  version(version: IntegerSelector): Int!
}

"""OmniTransfers"""
type BitcoinOmniTransfers {
  any(of: BitcoinOmniTransfersMeasureablse!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Hash of the block"""
  blockHash(blockHash: HashSelector): String!

  """Transaction s count"""
  count(uniq: BitcoinOmniTransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Int

  """Transaction s count"""
  countBigInt(uniq: BitcoinOmniTransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): BigInt

  """Currency of transfer"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Direction"""
  direction(direction: StringSelector): String

  """Divisible"""
  divisible(divisible: IntegerSelector): Int

  """Transactions total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Float

  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!

  """Transactions index in block, 0-based"""
  index(txIndex: IntegerSelector): String!

  """Ismine"""
  ismine(ismine: IntegerSelector): Int
  maximum(of: BitcoinOmniTransfersMeasureablse!, get: BitcoinOmniTransfersMeasureablse): String
  minimum(of: BitcoinOmniTransfersMeasureablse!, get: BitcoinOmniTransfersMeasureablse): String

  """Transfer From"""
  transferFrom(transferFrom: HashSelector): String!

  """Transfer From"""
  transferTo(transferTo: HashSelector): String!

  """Transaction Sender"""
  txSender(txSender: HashSelector): String!

  """Type"""
  type(type: StringSelector): String!

  """Type Int"""
  typeInt(typeInt: IntegerSelector): Int!

  """value"""
  value(value: FloatSelector): Float
}

input BitcoinOmniTransfersFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransfersMeasureablse {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transactions hash"""
  tx_hash

  """Transactions index"""
  tx_index
}

enum BitcoinOmniTransfersUniq {
  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique transaction sender"""
  tx_sender
}

enum BitcoinOutputDirection {
  """Not defined"""
  unknown

  """Not a change return"""
  not_change

  """Change return"""
  change

  """Likely Not a change return"""
  likely_not_change

  """Likely Change return"""
  likely_change

  """Mining"""
  mining

  """Fee"""
  fee

  """Minting"""
  minting

  """Genesis"""
  genesis
}

"""A guessed direction of output"""
input BitcoinOutputDirectionSelector {
  """Equal to direction"""
  is: BitcoinOutputDirection

  """Not Equal to direction"""
  not: BitcoinOutputDirection

  """In the list of direction"""
  in: [BitcoinOutputDirection!]

  """Not in the list of direction"""
  notIn: [BitcoinOutputDirection!]
}

input BitcoinOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputScriptType: BitcoinOutputScriptTypeSelector
  outputDirection: BitcoinOutputDirectionSelector
  outputValue: FloatSelector
}

enum BitcoinOutputScriptType {
  """Output PubKey"""
  pubkey

  """Output PubKey Hash"""
  pubkeyhash

  """Output Script Hash"""
  scripthash

  """Output Witness Key Hash"""
  witness_v0_keyhash

  """Output nulldata"""
  nulldata

  """Output Witness Script Hash"""
  witness_v0_scripthash

  """Non standard output script"""
  nonstandard

  """Output Multisignature Wallet"""
  multisig

  """Output Witness Other"""
  witness_unknown
}

"""Selector of output script type"""
input BitcoinOutputScriptTypeSelector {
  """Equal to Script Type"""
  is: BitcoinOutputScriptType

  """Not Equal to Script Type"""
  not: BitcoinOutputScriptType

  """In the list of Script Type"""
  in: [BitcoinOutputScriptType!]

  """Not in the list of Script Type"""
  notIn: [BitcoinOutputScriptType!]
}

enum BitcoinOutputUniq {
  """Unique transactions count"""
  transactions

  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique input addresses count"""
  addresses
}

enum BitcoinOutputsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Amount"""
  amount

  """Address"""
  address

  """Output index"""
  output_index
}

"""Transaction"""
type BitcoinTransaction {
  any(of: BitcoinTransactionsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Transaction  count"""
  count(uniq: BitcoinTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction  count"""
  countBigInt(uniq: BitcoinTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Calendar date"""
  date: Date

  """Transaction total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total fee value"""
  feeValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber

  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!

  """Transaction index in block, 0-based"""
  index(txIndex: IntegerSelector): String!

  """Transaction total input count"""
  inputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction total input count"""
  inputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Transaction total input value"""
  inputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total input value as decimal"""
  inputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber
  maximum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String

  """Transaction total mined value"""
  minedValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total mined value"""
  minedValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber
  minimum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String

  """Transaction total output count"""
  outputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction total output count"""
  outputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Transaction total output value"""
  outputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total output value"""
  outputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber

  """Transaction is coinbase"""
  txCoinbase(txCoinbase: Boolean): Boolean

  """Transaction locktime"""
  txLocktime(txLocktime: IntegerSelector): BigInt

  """Transaction size"""
  txSize(txSize: IntegerSelector): Int

  """Transaction version"""
  txVersion(txVersion: IntegerSelector): Int

  """Transaction vsize"""
  txVsize(txVsize: IntegerSelector): Int

  """Transaction weight"""
  txWeight(txWeight: IntegerSelector): Int
}

input BitcoinTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  txVsize: IntegerSelector
  txWeight: IntegerSelector
  txVersion: IntegerSelector
  txCoinbase: Boolean
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  minedValue: FloatSelector
  txLocktime: IntegerSelector
  outputAddress: AddressSelectorIn
  inputAddress: AddressSelectorIn
}

"""Blockchain transaction"""
type BitcoinTransactionHashIndexValues {
  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0-based"""
  index: String!

  """Transaction value in input"""
  valueIn: Float!

  """Transaction value in input"""
  valueInDecimal: DecimalNumber!

  """Transaction value in output"""
  valueOut: Float!

  """Transaction value in output"""
  valueOutDecimal: DecimalNumber!
}

"""Transaction Input"""
type BitcoinTransactionInput {
  any(of: BitcoinInputsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Input count"""
  count(uniq: BitcoinInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): Int

  """Input count"""
  countBigInt(uniq: BitcoinInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): BigInt

  """Calendar date"""
  date: Date

  """Input address"""
  inputAddress(inputAddress: AddressSelector): Address

  """Input index"""
  inputIndex(inputIndex: IntegerSelector): Int

  """Input script"""
  inputScript: String

  """Input script type and attributes"""
  inputScriptType(inputScriptType: BitcoinInputScriptTypeSelector): InputScript
  maximum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String
  minimum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String

  """Output Transaction for this input"""
  outputTransaction(inOutputTxId: StringIdSelector, inOutputIndex: IntegerSelector): TransactionHashIndex

  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  """Input value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): Float

  """Input value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): DecimalNumber
}

"""Transaction Output"""
type BitcoinTransactionOutput {
  any(of: BitcoinOutputsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Output count"""
  count(uniq: BitcoinOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Int

  """Output count"""
  countBigInt(uniq: BitcoinOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): BigInt

  """Calendar date"""
  date: Date
  maximum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String
  minimum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String

  """Output address"""
  outputAddress(outputAddress: AddressSelector): Address

  """Output guessed direction"""
  outputDirection(outputDirection: BitcoinOutputDirectionSelector): BitcoinOutputDirection

  """Output index"""
  outputIndex(outputIndex: IntegerSelector): Int

  """Output script"""
  outputScript: String

  """Output script type and attributes"""
  outputScriptType(inputScriptType: BitcoinOutputScriptTypeSelector): OutputScript
  reqSigs: Int

  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  """Output value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Float

  """Output value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): DecimalNumber
}

enum BitcoinTransactionUniq {
  """Unique block count"""
  blocks

  """Unique date count"""
  dates
}

enum BitcoinTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Input count"""
  input_count

  """Output count"""
  output_count

  """Transaction size"""
  tx_size

  """Transaction input value"""
  input_value

  """Transaction output value"""
  output_value
}

"""Block"""
type Block {
  """Block number (height) in blockchain"""
  height: Int!

  """Block timestamp"""
  timestamp: DateTime
}

"""BlockExtended"""
type BlockExtended {
  """Hash hex representation"""
  hash: String!

  """Block number (height) in blockchain"""
  height: Int!

  """Block timestamp"""
  timestamp: DateTime
}

"""ConfluxBlock"""
type BlockInfo {
  """Block hash"""
  hash: String

  """Block number (height) in blockchain"""
  height: Int!

  """Block timestamp"""
  timestamp: DateTime
}

"""Select block by height ( sequence number)"""
input BlockSelector {
  """Block height is"""
  is: Int

  """Block height not"""
  not: Int

  """Block height in the list"""
  in: [Int!]

  """Block height not in the list"""
  notIn: [Int!]

  """Block height greater than"""
  gt: Int

  """Block height less than"""
  lt: Int

  """Block height less or equal than"""
  lteq: Int

  """Block height greater or equal than"""
  gteq: Int

  """Block height in range"""
  between: [Int!]
}

"""Select block by height ( sequence number)"""
input BlockSelectorRange {
  """Block height less or equal than"""
  lteq: Int

  """Block height greater or equal than"""
  gteq: Int

  """Block height in range"""
  between: [Int!]
}

"""Blockchain network"""
type BlockchainNetwork {
  """Network name"""
  network: Network!

  """Network protocol type"""
  protocol: Protocol!
}

"""Select by boolean (sequence number)"""
input BooleanSelector {
  """Is"""
  is: Boolean

  """Is not"""
  not: Boolean
}

"""Information about call"""
type CallElrond {
  """
  Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """Contract method invoked"""
  smartContractAddress(smartContractAddress: HashSelector): String

  """Smart contract name"""
  smartContractName(smartContractName: StringSelector): String

  """Smart contract signature"""
  smartContractSignature(smartContractSignature: StringSelector): String

  """Signature Hash"""
  smartContractSignatureHash(smartContractSignatureHash: HashSelector): String
}

"""Cardano"""
type Cardano {
  """Information about address"""
  address(address: [AddressSelectorIn!]!): [CardanoAddressInfo!]!

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockVersion: IntegerSelector, transactionCount: IntegerSelector, epoch: IntegerSelector, slot: IntegerSelector, slotInEpoch: IntegerSelector, opCert: StringSelector, slotLeaderHash: StringSelector, vrfKey: StringSelector, version: StringSelector, any: [CardanoBlockFilter!], options: QueryOptions): [CardanoBlock!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, currency: [CardanoCurrencySelector!], options: CardanoCoinpathOptions): [CardanoCoinpath!]

  """Blockchain Transaction Inputs"""
  inputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!], any: [CardanoInputFilter!], options: QueryOptions): [CardanoTransactionInput!]

  """Blockchain Tokens Mints"""
  mints(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!], any: [CardanoMintFilter!], options: QueryOptions): [CardanoTransactionMint!]

  """Blockchain Transaction Outputs"""
  outputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!], any: [CardanoOutputFilter!], options: QueryOptions): [CardanoTransactionOutput!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn, any: [CardanoTransactionFilter!], options: QueryOptions): [CardanoTransaction!]
}

"""Address balance information for Cardano network"""
type CardanoAddressBalance {
  """Currency"""
  currency: Currency

  """Currency value"""
  value: Float
}

"""Address detailed information for Cardano network"""
type CardanoAddressInfo {
  """Address"""
  address: Address

  """Current address balances"""
  balance: [CardanoAddressBalance!]

  """Current staking addressese info"""
  staking: [CardanoStakingAddress!]
}

"""Block"""
type CardanoBlock {
  any(of: CardanoBlocksMeasureable!): String

  """Block Hash"""
  blockHash(blockHash: StringIdSelector): String

  """Block size"""
  blockSize(blockSize: IntegerSelector): Int

  """Block version"""
  blockVersion(blockVersion: IntegerSelector): Int
  count(uniq: CardanoBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): Int
  countBigInt(uniq: CardanoBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): BigInt

  """Calendar date"""
  date: Date

  """Epoch number"""
  epoch: Int

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: CardanoBlocksMeasureable!, get: CardanoBlocksMeasureable): String
  minimum(of: CardanoBlocksMeasureable!, get: CardanoBlocksMeasureable): String

  """Op cert"""
  opCert: String

  """Slot number"""
  slot: Int

  """Slot in epoch number"""
  slotInEpoch: Int

  """Slot leader description"""
  slotLeaderDescription: String

  """Slot leader hash"""
  slotLeaderHash: String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Transaction count in block"""
  transactionCount(transactionCount: IntegerSelector): Int

  """VRF Key"""
  vrfKey: String
}

input CardanoBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  epoch: IntegerSelector
  slot: IntegerSelector
  slotInEpoch: IntegerSelector
  opCert: StringSelector
  slotLeaderHash: StringSelector
  vrfKey: StringSelector
  version: StringSelector
}

enum CardanoBlockUniq {
  """Unique date count"""
  dates

  """Unique epoch"""
  epoch

  """Unique slot"""
  slot

  """Unique slot leader"""
  slot_leader

  """Unique version"""
  version
}

enum CardanoBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Tx Count"""
  transaction_count
}

"""Coinpath"""
type CardanoCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: CardanoTransactionHashIndexValues

  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

enum CardanoCoinpathMethod {
  """Tracking money flow by amounts, ignoring coins (default)"""
  moneyflow

  """Tracking coins by UTXO transactions"""
  utxo
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input CardanoCoinpathOptions {
  """Limit number of results"""
  limit: Int

  """Limit number of results by specific field"""
  limitBy: LimitByOption

  """Offset of results, starting from 0"""
  offset: Int

  """Ordering field(s) for ascending"""
  asc: [String!]

  """Ordering field(s) for descending"""
  desc: [String!]

  """Flow direction"""
  direction: FlowDirection

  """Do not include transactions below this amount"""
  minimumTxAmount: Float

  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int

  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """Invalidating cache seed"""
  seed: Int

  """Method to use coinpath"""
  coinpathMethod: CardanoCoinpathMethod
}

"""
Cardano token selector by tokenId.
    Native binance token has ADA symbol, pass it as argument.
    Otherwise pass asset fingerprint, starting from asset...
"""
input CardanoCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

input CardanoInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputValue: FloatSelector
  currency: [CardanoCurrencySelector!]
}

enum CardanoInputSource {
  """Input"""
  input

  """Withdrawal"""
  withdrawal
}

enum CardanoInputUniq {
  """Unique transactions count"""
  transactions

  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique addresses count"""
  addresses

  """Unique currencies count"""
  currencies
}

enum CardanoInputsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Amount"""
  amount

  """Address"""
  address

  """Input index"""
  input_index
}

input CardanoMintFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  value: FloatSelector
  currency: [CardanoCurrencySelector!]
}

enum CardanoMintUniq {
  """Unique transactions count"""
  transactions

  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique currencies count"""
  currencies
}

enum CardanoMintsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Amount"""
  amount
}

enum CardanoNetwork {
  """Cardano ( ADA )"""
  cardano
}

enum CardanoOutputDirection {
  """Not defined"""
  unknown

  """Not a change return"""
  not_change

  """Change return"""
  change

  """Likely Not a change return"""
  likely_not_change

  """Likely Change return"""
  likely_change

  """Mining"""
  mining

  """Fee"""
  fee

  """Minting"""
  minting

  """Genesis"""
  genesis
}

"""A guessed direction of output"""
input CardanoOutputDirectionSelector {
  """Equal to direction"""
  is: CardanoOutputDirection

  """Not Equal to direction"""
  not: CardanoOutputDirection

  """In the list of direction"""
  in: [CardanoOutputDirection!]

  """Not in the list of direction"""
  notIn: [CardanoOutputDirection!]
}

input CardanoOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputDirection: CardanoOutputDirectionSelector
  outputValue: FloatSelector
  currency: [CardanoCurrencySelector!]
}

enum CardanoOutputUniq {
  """Unique transactions count"""
  transactions

  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique input addresses count"""
  addresses

  """Unique currencies count"""
  currencies
}

enum CardanoOutputsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Amount"""
  amount

  """Address"""
  address

  """Output index"""
  output_index
}

"""Address staking information for Cardano network"""
type CardanoStakingAddress {
  """Staking Address"""
  address: Address

  """Rewards value"""
  rewardsAmount: Float

  """Staked value"""
  stakedAmount: Float

  """Staked value including rewards"""
  stakedAmountWithRewards: Float

  """Withdrawn value"""
  withdrawnAmount: Float
}

"""Transaction"""
type CardanoTransaction {
  any(of: CardanoTransactionsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Transaction  count"""
  count(uniq: CardanoTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction  count"""
  countBigInt(uniq: CardanoTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Calendar date"""
  date: Date

  """Transaction total deposit value"""
  depositValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total fee value"""
  depositValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv

  """Transaction total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total fee value"""
  feeValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv

  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!

  """Included at timestamp"""
  includedAt: DateTime

  """Transaction index in block, 0-based"""
  index(txIndex: IntegerSelector): String!

  """Transaction total input count"""
  inputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction total input count"""
  inputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Transaction total input value"""
  inputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total input value as decimal"""
  inputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv

  """Invalid before"""
  invalidBefore: String

  """Invalid hereafter"""
  invalidHereafter: String
  maximum(of: CardanoTransactionsMeasureable!, get: CardanoTransactionsMeasureable): String

  """Metadata"""
  metadata: String
  minimum(of: CardanoTransactionsMeasureable!, get: CardanoTransactionsMeasureable): String

  """Transaction total mint count"""
  mintCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction total mint count"""
  mintCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Transaction total output count"""
  outputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction total output count"""
  outputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Transaction total output value"""
  outputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total output value"""
  outputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv

  """Transaction size"""
  txSize(txSize: IntegerSelector): Int

  """Transaction total withdrawal count"""
  withdrawalCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int

  """Transaction total withdrawal count"""
  withdrawalCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt

  """Transaction total withdrawal value"""
  withdrawalValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float

  """Transaction total fee value"""
  withdrawalValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv
}

input CardanoTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  withdrawalCount: IntegerSelector
  mintCount: IntegerSelector
  withdrawalValue: FloatSelector
  depositValue: FloatSelector
  outputAddress: AddressSelectorIn
  inputAddress: AddressSelectorIn
}

"""Blockchain transaction"""
type CardanoTransactionHashIndexValues {
  depositValue: Float!

  """Transaction deposit value as decimal"""
  depositValueDecimal: DecimalNumberAsDiv!
  feeValue: Float!

  """Transaction fee value as decimal"""
  feeValueDecimal: DecimalNumberAsDiv!

  """Hash hex representation"""
  hash: String!
  includedAt: DateTime!

  """Transaction index in block, 0-based"""
  index: String!
  invalidBefore: String!
  invalidHereafter: String!
  metadata: String!
  txSize: Int!

  """Transaction value in input"""
  valueIn: Float!

  """Transaction value in input as decimal"""
  valueInDecimal: DecimalNumberAsDiv!

  """Transaction value in output"""
  valueOut: Float!

  """Transaction value in output as decimal"""
  valueOutDecimal: DecimalNumberAsDiv!
  withdrawalValue: Float!

  """Transaction withdraw value as decimal"""
  withdrawalValueDecimal: DecimalNumberAsDiv!
}

"""Transaction Input"""
type CardanoTransactionInput {
  any(of: CardanoInputsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Input count"""
  count(uniq: CardanoInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!]): Int

  """Input count"""
  countBigInt(uniq: CardanoInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!]): BigInt

  """Currency of the input"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Input address"""
  inputAddress(inputAddress: AddressSelector): Address

  """Input index"""
  inputIndex(inputIndex: IntegerSelector): Int
  maximum(of: CardanoInputsMeasureable!, get: CardanoInputsMeasureable): String
  minimum(of: CardanoInputsMeasureable!, get: CardanoInputsMeasureable): String

  """Output Transaction for this input"""
  outputTransaction(inOutputTxId: StringIdSelector, inOutputIndex: IntegerSelector): TransactionHashIndex

  """Source of the input"""
  source: CardanoInputSource

  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  """Input value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!]): Float

  """Input value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!]): DecimalNumberAsDiv
}

"""Transaction Mint"""
type CardanoTransactionMint {
  any(of: CardanoMintsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Mint count"""
  count(uniq: CardanoMintUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!]): Int

  """Mint count"""
  countBigInt(uniq: CardanoMintUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!]): BigInt

  """Currency of the mint"""
  currency: Currency

  """Calendar date"""
  date: Date
  maximum(of: CardanoMintsMeasureable!, get: CardanoMintsMeasureable): String
  minimum(of: CardanoMintsMeasureable!, get: CardanoMintsMeasureable): String

  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  """Mint value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!]): Float
}

"""Transaction Output"""
type CardanoTransactionOutput {
  any(of: CardanoOutputsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Output count"""
  count(uniq: CardanoOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!]): Int

  """Output count"""
  countBigInt(uniq: CardanoOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!]): BigInt

  """Currency of the output"""
  currency: Currency

  """Calendar date"""
  date: Date
  maximum(of: CardanoOutputsMeasureable!, get: CardanoOutputsMeasureable): String
  minimum(of: CardanoOutputsMeasureable!, get: CardanoOutputsMeasureable): String

  """Output address"""
  outputAddress(outputAddress: AddressSelector): Address

  """Output guessed direction"""
  outputDirection(outputDirection: CardanoOutputDirectionSelector): CardanoOutputDirection

  """Output index"""
  outputIndex(outputIndex: IntegerSelector): Int

  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  """Output value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!]): Float

  """Input value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!]): DecimalNumberAsDiv
}

enum CardanoTransactionUniq {
  """Unique block count"""
  blocks

  """Unique date count"""
  dates
}

enum CardanoTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Input count"""
  input_count

  """Output count"""
  output_count

  """Transaction size"""
  tx_size

  """Transaction input value"""
  input_value

  """Transaction output value"""
  output_value

  """Transaction withdrawal value"""
  withdrawal_value

  """Transaction deposit value"""
  deposit_value

  """Transaction withdrawal count"""
  withdrawal_count

  """Transaction mint count"""
  mint_count
}

"""Transaction attributes in coinpath"""
type CoinpathEntry {
  """Amount involved in the flow"""
  amount: Float!

  """Block of transaction"""
  height: Int!

  """Time of transaction in ISO 8601 format"""
  timestamp: ISO8601DateTime!

  """Hash of transaction"""
  txHash: String!

  """Amount transfered in transaction"""
  txValue: Float!
}

enum CoinpathMeasureable {
  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Depth"""
  depth
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input CoinpathOptions {
  """Limit number of results"""
  limit: Int

  """Limit number of results by specific field"""
  limitBy: LimitByOption

  """Offset of results, starting from 0"""
  offset: Int

  """Ordering field(s) for ascending"""
  asc: [String!]

  """Ordering field(s) for descending"""
  desc: [String!]

  """Flow direction"""
  direction: FlowDirection

  """Do not include transactions below this amount"""
  minimumTxAmount: Float

  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int

  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """Invalidating cache seed"""
  seed: Int
}

"""Conflux Chain"""
type Conflux {
  """Basic information about address ( or smart contract )"""
  address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!

  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, any: [EthereumArgumentFilter!], options: QueryOptions): [EthereumArguments!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [ConfluxBlockFilter!], options: QueryOptions): [ConfluxBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: EthereumAddressSelector, receiver: EthereumAddressSelector, currency: [EthereumCurrencySelector!], initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EthereumCoinpath!]

  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!], any: [EthereumSmartContractCallFilter!], options: QueryOptions): [EthereumSmartContractCalls!]

  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, any: [EthereumSmartContractEventFilter!], options: QueryOptions): [EthereumSmartContractEvent!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector, any: [ConfluxTransactionFilter!], options: QueryOptions): [ConfluxTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!], any: [EthereumTransferFilter!], options: QueryOptions): [EthereumTransfers!]
}

input ConfluxBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  epoch: BlockSelector
  pivot: Boolean
  blockHash: HashSelector
  referenceBlockHash: HashSelector
  miner: [EthereumAddressSelector!]
  refereeCount: [IntegerSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""Blocks in Conflux blockchain"""
type ConfluxBlocks {
  """Block is adaptive"""
  adaptive: Boolean!
  any(of: ConfluxBlocksMeasureable!): String

  """Blame"""
  blame: Int!

  """Block index in epoch"""
  blockPosition: Int!
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  countBigInt(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Epoch in blockchain"""
  epoch(height: BlockSelector): Int!

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block height in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  """Block miner"""
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  """Block nonce"""
  nonce: Int!

  """Parent block hash"""
  parentHash: String!

  """Block is pivot"""
  pivot: Boolean!

  """Power Quality"""
  powerQuality: BigInt!
  refereeCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  refereeCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt

  """Reference Block hash"""
  referenceBlockHash(referenceBlockHash: [HashSelector!]): String!
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  transactionCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt

  """Hash of Transaction included in block"""
  txHash(txHash: [HashSelector!]): String!
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  uncleCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
}

enum ConfluxBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Miner"""
  miner

  """Block Referee Count"""
  referee_count

  """Block TX Count"""
  transaction_count
}

enum ConfluxNetwork {
  """Conflux Oceanus"""
  conflux_oceanus

  """Conflux Tethys"""
  conflux_tethys
}

input ConfluxTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  blockHash: HashSelector
}

"""Transactions in Conflux blockchain"""
type ConfluxTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float
  any(of: ConfluxTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(blockHash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockInfo
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int
  countBigInt(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): BigInt

  """Created smart contract"""
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo

  """Currency of amount"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Error message if any"""
  error: String
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int

  """Currency of gas"""
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String
  minimum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String

  """Transaction nonce"""
  nonce: Int

  """Transaction sender"""
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo

  """Success"""
  success(success: Boolean): Boolean

  """Transaction receiver"""
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

enum ConfluxTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Transaction Sender"""
  tx_sender

  """Gas value"""
  gas_value

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

enum Continent {
  """Africa"""
  Africa

  """Asia"""
  Asia

  """Europe"""
  Europe

  """North America"""
  North_America

  """Oceania"""
  Oceania

  """South America"""
  South_America

  """Antarctica"""
  Antarctica
}

"""Continent selector"""
input ContinentSelector {
  """Country code is"""
  is: Continent

  """Country code not"""
  not: Continent

  """Country code in the list"""
  in: [Continent!]

  """Country code not in the list"""
  notIn: [Continent!]
}

enum CountryCode {
  """Afghanistan"""
  AF

  """Albania"""
  AL

  """Algeria"""
  DZ

  """American Samoa"""
  AS

  """Andorra"""
  AD

  """Angola"""
  AO

  """Anguilla"""
  AI

  """Antarctica"""
  AQ

  """Antigua and Barbuda"""
  AG

  """Argentina"""
  AR

  """Armenia"""
  AM

  """Aruba"""
  AW

  """Australia"""
  AU

  """Austria"""
  AT

  """Azerbaijan"""
  AZ

  """Bahamas"""
  BS

  """Bahrain"""
  BH

  """Bangladesh"""
  BD

  """Barbados"""
  BB

  """Belarus"""
  BY

  """Belgium"""
  BE

  """Belize"""
  BZ

  """Benin"""
  BJ

  """Bermuda"""
  BM

  """Bhutan"""
  BT

  """Bolivia"""
  BO

  """Bosnia and Herzegovina"""
  BA

  """Botswana"""
  BW

  """Brazil"""
  BR

  """British Indian Ocean Territory"""
  IO

  """British Virgin Islands"""
  VG

  """Brunei"""
  BN

  """Bulgaria"""
  BG

  """Burkina Faso"""
  BF

  """Burundi"""
  BI

  """Cambodia"""
  KH

  """Cameroon"""
  CM

  """Canada"""
  CA

  """Cape Verde"""
  CV

  """Cayman Islands"""
  KY

  """Central African Republic"""
  CF

  """Chad"""
  TD

  """Chile"""
  CL

  """China"""
  CN

  """Christmas Island"""
  CX

  """Cocos Islands"""
  CC

  """Colombia"""
  CO

  """Comoros"""
  KM

  """Cook Islands"""
  CK

  """Costa Rica"""
  CR

  """Croatia"""
  HR

  """Cuba"""
  CU

  """Curacao"""
  CW

  """Cyprus"""
  CY

  """Czech Republic"""
  CZ

  """Democratic Republic of the Congo"""
  CD

  """Denmark"""
  DK

  """Djibouti"""
  DJ

  """Dominica"""
  DM

  """Dominican Republic"""
  DO

  """East Timor"""
  TL

  """Ecuador"""
  EC

  """Egypt"""
  EG

  """El Salvador"""
  SV

  """Equatorial Guinea"""
  GQ

  """Eritrea"""
  ER

  """Estonia"""
  EE

  """Ethiopia"""
  ET

  """Falkland Islands"""
  FK

  """Faroe Islands"""
  FO

  """Fiji"""
  FJ

  """Finland"""
  FI

  """France"""
  FR

  """French Polynesia"""
  PF

  """Gabon"""
  GA

  """Gambia"""
  GM

  """Georgia"""
  GE

  """Germany"""
  DE

  """Ghana"""
  GH

  """Gibraltar"""
  GI

  """Greece"""
  GR

  """Greenland"""
  GL

  """Grenada"""
  GD

  """Guam"""
  GU

  """Guatemala"""
  GT

  """Guernsey"""
  GG

  """Guinea"""
  GN

  """Guinea-Bissau"""
  GW

  """Guyana"""
  GY

  """Haiti"""
  HT

  """Honduras"""
  HN

  """Hong Kong"""
  HK

  """Hungary"""
  HU

  """Iceland"""
  IS

  """India"""
  IN

  """Indonesia"""
  ID

  """Iran"""
  IR

  """Iraq"""
  IQ

  """Ireland"""
  IE

  """Isle of Man"""
  IM

  """Israel"""
  IL

  """Italy"""
  IT

  """Ivory Coast"""
  CI

  """Jamaica"""
  JM

  """Japan"""
  JP

  """Jersey"""
  JE

  """Jordan"""
  JO

  """Kazakhstan"""
  KZ

  """Kenya"""
  KE

  """Kiribati"""
  KI

  """Kosovo"""
  XK

  """Kuwait"""
  KW

  """Kyrgyzstan"""
  KG

  """Laos"""
  LA

  """Latvia"""
  LV

  """Lebanon"""
  LB

  """Lesotho"""
  LS

  """Liberia"""
  LR

  """Libya"""
  LY

  """Liechtenstein"""
  LI

  """Lithuania"""
  LT

  """Luxembourg"""
  LU

  """Macau"""
  MO

  """Macedonia"""
  MK

  """Madagascar"""
  MG

  """Malawi"""
  MW

  """Malaysia"""
  MY

  """Maldives"""
  MV

  """Mali"""
  ML

  """Malta"""
  MT

  """Marshall Islands"""
  MH

  """Mauritania"""
  MR

  """Mauritius"""
  MU

  """Mayotte"""
  YT

  """Mexico"""
  MX

  """Micronesia"""
  FM

  """Moldova"""
  MD

  """Monaco"""
  MC

  """Mongolia"""
  MN

  """Montenegro"""
  ME

  """Montserrat"""
  MS

  """Morocco"""
  MA

  """Mozambique"""
  MZ

  """Myanmar"""
  MM

  """Namibia"""
  NA

  """Nauru"""
  NR

  """Nepal"""
  NP

  """Netherlands"""
  NL

  """Netherlands Antilles"""
  AN

  """New Caledonia"""
  NC

  """New Zealand"""
  NZ

  """Nicaragua"""
  NI

  """Niger"""
  NE

  """Nigeria"""
  NG

  """Niue"""
  NU

  """North Korea"""
  KP

  """Northern Mariana Islands"""
  MP

  """Norway"""
  NO

  """Oman"""
  OM

  """Pakistan"""
  PK

  """Palau"""
  PW

  """Palestine"""
  PS

  """Panama"""
  PA

  """Papua New Guinea"""
  PG

  """Paraguay"""
  PY

  """Peru"""
  PE

  """Philippines"""
  PH

  """Pitcairn"""
  PN

  """Poland"""
  PL

  """Portugal"""
  PT

  """Puerto Rico"""
  PR

  """Qatar"""
  QA

  """Republic of the Congo"""
  CG

  """Reunion"""
  RE

  """Romania"""
  RO

  """Russia"""
  RU

  """Rwanda"""
  RW

  """Saint Barthelemy"""
  BL

  """Saint Helena"""
  SH

  """Saint Kitts and Nevis"""
  KN

  """Saint Lucia"""
  LC

  """Saint Martin"""
  MF

  """Saint Pierre and Miquelon"""
  PM

  """Saint Vincent and the Grenadines"""
  VC

  """Samoa"""
  WS

  """San Marino"""
  SM

  """Sao Tome and Principe"""
  ST

  """Saudi Arabia"""
  SA

  """Senegal"""
  SN

  """Serbia"""
  RS

  """Seychelles"""
  SC

  """Sierra Leone"""
  SL

  """Singapore"""
  SG

  """Sint Maarten"""
  SX

  """Slovakia"""
  SK

  """Slovenia"""
  SI

  """Solomon Islands"""
  SB

  """Somalia"""
  SO

  """South Africa"""
  ZA

  """South Korea"""
  KR

  """South Sudan"""
  SS

  """Spain"""
  ES

  """Sri Lanka"""
  LK

  """Sudan"""
  SD

  """Suriname"""
  SR

  """Svalbard and Jan Mayen"""
  SJ

  """Swaziland"""
  SZ

  """Sweden"""
  SE

  """Switzerland"""
  CH

  """Syria"""
  SY

  """Taiwan"""
  TW

  """Tajikistan"""
  TJ

  """Tanzania"""
  TZ

  """Thailand"""
  TH

  """Togo"""
  TG

  """Tokelau"""
  TK

  """Tonga"""
  TO

  """Trinidad and Tobago"""
  TT

  """Tunisia"""
  TN

  """Turkey"""
  TR

  """Turkmenistan"""
  TM

  """Turks and Caicos Islands"""
  TC

  """Tuvalu"""
  TV

  """U.S. Virgin Islands"""
  VI

  """Uganda"""
  UG

  """Ukraine"""
  UA

  """United Arab Emirates"""
  AE

  """United Kingdom"""
  GB

  """United States"""
  US

  """Uruguay"""
  UY

  """Uzbekistan"""
  UZ

  """Vanuatu"""
  VU

  """Vatican"""
  VA

  """Venezuela"""
  VE

  """Vietnam"""
  VN

  """Wallis and Futuna"""
  WF

  """Western Sahara"""
  EH

  """Yemen"""
  YE

  """Zambia"""
  ZM

  """Zimbabwe"""
  ZW
}

"""Country selector by 3 digit ISO code"""
input CountrySelector {
  """Country code is"""
  is: CountryCode

  """Country code not"""
  not: CountryCode

  """Country code in the list"""
  in: [CountryCode!]

  """Country code not in the list"""
  notIn: [CountryCode!]
}

"""Country"""
type CovidCountry {
  """Area, km2"""
  areaKm2: Float

  """Continent name"""
  continent: Continent

  """Gross Domestic Product"""
  gdp: Float

  """ISO 2 letter code"""
  iso2: CountryCode

  """ISO 3 letter code"""
  iso3: String

  """ISO numeric code"""
  isoNumeric: Int

  """Location latitude"""
  latitude: Float

  """Location longitude"""
  longitude: Float

  """Country name"""
  name: String

  """Population density in thousands per km2"""
  populationPerKm2: Float

  """Population total in thousands"""
  populationTotal: Float
}

"""Facts of Covid virus development"""
type CovidFact {
  """Count of confirmed cases"""
  confirmed(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int

  """Country"""
  country(country: CountrySelector, continent: ContinentSelector): CovidCountry

  """Calendar date"""
  date: Date

  """Count of death cases"""
  deaths(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int

  """Location"""
  location: CovidLocation

  """Count of recovered cases"""
  recovered(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int
}

"""Covid History"""
type CovidHistory {
  """COVID daily facts"""
  facts(date: DateSelector, country: CountrySelector, continent: ContinentSelector, options: QueryOptions): [CovidFact!]
}

"""Geo Location"""
type CovidLocation {
  """Admin center name"""
  adminCenter: String

  """FIPS code for USA"""
  fipsCode: Int

  """Location latitude"""
  latitude: Float

  """Location longitude"""
  longitude: Float

  """Location Country name"""
  name: String

  """Location Province / State name"""
  province: String
}

"""Crypto currency ( token, coin, currency )"""
type Currency {
  """Token Smart Contract Address"""
  address: String

  """Decimals"""
  decimals: Int!

  """Currency name"""
  name: String

  """Currency symbol"""
  symbol: String!

  """Token ID"""
  tokenId: String

  """Token Type"""
  tokenType: String
}

"""Currency selector"""
input CurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Instruction Data"""
type Data {
  base58: String!
  hex: String!
}

"""Date"""
type Date {
  """String date representation with default format as YYYY-MM-DD"""
  date(format: String): String!

  """Day of month (1-31)"""
  dayOfMonth: Int!

  """Day of week  (Monday is 1, and Sunday is 7)"""
  dayOfWeek: Int!

  """Month number (1-12)"""
  month: Int!

  """
  Returns start of date interval ,
      date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
    starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
  """
  startOfInterval(format: String, interval: Int, offset: Int, unit: DateInterval!): String!

  """Year number"""
  year: Int!
}

enum DateInterval {
  """Year"""
  year

  """Month"""
  month

  """Week"""
  week

  """Day"""
  day
}

"""Selecting the date in a range, list or just date"""
input DateSelector {
  """Since date"""
  since: ISO8601DateTime

  """Till date"""
  till: ISO8601DateTime

  """Range of dates"""
  between: [ISO8601DateTime!]

  """Before date"""
  before: ISO8601DateTime

  """After date"""
  after: ISO8601DateTime

  """In dates"""
  in: [ISO8601DateTime!]

  """Not in dates"""
  notIn: [ISO8601DateTime!]

  """Date equals"""
  is: ISO8601DateTime

  """Date not equals"""
  not: ISO8601DateTime
}

"""Date and Time"""
type DateTime {
  """Day of month (1-31)"""
  dayOfMonth: Int!

  """Day of week  (Monday is 1, and Sunday is 7)"""
  dayOfWeek: Int!

  """Hour (0-23)"""
  hour: Int!

  """ISO8601 date time such as '2020-03-02T13:30:41+00:00'"""
  iso8601: ISO8601DateTime!

  """Minute (0-59)"""
  minute: Int!

  """Month number (1-12)"""
  month: Int!

  """Second (0-59)"""
  second: Int!

  """String date representation with default format as YYYY-MM-DD"""
  time(format: String): String!

  """Unix timestamp"""
  unixtime: Int!

  """Year number"""
  year: Int!
}

"""Selecting the time in a range, list or just time"""
input DateTimeSelector {
  """Since time"""
  since: ISO8601DateTime

  """Till time"""
  till: ISO8601DateTime

  """Range of time"""
  between: [ISO8601DateTime!]

  """Before time"""
  before: ISO8601DateTime

  """After time"""
  after: ISO8601DateTime

  """In times"""
  in: [ISO8601DateTime!]

  """Not in times"""
  notIn: [ISO8601DateTime!]

  """Time equals"""
  is: ISO8601DateTime

  """Time not equals"""
  not: ISO8601DateTime
}

"""
Represents fractional signed whole numeric values.
Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar DecimalNumber

"""
Represents fractional signed whole numeric values.
Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar DecimalNumberAsDiv

enum DiemNetwork {
  """Diem Testnet"""
  diem_testnet

  """Libra Testnet"""
  libra_testnet
}

"""Elrond Chain"""
type Elrond {
  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, smartContractAddress: HashSelector, callDepth: IntegerSelector, argumentIndex: IntegerSelector, argumentValue: IntIdSelector, any: [ElrondArgumentFilter!], options: QueryOptions): [ElrondArgument!]

  """Information about validators of the block"""
  blockValidators(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, validator: HashSelector, any: [ElrondBlockValidatorFilter!], options: QueryOptions): [ElrondBlockValidator!]

  """Information about blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, hash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, nonce: IntegerSelector, round: IntegerSelector, publicKeyBitmap: StringSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: IntegerSelector, transactionCount: IntegerSelector, any: [ElrondBlockFilter!], options: QueryOptions): [ElrondBlock!]

  """Information about calls"""
  callResults(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, callResultIndex: IntegerSelector, callResultType: StringSelector, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultHash: HashSelector, callResultNonce: IntegerSelector, originTxHash: HashSelector, previousTxHash: HashSelector, callResultReceiver: HashSelector, callResultSender: HashSelector, returnMessage: StringSelector, relayed: StringSelector, callResultValue: FloatSelector, callResultRelayedValue: FloatSelector, callResultGasPrice: FloatSelector, callResultGasLimit: FloatSelector, any: [ElrondCallResultFilter!], options: QueryOptions): [ElrondCallResult!]

  """Information about calls"""
  calls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, smartContractAddress: HashSelector, smartContractMethod: MethodSelector, callDepth: StringSelector, any: [ElrondCallFilter!], options: QueryOptions): [ElrondCall!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: CurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [ElrondCoinpath!]

  """Information about miniblocks"""
  miniblocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, receiverBlockHash: HashSelector, receiverShard: BigIntIdSelector, type: StringSelector, any: [ElrondMiniblockFilter!], options: QueryOptions): [ElrondMiniblock!]

  """Information about notarized block"""
  notarizedBlock(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, notarizedBlockHash: HashSelector, any: [ElrondNotarizedBlockFilter!], options: QueryOptions): [ElrondNotarizedBlock!]

  """Information about transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, fee: FloatSelector, gasUsed: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, txValue: FloatSelector, any: [ElrondTransactionFilter!], options: QueryOptions): [ElrondTransaction!]

  """Information about transactions"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, currency: CurrencySelector, transferSender: AddressSelector, transferReceiver: AddressSelector, transferReason: TransferReasonSelector, nftNonce: IntIdSelector, metadata: StringSelector, any: [ElrondTransferFilter!], options: QueryOptions): [ElrondTransfer!]
}

"""Blockchain address hash"""
type ElrondAddressHash {
  """String hex address representation"""
  hex: String!
}

"""Arguments of Smart Contract Calls and Events"""
type ElrondArgument {
  any(of: ElrondArgumentsMeasureable!): String

  """Information about arguments call"""
  call(smartContractAddress: HashSelector, callDepth: IntegerSelector): CallElrond
  count(uniq: ElrondArgumentUniq): Int
  countBigInt(uniq: ElrondArgumentUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Index of the argument"""
  index(argumentIndex: IntIdSelector): Int
  maximum(of: ElrondArgumentsMeasureable!, get: ElrondArgumentsMeasureable): String

  """Information about arguments miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondArgumentsMeasureable!, get: ElrondArgumentsMeasureable): String

  """Information about arguments block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension

  """The time this transaction was created"""
  time: DateTime

  """Information about arguments transaction"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector): TransactionElrond

  """Value of the argument"""
  value(argumentValue: StringSelector): String
}

input ElrondArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  smartContractAddress: HashSelector
  callDepth: IntegerSelector
  argumentIndex: IntegerSelector
  argumentValue: IntIdSelector
}

enum ElrondArgumentUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  block_height

  """Unique Transaction Hash"""
  signature

  """Unique number of arguments"""
  argument_index
}

enum ElrondArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """The block hash of this block`s parent"""
  transaction_count

  """Hash of the miniblock"""
  miniblock_hash

  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash

  """Miniblock receiver shard"""
  miniblock_receiver_shard

  """Type of miniblock"""
  type

  """Transaction hash"""
  tx_hash

  """Receiver hash"""
  tx_receiver

  """Shard number of the receiver"""
  tx_receiver_shard

  """Sender hash"""
  tx_sender

  """Shard number of the sender"""
  tx_sender_shard

  """Transaction Signature"""
  tx_signature

  """Data"""
  data

  """Gas Limit"""
  gas_limit

  """Gas Price"""
  gas_price

  """Gas Used"""
  gas_used

  """Value"""
  tx_value

  """Smart Contract Address"""
  smart_contract_address

  """Smart Contract call path"""
  call_depth

  """Argument Index"""
  argument_index

  """Argument Value"""
  argument_value
}

"""Blocks in Elrond  blockchain"""
type ElrondBlock {
  any(of: ElrondBlocksMeasureable!): String
  count(uniq: ElrondBlockUniq): Int
  countBigInt(uniq: ElrondBlockUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Epoch"""
  epoch(epoch: IntegerSelector): Int

  """Hash of the the block"""
  hash(hash: HashSelector): String

  """Number of block in the blockchains"""
  height(height: BlockSelector): BigInt
  maximum(of: ElrondBlocksMeasureable!, get: ElrondBlocksMeasureable): String
  minimum(of: ElrondBlocksMeasureable!, get: ElrondBlocksMeasureable): String

  """Block Height"""
  nonce(nonce: IntegerSelector): BigInt

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String

  """Proposer block hash"""
  proposer(proposer: HashSelector): ElrondAddressHash

  """Public Key Bitmap"""
  publicKeyBitmap(publicKeyBitmap: StringSelector): String

  """Round"""
  round(round: IntegerSelector): BigInt

  """Shard number of block"""
  shard(shard: BigIntIdSelector): String

  """Size"""
  size(size: IntegerSelector): Int

  """Size Tx"""
  sizeTxs(sizeTxs: IntegerSelector): Int

  """State root hash"""
  stateRootHash(stateRootHash: HashSelector): String

  """The time this transaction was created"""
  time: DateTime

  """Count of transactions in this block"""
  transactionCount(transactionCount: IntegerSelector): BigInt
}

"""Information about block"""
type ElrondBlockDimension {
  """Epoch"""
  epoch(epoch: IntegerSelector): Int

  """Hash of the block"""
  hash(blockHash: HashSelector): String

  """Number of block in the blockchains"""
  height(height: BlockSelector): BigInt

  """Block Height"""
  nonce(blockNonce: IntegerSelector): BigInt

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String

  """Proposer block hash"""
  proposer(proposer: HashSelector): ElrondAddressHash

  """Public Key Bitmap"""
  publicKeyBitmap(publicKeyBitmap: StringSelector): String

  """Round"""
  round(round: IntegerSelector): BigInt

  """Shard number of block"""
  shard(shard: IntIdSelector): String

  """Size"""
  size(size: IntegerSelector): Int

  """Size Tx"""
  sizeTxs(sizeTxs: IntegerSelector): Int

  """State root hash"""
  stateRootHash(stateRootHash: HashSelector): String

  """Count of transactions in this block"""
  transactionCount(transactionCount: IntegerSelector): BigInt
}

input ElrondBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  hash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  nonce: IntegerSelector
  round: IntegerSelector
  publicKeyBitmap: StringSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  stateRootHash: IntegerSelector
  transactionCount: IntegerSelector
}

enum ElrondBlockUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height

  """Unique Number of Shards in the blockchains"""
  block_shard
}

"""BlockValidators in Elrond  blockchain"""
type ElrondBlockValidator {
  any(of: ElrondBlockValidatorsMeasureable!): String

  """Information about blocks notarized block"""
  block(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
  count(uniq: ElrondBlockValidatorUniq): Int
  countBigInt(uniq: ElrondBlockValidatorUniq): BigInt

  """The date this transaction was created"""
  date: Date
  maximum(of: ElrondBlockValidatorsMeasureable!, get: ElrondBlockValidatorsMeasureable): String
  minimum(of: ElrondBlockValidatorsMeasureable!, get: ElrondBlockValidatorsMeasureable): String

  """The time this transaction was created"""
  time: DateTime

  """Hash of validator"""
  validator(validator: HashSelector): ElrondAddressHash
}

input ElrondBlockValidatorFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  validator: HashSelector
}

enum ElrondBlockValidatorUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height

  """Unique number of validators"""
  validators
}

enum ElrondBlockValidatorsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Shard number of block"""
  shard

  """Block proposer"""
  proposer

  """Block epoch"""
  epoch

  """Block nonce"""
  nonce

  """Block round"""
  round

  """Block public key bitmap"""
  public_key_bitmap

  """Block size"""
  size

  """Block size txs"""
  size_txs

  """State root hash"""
  state_root_hash

  """Count of transactions in this block"""
  transaction_count

  """Hash of the validator"""
  validator
}

enum ElrondBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Shard number of block"""
  shard

  """Block proposer"""
  proposer

  """Block epoch"""
  epoch

  """Block nonce"""
  nonce

  """Block round"""
  round

  """Block public key bitmap"""
  public_key_bitmap

  """Block size"""
  size

  """Block size txs"""
  size_txs

  """State root hash"""
  state_root_hash

  """Count of transactions in this block"""
  transaction_count
}

"""Calls in Elrond blockchain"""
type ElrondCall {
  any(of: ElrondCallsMeasureable!): String

  """
  Depth of the call. Empty string for external call, then counted
          as 0...N, and the next layer is added through '-'. For example 0-3-9.
  """
  callDepth(callDepth: StringSelector): String
  count(uniq: ElrondCallsUni): Int
  countBigInt(uniq: ElrondCallsUni): BigInt

  """The date this transaction was created"""
  date: Date
  maximum(of: ElrondCallsMeasureable!, get: ElrondCallsMeasureable): String

  """Information about calls miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondCallsMeasureable!, get: ElrondCallsMeasureable): String

  """Information about calls block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension

  """Contract method invoked"""
  smartContractAddress(smartContractAddress: HashSelector): Address

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """The time this transaction was created"""
  time: DateTime

  """Information about calls transaction"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector): TransactionElrond
}

input ElrondCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  smartContractAddress: HashSelector
  smartContractMethod: MethodSelector
  callDepth: StringSelector
}

"""CallResults in Elrond blockchain"""
type ElrondCallResult {
  any(of: ElrondCallResultsMeasureable!): String
  count(uniq: ElrondCallResultUniq): Int
  countBigInt(uniq: ElrondCallResultUniq): BigInt

  """Call result data"""
  data(callResultData: StringSelector): String

  """Call result data operation"""
  dataOperation(callResultDataOperation: StringSelector): String

  """The date this transaction was created"""
  date: Date

  """Call result gas limit"""
  gasLimit(callResultGasLimit: IntegerSelector): BigInt

  """Call result gas price"""
  gasPrice(callResultGasPrice: IntegerSelector): BigInt

  """Hash of the call result"""
  hash(callResultHash: HashSelector): String

  """Call result index"""
  index(callResultIndex: IntegerSelector): Int
  maximum(of: ElrondCallResultsMeasureable!, get: ElrondCallResultsMeasureable): String

  """Information about calls miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondCallResultsMeasureable!, get: ElrondCallResultsMeasureable): String

  """Nonce of the call result"""
  nonce(callResultNonce: IntegerSelector): BigInt

  """Hash of the origin transaction"""
  originTxHash(originTxHash: HashSelector): String

  """Hash of the previous transaction"""
  previousTxHash(previousTxHash: HashSelector): String

  """Call result receiver"""
  receiver(callResultReceiver: HashSelector): Address

  """Call result relayed"""
  relayed(relayed: StringSelector): String
  relayedValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, callResultIndex: IntegerSelector, callResultType: StringSelector, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultHash: HashSelector, callResultNonce: IntegerSelector, originTxHash: HashSelector, previousTxHash: HashSelector, callResultReceiver: HashSelector, callResultSender: HashSelector, returnMessage: StringSelector, relayed: StringSelector, callResultValue: FloatSelector, callResultRelayedValue: FloatSelector, callResultGasPrice: FloatSelector, callResultGasLimit: FloatSelector): Float

  """Call result return message"""
  returnMessage(returnMessage: StringSelector): String

  """Call result sender"""
  sender(callResultSender: HashSelector): Address

  """Information about calls block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension

  """The time this transaction was created"""
  time: DateTime

  """Information about calls transaction"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector): TransactionElrond

  """Call result type"""
  type(callResultType: StringSelector): String
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, callResultIndex: IntegerSelector, callResultType: StringSelector, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultHash: HashSelector, callResultNonce: IntegerSelector, originTxHash: HashSelector, previousTxHash: HashSelector, callResultReceiver: HashSelector, callResultSender: HashSelector, returnMessage: StringSelector, relayed: StringSelector, callResultValue: FloatSelector, callResultRelayedValue: FloatSelector, callResultGasPrice: FloatSelector, callResultGasLimit: FloatSelector): Float
}

input ElrondCallResultFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  callResultIndex: IntegerSelector
  callResultType: StringSelector
  callResultData: StringSelector
  callResultDataOperation: StringSelector
  callResultHash: HashSelector
  callResultNonce: IntegerSelector
  originTxHash: HashSelector
  previousTxHash: HashSelector
  callResultReceiver: HashSelector
  callResultSender: HashSelector
  returnMessage: StringSelector
  relayed: StringSelector
  callResultValue: FloatSelector
  callResultRelayedValue: FloatSelector
  callResultGasPrice: FloatSelector
  callResultGasLimit: FloatSelector
}

enum ElrondCallResultUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height

  """Unique Number of call results"""
  index
}

enum ElrondCallResultsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """The block hash of this block`s parent"""
  transaction_count

  """Hash of the miniblock"""
  miniblock_hash

  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash

  """Miniblock receiver shard"""
  miniblock_receiver_shard

  """Type of miniblock"""
  type

  """Transaction hash"""
  tx_hash

  """Receiver hash"""
  tx_receiver

  """Shard number of the receiver"""
  tx_receiver_shard

  """Sender hash"""
  tx_sender

  """Shard number of the sender"""
  tx_sender_shard

  """Data"""
  data

  """Gas Limit"""
  gas_limit

  """Gas Price"""
  gas_price

  """Gas Used"""
  gas_used

  """Value"""
  tx_value

  """Index of the call result"""
  call_result_index

  """Data of the call result"""
  call_result_data

  """Hash of the call result"""
  call_result_hash

  """Previous transaction hash of the call result"""
  previous_tx_hash

  """Receiver of the call result"""
  call_result_receiver

  """Sender of the call result"""
  call_result_sender
}

enum ElrondCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """The block hash of this block`s parent"""
  transaction_count

  """Hash of the miniblock"""
  miniblock_hash

  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash

  """Miniblock receiver shard"""
  miniblock_receiver_shard

  """Type of miniblock"""
  type

  """Transaction hash"""
  tx_hash

  """Receiver hash"""
  tx_receiver

  """Shard number of the receiver"""
  tx_receiver_shard

  """Sender hash"""
  tx_sender

  """Shard number of the sender"""
  tx_sender_shard

  """Data"""
  data

  """Gas Limit"""
  gas_limit

  """Gas Price"""
  gas_price

  """Gas Used"""
  gas_used

  """Value"""
  tx_value

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

enum ElrondCallsUni {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height

  """Unique Number of smart contract"""
  smart_contracts

  """Unique Number of smart contract methods"""
  smart_contract_methods
}

"""Elrond Coinpath"""
type ElrondCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: ElrondCoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: ElrondCoinpathMeasureable!, get: ElrondCoinpathMeasureable): String
  minimum(of: ElrondCoinpathMeasureable!, get: ElrondCoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: ElrondTransactionValueDimension
}

enum ElrondCoinpathMeasureable {
  """Time"""
  time

  """Block"""
  block

  """Version"""
  tx_hash

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Depth"""
  depth
}

"""Miniblocks in Elrond  blockchain"""
type ElrondMiniblock {
  any(of: ElrondMiniblocksMeasureable!): String
  count(uniq: ElrondMiniblockUniq): Int
  countBigInt(uniq: ElrondMiniblockUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Miniblock hash"""
  hash(miniblockHash: HashSelector): String
  maximum(of: ElrondMiniblocksMeasureable!, get: ElrondMiniblocksMeasureable): String
  minimum(of: ElrondMiniblocksMeasureable!, get: ElrondMiniblocksMeasureable): String

  """Hash of the receiver block"""
  receiverBlockHash(receiverBlockHash: HashSelector): String

  """Number of the receiver shard"""
  receiverShard(receiverShard: BigIntIdSelector): String

  """Information about miniblocks block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension

  """The time this transaction was created"""
  time: DateTime

  """Miniblock type"""
  type(type: StringSelector): String
}

input ElrondMiniblockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  receiverBlockHash: HashSelector
  receiverShard: BigIntIdSelector
  type: StringSelector
}

enum ElrondMiniblockUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height
}

enum ElrondMiniblocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Count of transactions"""
  transaction_count

  """Hash of the miniblock"""
  hash

  """Hash of the miniblocks receiver block"""
  receiver_block_hash

  """Miniblock receiver shard"""
  receiver_shard

  """Type of miniblock"""
  type
}

enum ElrondNetwork {
  """Elrond mainnet"""
  elrond
}

"""NotarizedBlocks in Elrond blockchain"""
type ElrondNotarizedBlock {
  any(of: ElrondNotarizedBlocksMeasureable!): String

  """Information about blocks notarized block"""
  block(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
  count(uniq: ElrondNotarizedBlockUniq): Int
  countBigInt(uniq: ElrondNotarizedBlockUniq): BigInt

  """The date this transaction was created"""
  date: Date
  maximum(of: ElrondNotarizedBlocksMeasureable!, get: ElrondNotarizedBlocksMeasureable): String
  minimum(of: ElrondNotarizedBlocksMeasureable!, get: ElrondNotarizedBlocksMeasureable): String

  """Hash of the notarized block"""
  notarizedBlockHash(notarizedBlockHash: HashSelector): String

  """The time this transaction was created"""
  time: DateTime
}

input ElrondNotarizedBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  notarizedBlockHash: HashSelector
}

enum ElrondNotarizedBlockUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height

  """Unique hash of notarized block"""
  notarized_block_hash
}

enum ElrondNotarizedBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Shard number of block"""
  shard

  """Block proposer"""
  proposer

  """Block epoch"""
  epoch

  """Block nonce"""
  nonce

  """Block round"""
  round

  """Block public key bitmap"""
  public_key_bitmap

  """Block size"""
  size

  """Block size txs"""
  size_txs

  """State root hash"""
  state_root_hash

  """Count of transactions in this block"""
  transaction_count

  """Notarized block hash"""
  notarized_block_hash
}

"""Transactions in Elrond blockchain"""
type ElrondTransaction {
  any(of: ElrondTransactionsMeasureable!): String
  count(uniq: ElrondTransactionUniq): Int
  countBigInt(uniq: ElrondTransactionUniq): BigInt

  """Data"""
  data(data: StringSelector): String

  """Data operation"""
  dataOperation(dataOperation: StringSelector): String

  """The date this transaction was created"""
  date: Date
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, fee: FloatSelector, gasUsed: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, txValue: FloatSelector): Float

  """Number of gas limit"""
  gasLimit(gasLimit: IntegerSelector): BigInt

  """Number of gas price"""
  gasPrice(gasPrice: IntegerSelector): BigInt

  """Number of gas used"""
  gasUsed(gasUsed: IntegerSelector): BigInt

  """Transaction hash"""
  hash(txHash: HashSelector): String

  """Transaction index"""
  index(txIndex: IntegerSelector): Int
  maximum(of: ElrondTransactionsMeasureable!, get: ElrondTransactionsMeasureable): String

  """Information about transactions miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondTransactionsMeasureable!, get: ElrondTransactionsMeasureable): String

  """Transaction nonce"""
  nonce(txNonce: IntegerSelector): Int

  """TX  receiver"""
  receiver(txReceiver: HashSelector): Address

  """Shard number of receiver"""
  receiverShard(txReceiverShard: BigIntIdSelector): BigInt

  """Hash of the sender"""
  sender(txSender: HashSelector): Address

  """Information about transactions block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension

  """Shard number of sender"""
  senderShard(txSenderShard: BigIntIdSelector): BigInt

  """Signature"""
  signature(signature: HashSelector): String

  """Tx Status"""
  status(status: StringSelector): String

  """The time this transaction was created"""
  time: DateTime
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, fee: FloatSelector, gasUsed: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, txValue: FloatSelector): Float
}

input ElrondTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txNonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  fee: FloatSelector
  gasUsed: FloatSelector
  gasLimit: FloatSelector
  gasPrice: FloatSelector
  txValue: FloatSelector
}

enum ElrondTransactionUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height
}

"""Blockchain transaction with value"""
type ElrondTransactionValueDimension {
  """Transaction hash"""
  hash: String!

  """Transaction value"""
  value: Float!
}

enum ElrondTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """The block hash of this block`s parent"""
  transaction_count

  """Hash of the miniblock"""
  miniblock_hash

  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash

  """Miniblock receiver shard"""
  miniblock_receiver_shard

  """Type of miniblock"""
  type

  """Transaction hash"""
  hash

  """Receiver hash"""
  tx_receiver

  """Shard number of the receiver"""
  tx_receiver_shard

  """Sender hash"""
  tx_sender

  """Shard number of the sender"""
  tx_sender_shard

  """Data"""
  data

  """Gas Limit"""
  gas_limit

  """Gas Price"""
  gas_price

  """Gas Used"""
  gas_used

  """Value"""
  value
}

"""Transfers of Smart Contract Calls and Events"""
type ElrondTransfer {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, currency: CurrencySelector, transferSender: AddressSelector, transferReceiver: AddressSelector, transferReason: TransferReasonSelector, nftNonce: IntIdSelector, metadata: StringSelector): Float
  any(of: ElrondTransfersMeasureable!): String
  count(uniq: ElrondTransferUniq): Int
  countBigInt(uniq: ElrondTransferUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, currency: CurrencySelector, transferSender: AddressSelector, transferReceiver: AddressSelector, transferReason: TransferReasonSelector, nftNonce: IntIdSelector, metadata: StringSelector): BigInt

  """Currency of transfer"""
  currency(currency: CurrencySelector): Currency

  """The date this transaction was created"""
  date: Date
  maximum(of: ElrondTransfersMeasureable!, get: ElrondTransfersMeasureable): String

  """Metadata"""
  metadata(metadata: StringSelector): String

  """Information about arguments miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondTransfersMeasureable!, get: ElrondTransfersMeasureable): String

  """NFT nonce"""
  nftNonce(nftNonce: IntIdSelector): String

  """How the money was transferred"""
  reason(transferReason: TransferReasonSelector): String

  """Receiver account address"""
  receiver(transferReceiver: AddressSelector): Address

  """Sender account address"""
  sender(transferSender: AddressSelector): Address

  """Information about arguments block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension

  """The time this transaction was created"""
  time: DateTime

  """Information about arguments transaction"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector): TransactionElrond
}

input ElrondTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  currency: CurrencySelector
  transferSender: AddressSelector
  transferReceiver: AddressSelector
  transferReason: TransferReasonSelector
  nftNonce: IntIdSelector
  metadata: StringSelector
}

enum ElrondTransferUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  block_height

  """Unique Transaction Hash"""
  signature
}

enum ElrondTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """The block hash of this block`s parent"""
  transaction_count

  """Hash of the miniblock"""
  miniblock_hash

  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash

  """Miniblock receiver shard"""
  miniblock_receiver_shard

  """Type of miniblock"""
  type

  """Transaction hash"""
  tx_hash

  """Receiver hash"""
  tx_receiver

  """Shard number of the receiver"""
  tx_receiver_shard

  """Sender hash"""
  tx_sender

  """Shard number of the sender"""
  tx_sender_shard

  """Data"""
  data

  """Gas Limit"""
  gas_limit

  """Gas Price"""
  gas_price

  """Gas Used"""
  gas_used

  """Value"""
  tx_value

  """Transfer Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver
}

"""Entity"""
type Entity {
  """Entity ID"""
  id(entityId: String): String!

  """Entity number"""
  num: Int!

  """Entity realm ID"""
  realmId: Int!

  """Entity shard ID"""
  shardId: Int!

  """Entity Type"""
  type: String!
}

"""Selector of entity ID for NFT  tokens"""
input EntitySelector {
  """EntityID is"""
  is: String

  """EntityID not"""
  not: String

  """EntityID in the list"""
  in: [String!]

  """EntityID not in the list"""
  notIn: [String!]
}

enum EntityTypeEnum {
  """account"""
  account

  """contract"""
  contract

  """file"""
  file

  """topic"""
  topic

  """token"""
  token

  """schedule"""
  schedule
}

"""Select by entity type"""
input EntityTypeSelector {
  """Type is"""
  is: EntityTypeEnum

  """Type not"""
  not: EntityTypeEnum

  """Type in the list"""
  in: [EntityTypeEnum!]

  """Type not in the list"""
  notIn: [EntityTypeEnum!]
}

"""EOS Chain"""
type Eos {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [EosAddressInfo!]!

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector, any: [EosBlockFilter!], options: QueryOptions): [EosBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EosCoinpath!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean, any: [EosSmartContractCallFilter!], options: QueryOptions): [EosSmartContractCalls!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean, any: [EosTransactionFilter!], options: QueryOptions): [EosTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [EosTransferFilter!], options: QueryOptions): [EosTransfers!]
}

"""Address detailed information for EOS network"""
type EosAddressInfo {
  """Address"""
  address: String

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract if exists on the address"""
  smartContract: EosSmartContractInfo
}

input EosBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: AddressSelector
}

"""Blocks in EOS blockchain"""
type EosBlocks {
  any(of: EosBlocksMeasureable!): String
  count(uniq: EosBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector): Int
  countBigInt(uniq: EosBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector): BigInt

  """Calendar date"""
  date: Date

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String
  minimum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String

  """Block producer"""
  producer(producer: AddressSelector): Address

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
}

enum EosBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Proposer"""
  proposer
}

enum EosBlocksUniq {
  """Unique proposer count"""
  proposers

  """Unique date count"""
  dates
}

enum EosCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Sender"""
  tx_sender

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

"""Coinpath"""
type EosCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: EosAddressInfo

  """Sender address"""
  sender: EosAddressInfo

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

"""
Currency selector in EOS blockchain.
Token identified by address of contract ( eosio.token for main EOS token ) 
"""
input EosCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

enum EosNetwork {
  """EOS mainnet"""
  eos
}

"""Eos smart contract"""
type EosSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EosSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
  scheduled: Boolean
}

"""Smart Contract Calls"""
type EosSmartContractCalls {
  """Actors"""
  actors: String
  any(of: EosCallsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """Console"""
  console: String

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean): BigInt

  """Calendar date"""
  date: Date

  """Error Code"""
  errorCode(errorCode: IntIdSelector): Int

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  maximum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String
  minimum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String

  """Permissions"""
  permissions: String

  """Receivers"""
  receivers: String

  """True if call scheduled"""
  scheduled(scheduled: [Boolean!]): Boolean

  """Smart contract being called"""
  smartContract(smartContractAddress: AddressSelector): EosSmartContract

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

"""Blockchain smart contract"""
type EosSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  scheduled: Boolean
}

"""Transactions in EOS blockchain"""
type EosTransactions {
  any(of: EosTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EosTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int
  countBigInt(uniq: EosTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): BigInt
  cpuUsageUs(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int

  """Calendar date"""
  date: Date

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  minimum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  netUsageWords(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int

  """Success"""
  scheduled(scheduled: Boolean): Boolean

  """Success"""
  success(success: Boolean): Boolean
}

enum EosTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """CPU Usage"""
  cpu_usage_us

  """Net Usage"""
  net_usage_words
}

enum EosTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input EosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: EosCurrencySelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type EosTransfers {
  """Actors"""
  actors: String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: EosTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt

  """Currency of transfer"""
  currency(currency: EosCurrencySelector): Currency

  """Calendar date"""
  date: Date

  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  maximum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  """Memo"""
  memo: String
  minimum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Transfer succeeded"""
  success(success: Boolean): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

enum EosTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Token address"""
  currency_address
}

"""Ethereum Chain"""
type Ethereum {
  """Basic information about address ( or smart contract )"""
  address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!

  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, any: [EthereumArgumentFilter!], options: QueryOptions): [EthereumArguments!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [EthereumBlockFilter!], options: QueryOptions): [EthereumBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: EthereumAddressSelector, receiver: EthereumAddressSelector, currency: [EthereumCurrencySelector!], initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EthereumCoinpath!]

  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!], any: [EthereumSmartContractCallFilter!], options: QueryOptions): [EthereumSmartContractCalls!]

  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, any: [EthereumSmartContractEventFilter!], options: QueryOptions): [EthereumSmartContractEvent!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], any: [EthereumTransactionFilter!], options: QueryOptions): [EthereumTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!], any: [EthereumTransferFilter!], options: QueryOptions): [EthereumTransfers!]
}

"""Ethereum v 2.0 Baecon Chain"""
type Ethereum2 {
  """Attestations in block"""
  attestations(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Attestation!]

  """Attester Slashings"""
  attesterSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2AttesterSlashing!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Blocks!]

  """Attestations of blocks"""
  deposits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Deposit!]

  """Proposer Slashings"""
  proposerSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2ProposerSlashing!]

  """Voluntary Exits"""
  voluntaryExits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2VoluntaryExit!]
}

"""Attestations in Ethereum v2.0 blockchain"""
type Ethereum2Attestation {
  aggregationBits: String!
  any(of: Ethereum2AttestationsMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  """Attestation Index (0 based ) in block"""
  attestationIndex: Int!

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!

  """Committee index for attestation"""
  committeeIndex: Int!
  count(uniq: Ethereum2AttestationsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2AttestationsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String
  minimum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!

  """Sequential index of validator in committee ( 0-based)"""
  validatorInCommitteeIndex: Int!
}

"""AttestationFieldInfo for Ethereum v 2.0 network"""
type Ethereum2AttestationFieldInfo {
  epoch: Int!

  """Root Hash"""
  root: String!
}

"""AttestationInfo for Ethereum v 2.0 network"""
type Ethereum2AttestationInfo {
  beaconBlockRoot: String!
  epoch: Int!
  signature: String!
  slot: Int!
  source: Ethereum2AttestationFieldInfo!
  target: Ethereum2AttestationFieldInfo!
}

enum Ethereum2AttestationsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Committee Index"""
  committee

  """Validator index"""
  validator
}

enum Ethereum2AttestationsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique commitees"""
  committees

  """Unique validators"""
  validators

  """Unique attestations"""
  attestations

  """Unique attestation slots"""
  attestation_slots

  """Unique attestation epochs"""
  attestation_epochs
}

"""Attester Slashing in Ethereum v2.0 blockchain"""
type Ethereum2AttesterSlashing {
  any(of: Ethereum2AttesterSlashingMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  """Attestation slashing sequential number"""
  attestationOrder: Int!

  """Attester Slashing Index (0 based ) in block"""
  attesterSlashingIndex: Int!

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2AttesterSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2AttesterSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String
  minimum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!

  """Validator index in slashing sequential numbern"""
  validatorInAttestationIndex: Int!
}

enum Ethereum2AttesterSlashingMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Validator index"""
  validator
}

enum Ethereum2AttesterSlashingsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique validators"""
  validators

  """Unique slashing slots"""
  attestation_slots

  """Unique slashing epochs"""
  attestation_epochs
}

"""Blocks in Ethereum v2.0 blockchain"""
type Ethereum2Blocks {
  any(of: Ethereum2BlocksMeasureable!): String
  attestationsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  attestationsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
  attesterSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  attesterSlashingsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2BlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2BlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date
  depositsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  depositsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!

  """Graffiti"""
  graffiti: String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String
  minimum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  proposerSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  proposerSlashingsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt

  """Randao Reveal"""
  randaoReveal: String!

  """Block signature"""
  signature: String!

  """Block state root hash"""
  stateRoot: String!

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  voluntaryExitsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  voluntaryExitsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
}

enum Ethereum2BlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Miner"""
  block_proposer
}

enum Ethereum2BlocksUniq {
  """Unique proposers"""
  block_proposers

  """Unique date count"""
  dates
}

"""Deposit in Ethereum v2.0 blockchain"""
type Ethereum2Deposit {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!]): Float
  any(of: Ethereum2DepositsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2DepositsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2DepositsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Deposit Index (0 based ) in block"""
  depositIndex: Int!

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String
  minimum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String

  """Block parent hash"""
  parentRoot: String!
  proof: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  signature: String!

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!
}

enum Ethereum2DepositsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Validator index"""
  validator
}

enum Ethereum2DepositsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique validators"""
  validators
}

"""Eth1 attributes for Ethereum v 2.0 network"""
type Ethereum2Eth1Info {
  """Block Eth1 block hash"""
  blockHash: String!

  """Block Eth1 deposit count"""
  depositCount: Int!

  """Block Eth1 deposit root hash"""
  depositRoot: String!
}

input Ethereum2Filter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockRootHash: HashSelector
  blockProposerIndex: [IntegerSelector!]
}

enum Ethereum2Network {
  """Beacon Chain Ethereum 2.0"""
  eth2

  """Medalla Ethereum 2.0 Beacon Testnet"""
  medalla
}

"""Proposer Slashing in Ethereum v2.0 blockchain"""
type Ethereum2ProposerSlashing {
  any(of: Ethereum2ProposerSlashingMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2ProposerSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2ProposerSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!

  """Header slashing sequential numbern"""
  headerOrder: Int!
  maximum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String
  minimum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Proposer Slashing Index (0 based ) in block"""
  proposerSlashingIndex: Int!
  slashing: Ethereum2SlashingInfo!

  """Block state root hash"""
  stateRoot: String!
}

enum Ethereum2ProposerSlashingMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Slashed Proposer"""
  proposer
}

enum Ethereum2ProposerSlashingsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique slashing slots"""
  slashing_slots

  """Unique slashing epochs"""
  slashing_epochs

  """Unique slashing proposers"""
  slashing_proposers
}

"""SlashingInfo for Ethereum v 2.0 network"""
type Ethereum2SlashingInfo {
  """Block body hash"""
  bodyRoot: String!
  epoch: Int!

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer: Ethereum2ValidatorInfo
  signature: String!
  slot: Int!

  """Block state root hash"""
  stateRoot: String!
}

"""Validator attributes for Ethereum v 2.0 network"""
type Ethereum2ValidatorInfo {
  """Validator Index as Integer"""
  index: Int!

  """Validator Pub Key"""
  pubkey: String!

  """Validator Withdrawal"""
  withdrawalCredentials: String!
}

"""Voluntary Exit in Ethereum v2.0 blockchain"""
type Ethereum2VoluntaryExit {
  any(of: Ethereum2VoluntaryExitsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2VoluntaryExitsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2VoluntaryExitsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String
  minimum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Signature"""
  signature: String!

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!
  voluntaryExitEpoch: Int!

  """Voluntary Exit Index (0 based ) in block"""
  voluntaryExitIndex: Int!
}

enum Ethereum2VoluntaryExitsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Validator index"""
  validator
}

enum Ethereum2VoluntaryExitsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique validators"""
  validators
}

"""Address detailed information for Ethereum network"""
type EthereumAddressInfo {
  """Address"""
  address: String

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract if exists on the address"""
  smartContract: EthereumSmartContractInfo
}

"""Blockchain address"""
type EthereumAddressInfoWithBalance {
  """Address"""
  address: String

  """Annotations ( tags ), if exists"""
  annotation: String

  """DEPRECATED Current address balance"""
  balance: Float

  """DEPRECATED Balances by currencies for the address"""
  balances(date: DateSelector, time: DateTimeSelector, currency: EthereumCurrencySelector, height: BlockSelectorRange): [EthereumBalance!]

  """Smart Contract if exists on the address"""
  smartContract: EthereumSmartContractInfoWithAttributes
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelector {
  """Equal to Address"""
  is: String

  """Not Equal to Address"""
  not: String

  """In the list of Addresses"""
  in: [String!]

  """Not in the list of Addresses"""
  notIn: [String!]
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelectorIn {
  """Equal to Address"""
  is: String

  """In the list of Addresses"""
  in: [String!]
}

input EthereumArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  reference: [EthereumAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
}

"""Arguments of Smart Contract Calls and Events"""
type EthereumArguments {
  any(of: EthereumArgumentsMeasureable!, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String

  """Method or event argument"""
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  """Counts and other metrics"""
  count(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): BigInt

  """Calendar date"""
  date: Date

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  maximum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String
  minimum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String
  number(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): Float

  """Address value of method or event argument"""
  reference(reference: [EthereumAddressSelector!]): EthereumAddressInfo

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Contract method or event"""
  smartContractSignature(smartContractMethod: MethodSelector, smartContractEvent: EventSelector, signatureType: SignatureTypeSelector): Signature

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo

  """The Value of method or event argument"""
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum EthereumArgumentsConvertable {
  """Token symbol"""
  token_symbol

  """Token name"""
  token_name
}

enum EthereumArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Caller"""
  caller

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature"""
  signature_type

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth

  """Argument"""
  argument

  """Argument type"""
  argument_type

  """Argument value"""
  argument_value

  """Argument index"""
  argument_index
}

"""Balance in a currency"""
type EthereumBalance {
  """Currency of transfer"""
  currency: Currency

  """History of balance changes by currencies for the address"""
  history(currency: [EthereumCurrencySelector!], height: BlockSelectorRange): [EthereumBalanceChange!]
  value: Float
}

"""Change of balance in a currency"""
type EthereumBalanceChange {
  """Block number (height) in blockchain"""
  block: Int!

  """Block timestamp"""
  timestamp: ISO8601DateTime

  """Transfer amount ( positive inbound, negative outbound)"""
  transferAmount: Float
  value: Float
}

input EthereumBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [EthereumAddressSelector!]
  blockReward: [AmountSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""Blocks in Ethereum blockchain"""
type EthereumBlocks {
  any(of: EthereumBlocksMeasureable!): String
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  countBigInt(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date
  difficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String

  """Block miner"""
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String

  """Block nonce"""
  nonce: Int!

  """Parent block hash"""
  parentHash: String!
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float

  """Currency of reward"""
  rewardCurrency: Currency
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  transactionCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  uncleCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
}

enum EthereumBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Reward"""
  block_reward

  """Block Miner"""
  miner
}

enum EthereumBlocksUniq {
  """Unique miner count"""
  miners

  """Unique date count"""
  dates
}

enum EthereumCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Caller"""
  caller

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

"""Coinpath"""
type EthereumCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: EthereumAddressInfo

  """Sender address"""
  sender: EthereumAddressInfo

  """Transaction of transfer happened"""
  transaction: TransactionHashValue

  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""
Currency selector in Ethereum blockchain.
  Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
  You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
  Ethereum Smart contract address should start from 0x and contain 40 hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Ethereum DEX attributes"""
type EthereumDex {
  """Address for DEX exchange identification"""
  address: Address!

  """Full name ( name for known, Protocol for unknown )"""
  fullName: String!

  """Full name ( name for known, Protocol / address for unknown )"""
  fullNameWithId: String!

  """Name for known exchanges"""
  name: String
}

input EthereumDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  protocol: [StringSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  exchangeAddress: [EthereumAddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [EthereumCurrencySelector!]
  buyCurrency: [EthereumCurrencySelector!]
  baseCurrency: [EthereumCurrencySelector!]
  quoteCurrency: [EthereumCurrencySelector!]
  maker: [EthereumAddressSelector!]
  makerSmartContractType: [SmartContractTypeSelector!]
  taker: [EthereumAddressSelector!]
  takerSmartContractType: [SmartContractTypeSelector!]
  makerOrTaker: [EthereumAddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

"""Trades on DEX smart contracts"""
type EthereumDexTrades {
  """Trader (maker or taker)"""
  address(makerOrTaker: [EthereumAddressSelector!]): EthereumAddressInfo
  any(of: EthereumDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Base currency"""
  baseCurrency(baseCurrency: [EthereumCurrencySelector!]): Currency

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Maker buys this currency"""
  buyCurrency(buyCurrency: [EthereumCurrencySelector!]): Currency
  count(uniq: EthereumDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  countBigInt(uniq: EthereumDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt

  """Calendar date"""
  date: Date

  """
  Identification of admin / manager / factory of smart contract, executing trades
  """
  exchange(exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!]): EthereumDex
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Trade 'maker' side"""
  maker(maker: [EthereumAddressSelector!]): EthereumAddressInfo
  maximum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  minimum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  price(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  """Protocol name of the smart contract"""
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Quote currency"""
  quoteCurrency(quoteCurrency: [EthereumCurrencySelector!]): Currency
  quotePrice(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Maker sells this currency"""
  sellCurrency(sellCurrency: [EthereumCurrencySelector!]): Currency

  """Side of trade ( SELL / BUY )"""
  side: TradeSide

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Trade 'taker' side"""
  taker(taker: [EthereumAddressSelector!]): EthereumAddressInfo

  """Time interval"""
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float

  """Index of trade in transaction, used to separate trades in transaction"""
  tradeIndex(tradeIndex: [StringSelector!]): String

  """Transaction of DexTrade"""
  transaction(txHash: [HashSelector!], txSender: [EthereumAddressSelector!]): EthereumTransactionInfoExtended
}

enum EthereumDexTradesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Buy Amount"""
  buy_amount

  """Sell Amount"""
  sell_amount

  """Price"""
  price

  """Quote Price"""
  quote_price

  """Maker"""
  maker

  """Taker"""
  taker

  """Buy Currency symbol"""
  buy_currency_symbol

  """Buy Token address"""
  buy_currency_address

  """Sell Currency symbol"""
  sell_currency_symbol

  """Sell Token address"""
  sell_currency_address
}

enum EthereumDexTradesUniq {
  """Unique TX senders count"""
  senders

  """Unique makers count"""
  makers

  """Unique makers count"""
  takers

  """Unique makers & takers count"""
  address

  """Buy currencies count"""
  buy_currency

  """Sell currencies count"""
  sell_currency

  """Base currencies count"""
  base_currency

  """Quote currencies count"""
  quote_currency

  """Unique blocks"""
  blocks

  """Unique transactions count"""
  txs

  """Unique date count"""
  dates

  """Unique smart contract count"""
  smart_contracts

  """Unique protocols count"""
  protocols
}

enum EthereumEventsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Smart Contract"""
  smart_contract

  """Smart Contract Event Name"""
  signature_name

  """Smart Contract Event Signature"""
  signature

  """Smart Contract Event Signature Hash"""
  signature_hash
}

enum EthereumNetwork {
  """Ethereum Mainnet"""
  ethereum

  """Ethereum Classic"""
  ethclassic

  """Ethereum Classic ( no reorg from block 10904146)"""
  ethclassic_reorg

  """Celo Alfajores Testnet"""
  celo_alfajores

  """Celo Baklava Testnet"""
  celo_baklava

  """Celo RC1"""
  celo_rc1

  """Binance Smart Chain Mainnet"""
  bsc

  """Binance Smart Chain Testnet"""
  bsc_testnet

  """Goerli Ethereum Testnet"""
  goerli

  """Matic (Polygon) Mainnet"""
  matic

  """Velas Mainnet"""
  velas

  """Velas Testnet"""
  velas_testnet

  """Klaytn Mainnet"""
  klaytn
}

"""Ethereum smart contract"""
type EthereumSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EthereumSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractType: SmartContractTypeSelector
  external: Boolean
  success: [Boolean!]
}

"""Smart Contract Calls"""
type EthereumSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Float
  any(of: EthereumCallsMeasureable!): String

  """Call arguments"""
  arguments: [ArgumentNameValue!]

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): BigInt

  """Calendar date"""
  date: Date

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """
  Gas used for transaction in external call, or by methd in internal call
  """
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Float
  maximum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String
  minimum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

"""Smart Contract Events"""
type EthereumSmartContractEvent {
  any(of: EthereumEventsMeasureable!): String

  """Event arguments"""
  arguments: [ArgumentNameValue!]

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector): BigInt

  """Calendar date"""
  date: Date

  """Event index"""
  eventIndex: String
  maximum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String
  minimum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Contract event logged"""
  smartContractEvent(smartContractEvent: EventSelector): Event

  """Transaction where event happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

input EthereumSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  smartContractType: SmartContractTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractEvent: EventSelector
}

"""Blockchain smart contract"""
type EthereumSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

"""Blockchain smart contract"""
type EthereumSmartContractInfoWithAttributes {
  """Attributes from readonly methods"""
  attributes: [SmartContractReadonlyAttribute!]

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EthereumTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  gasValue: [AmountSelector!]
}

"""Blockchain transaction info"""
type EthereumTransactionInfo {
  """Gas consumed"""
  gas: Int!

  """Gas price in Gwei"""
  gasPrice: Float!

  """Gas value cost"""
  gasValue: Float!

  """Hash hex representation"""
  hash: String!

  """Transaction from address"""
  txFrom: EthereumAddressInfo!
}

"""Blockchain Transaction Extended info"""
type EthereumTransactionInfoExtended {
  """Gas consumed"""
  gas: Int!

  """Gas price in Gwei"""
  gasPrice: Float!

  """Gas value cost"""
  gasValue: Float!

  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0 based"""
  index: Int

  """Transaction nonce"""
  nonce: Int

  """Transaction receiver"""
  to: EthereumAddressInfo

  """Transaction from address"""
  txFrom: EthereumAddressInfo!
}

"""Transactions in Ethereum blockchain"""
type EthereumTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float
  any(of: EthereumTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Int
  countBigInt(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): BigInt

  """Created smart contract"""
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo

  """Currency of amount"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Error message if any"""
  error: String
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float

  """Currency of gas"""
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String
  minimum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String

  """Transaction nonce"""
  nonce: Int

  """Transaction sender"""
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo

  """Success"""
  success(success: Boolean): Boolean

  """Transaction receiver"""
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

enum EthereumTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Transaction Sender"""
  tx_sender

  """Gas value"""
  gas_value

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

enum EthereumTransactionsUniq {
  """Unique TX senders count"""
  senders

  """Unique TX receivers count"""
  receivers

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input EthereumTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  entityId: EntitySelector
  sender: [EthereumAddressSelector!]
  receiver: [EthereumAddressSelector!]
  currency: [EthereumCurrencySelector!]
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type EthereumTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: EthereumTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt

  """Currency of transfer"""
  currency(currency: [EthereumCurrencySelector!]): Currency

  """Calendar date"""
  date: Date

  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String
  minimum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: [EthereumAddressSelector!]): EthereumAddressInfo

  """Transfer sender"""
  sender(sender: [EthereumAddressSelector!]): EthereumAddressInfo

  """Success flag"""
  success(success: Boolean): Boolean

  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

enum EthereumTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Token address"""
  currency_address

  """Entity ID"""
  entity_id
}

"""Smart contract event"""
type Event {
  """Name"""
  name: String

  """Signature"""
  signature: String

  """Signature Hash"""
  signatureHash: String!
}

"""
Smart contract event. In selector you can use the name, signature or hex hash
"""
input EventSelector {
  """Event signature is"""
  is: String

  """Event signature not"""
  not: String

  """Event signature in the list"""
  in: [String!]

  """Event signature not in the list"""
  notIn: [String!]
}

"""Filecoin"""
type Filecoin {
  """Filecoin Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector, any: [FilecoinBlockFilter!], options: QueryOptions): [FilecoinBlock!]

  """Filecoin Network Calls"""
  calls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector, any: [FilecoinCallFilter!], options: QueryOptions): [FilecoinCalls!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [FilecoinCoinpath!]

  """Filecoin Network Messages ( blocks, transfers, ... )"""
  messages(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector, any: [FilecoinMessageFilter!], options: QueryOptions): [FilecoinMessages!]

  """Filecoin Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector, any: [FilecoinTransferFilter!], options: QueryOptions): [FilecoinTransfers!]
}

"""Block"""
type FilecoinBlock {
  any(of: FilecoinBlocksMeasureable!): String
  blockSig: NameWithId
  blsAggregate: NameWithId
  count(uniq: FilecoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  countBigInt(uniq: FilecoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): BigInt

  """Calendar date"""
  date: Date
  electionProof: String
  forkSignalling: BigInt

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block round in blockchain"""
  height(height: BlockSelector): Int!

  """Block index on height"""
  index(blockIndex: IntegerSelector): Int
  maximum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  messageCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  messageCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): BigInt
  messages: String

  """Miner"""
  miner(miner: AddressSelector): Address
  minerTips(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  minimum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  parentMessageReceipts: String
  parentStateRoot: String
  parentWeight: BigInt
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  ticket: String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalReward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  winCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  winCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): BigInt
  wincount: Int
}

input FilecoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [AddressSelector!]
  blockIndex: IntegerSelector
}

enum FilecoinBlockUniq {
  """Miner"""
  miners

  """Unique date count"""
  dates

  """Unique block height count"""
  heights

  """Unique block count"""
  blocks
}

enum FilecoinBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Miner"""
  miner
}

input FilecoinCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  messageMethod: IntegerSelector
}

"""Calls in Filecoin blockchain"""
type FilecoinCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Float
  any(of: FilecoinCallsMeasureable!): String

  """Block where transfer Message is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Call hash"""
  callHash: String

  """Call hash"""
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Int
  countBigInt(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): BigInt

  """Calendar date"""
  date: Date
  exitCode: BigInt
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String

  """Message Method"""
  messageMethod(messageMethod: IntegerSelector): NameWithId

  """Method"""
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minimum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String
  nonce: BigInt

  """Message receiver"""
  receiver(receiver: AddressSelector): AddressWithAccount
  returnValue: String

  """Message sender"""
  sender(sender: AddressSelector): AddressWithAccount

  """Success"""
  success(success: Boolean): Boolean
}

enum FilecoinCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Message hash"""
  message_hash

  """Amount"""
  amount

  """Gas value"""
  gas_value

  """Gas limit"""
  gas_limit

  """Gas used"""
  gas
}

"""Coinpath"""
type FilecoinCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Message of transfer happened"""
  message: TransactionHashValue
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address
}

input FilecoinMessageFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  index: IntegerSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  success: Boolean
  amount: AmountSelector
}

"""Messages in Filecoin blockchain"""
type FilecoinMessages {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  any(of: FilecoinMessagesMeasureable!): String
  baseFeeBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float

  """Block where transfer Message is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  burned(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  countBigInt(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): BigInt

  """Calendar date"""
  date: Date
  exitCode: BigInt
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String

  """Method"""
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minerPenalty(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minerTip(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minimum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String
  nonce: BigInt
  overEstimationBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float

  """Message receiver"""
  receiver(receiver: AddressSelector): AddressWithAccount
  refund(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  returnValue: String

  """Message sender"""
  sender(sender: AddressSelector): AddressWithAccount
  signature: String
  signatureType: String

  """Signed Message hash"""
  signedHash: String

  """Success"""
  success(success: Boolean): Boolean
  totalCost(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
}

enum FilecoinMessagesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Message hash"""
  message_hash

  """Amount"""
  amount

  """Gas value"""
  gas_value

  """Gas limit"""
  gas_limit

  """Gas used"""
  gas
}

enum FilecoinMessagesUniq {
  """Unique block heights"""
  blocks

  """Unique date count"""
  dates

  """Unique Message senders"""
  senders

  """Unique Message receivers"""
  receivers
}

"""Filecoin Mined Block"""
type FilecoinMinedBlock {
  """Hash"""
  hash: String

  """Index on height"""
  index: Int

  """Miner"""
  miner: Address
}

enum FilecoinNetwork {
  """Filecoin Mainnet"""
  filecoin
}

input FilecoinTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  transferType: TransferTypeSelector
  messageMethod: IntegerSelector
}

enum FilecoinTransferType {
  """Send (transfer)"""
  send

  """Miner Tip"""
  miner

  """Reward"""
  reward

  """Burn"""
  burn

  """Rebalance"""
  rebalance

  """Genesis"""
  genesis
}

"""Transfers in Filecoin blockchain"""
type FilecoinTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Float
  any(of: FilecoinTransfersMeasureable!): String

  """Block where transfer Transfer is included"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended

  """Call hash"""
  callHash: String

  """Call hash"""
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Int
  countBigInt(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): BigInt

  """Currency of transfer"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String

  """Message Method"""
  messageMethod(messageMethod: IntegerSelector): NameWithId

  """Method"""
  method(method: IntegerSelector): NameWithId
  minimum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Transfer timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Type of transfer"""
  transferType(transferType: TransferTypeSelector): FilecoinTransferType
}

enum FilecoinTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Transfer hash"""
  tx_hash

  """Value"""
  value

  """Gas value"""
  gas_value

  """Gas limit"""
  gas_limit

  """Gas used"""
  gas
}

"""Select by number"""
input FloatSelector {
  """is"""
  is: Float

  """not"""
  not: Float

  """in the list"""
  in: [Float!]

  """not in the list"""
  notIn: [Float!]

  """greater than"""
  gt: Float

  """less than"""
  lt: Float

  """less or equal than"""
  lteq: Float

  """greater or equal than"""
  gteq: Float

  """in range"""
  between: [Float!]
}

enum FlowDirection {
  """Inbound transfers"""
  inbound

  """Outbound transfers"""
  outbound
}

"""Harmony Chain"""
type Harmony {
  """Arguments of Smart Contract Calls and Events"""
  arguments(time: DateTimeSelector, date: DateSelector, ledger: BlockSelector, blockHash: HashSelector, sender: HashSelector, receiver: HashSelector, smartContractAddress: HashSelector, smartContractId: IntegerSelector, argument: StringSelector, any: [HarmonyArgumentsFilter!], options: QueryOptions): [HarmonyArguments!]

  """Harmony Blocks"""
  blocks(date: DateSelector, ledger: BlockSelector, blockHash: HashSelector, miner: HashSelector, viewId: HashSelector, perentHash: HashSelector, transactionCount: HashSelector, stakingTransactionsCount: HashSelector, unclesCount: HashSelector, any: [HarmonyBlocksFilter!], options: QueryOptions): [HarmonyBlocks!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, any: [HarmonySmartContractCallsFilter!], options: QueryOptions): [HarmonySmartContractCalls!]

  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, any: [HarmonySmartContractEventsFilter!], options: QueryOptions): [HarmonySmartContractEvents!]

  """Harmony Staking Transactions"""
  stakingTransactions(date: DateSelector, transactionHash: HashSelector, ledger: BlockSelector, transactionType: StakingTransactionsTypeSelector, validatorAddress: HashSelector, delegatorAddress: HashSelector, success: Boolean, status: Boolean, any: [HarmonyStakingTransactionsFilter!], options: QueryOptions): [HarmonyStakingTransactions!]

  """Harmony Transactions"""
  transactions(date: DateSelector, transactionHash: HashSelector, ledger: BlockSelector, sender: HashSelector, reciever: HashSelector, success: Boolean, status: Boolean, any: [HarmonyTransactionsFilter!], options: QueryOptions): [HarmonyTransactions!]

  """Harmony Transfers"""
  transfers(date: DateSelector, transactionHash: HashSelector, ledger: BlockSelector, sender: HashSelector, success: Boolean, status: Boolean, any: [HarmonyTransfersFilter!], options: QueryOptions): [HarmonyTransfers!]
}

"""Arguments of Smart Contract Calls and Events"""
type HarmonyArguments {
  """Value"""
  address: String
  any(of: HarmonyArgumentsMeasureable!): String

  """Argument Index"""
  argIndex: String

  """Argument Type"""
  argType: String

  """Argument"""
  argument(argument: String): String

  """Transaction hash"""
  blockHash(blockHash: HashSelector): String

  """Call Path"""
  callPath: String
  count(uniq: HarmonyArgumentsUniq): Int

  """The date this transaction was created"""
  date: Date

  """Epoch"""
  epoch: BigInt

  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyArgumentsMeasureable!, get: HarmonyArgumentsMeasureable): String
  minimum(of: HarmonyArgumentsMeasureable!, get: HarmonyArgumentsMeasureable): String

  """The number of transactions made by the sender prior to this one."""
  nonce: BigInt

  """Value"""
  number: String

  """Address of the receiver"""
  receiver(receiver: HashSelector): String

  """Address of the sender"""
  sender(sender: HashSelector): String

  """ShardID"""
  shardId: BigInt

  """Signature ID"""
  signatureId: BigInt

  """Address of the smart contract"""
  smartContractAddress(smartContractAddress: HashSelector): String

  """Id of the smart contract"""
  smartContractId(smartContractAddress: IntegerSelector): BigInt

  """The time this transaction was created"""
  time: DateTime

  """Value"""
  value: String
}

input HarmonyArgumentsFilter {
  time: DateTimeSelector
  date: DateSelector
  ledger: BlockSelector
  blockHash: HashSelector
  sender: HashSelector
  receiver: HashSelector
  smartContractAddress: HashSelector
  smartContractId: IntegerSelector
  argument: StringSelector
}

enum HarmonyArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block hash"""
  block_hash

  """Address of the sender"""
  sender

  """Address of  the receive"""
  receiver

  """Address of the smart contract"""
  smart_contract_address

  """Id of the smart contract"""
  smart_contract_id

  """Signature"""
  signature

  """Name of the signature"""
  signature_name

  """Hash of the signature"""
  signature_hash
}

enum HarmonyArgumentsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique ledger count"""
  ledger

  """Unique block hash count"""
  block_hash

  """Unique smart contract address"""
  smart_contract_address

  """Unique address of the sender"""
  sender

  """Unique address of the receiver"""
  receiver
}

"""Blocks in Harmony blockchain"""
type HarmonyBlocks {
  any(of: HarmonyBlocksMeasureable!): String

  """Transaction hash"""
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyBlocksUniq): Int
  countBigInt(uniq: HarmonyBlocksUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Difficulty"""
  difficulty: String

  """Epoch"""
  epoch: BigInt

  """The extra data field of this block"""
  extraData: String

  """Gas limit"""
  gasLimit: BigInt

  """Gas used"""
  gasUsed: String

  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt

  """
  The bloom filter for the logs of the block. null when its pending block
  """
  logsBloom: String
  maximum(of: HarmonyBlocksMeasureable!, get: HarmonyBlocksMeasureable): String

  """Transaction hash"""
  miner(miner: HashSelector): String
  minimum(of: HarmonyBlocksMeasureable!, get: HarmonyBlocksMeasureable): String

  """Mix Hash"""
  mixHash: String

  """Nonce"""
  nonce: BigInt

  """Parent hash"""
  parentHash(parentHash: HashSelector): String

  """Receipts Root"""
  receiptsRoot: String

  """ShardID"""
  shardId: BigInt

  """Integer the size of this block in bytes"""
  size(size: HashSelector): BigInt

  """Staking Transaction Count"""
  stakingTransactionsCount(stakingTransactionsCount: HashSelector): BigInt

  """The root of the final state trie of the block"""
  stateRoot: String

  """The time this transaction was created"""
  time: DateTime

  """Transaction Count"""
  transactionCount(transactionCount: HashSelector): BigInt

  """The root of the transaction trie of the block"""
  transactionsRoot: String

  """Count of ucles hashes"""
  unclesCount(unclesCount: HashSelector): BigInt

  """View ID"""
  viewId(viewId: HashSelector): String
}

input HarmonyBlocksFilter {
  date: DateSelector
  ledger: BlockSelector
  blockHash: HashSelector
  miner: HashSelector
  viewId: HashSelector
  perentHash: HashSelector
  transactionCount: HashSelector
  stakingTransactionsCount: HashSelector
  unclesCount: HashSelector
}

enum HarmonyBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Gas limit"""
  gas_limit

  """Gas Used"""
  gas_used

  """Block hash"""
  block_hash

  """Parent hash"""
  paret_hash
}

enum HarmonyBlocksUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique ledger count"""
  ledger

  """Unique block hash count"""
  block_hash

  """Unique parent hash count"""
  parent_hash

  """Unique miner count"""
  miner

  """Unique mix hash count"""
  mix_hash

  """Unique state root count"""
  state_root

  """Unique receipts root count"""
  receipts_root

  """Unique transactions root count"""
  transactions_root
}

enum HarmonyEventsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature Hash"""
  signature_hash
}

enum HarmonyNetwork {
  """Harmony Mainnat"""
  harmony

  """Harmony Testnet"""
  harmony_testnet
}

"""Smart Contract Calls"""
type HarmonySmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  any(of: HarmonySmartContractCallsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
  """
  callPath: String

  """Counts and other metrics"""
  count(uniq: HarmonySmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int

  """Counts and other metrics"""
  countBigInt(uniq: HarmonySmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): BigInt

  """Calendar date"""
  date: Date

  """
  External call executed explicitly by caller. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int

  """Gas unit price"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  maximum(of: HarmonySmartContractCallsMeasureable!, get: HarmonySmartContractCallsMeasureable): String
  minimum(of: HarmonySmartContractCallsMeasureable!, get: HarmonySmartContractCallsMeasureable): String

  """Nonce"""
  nonce(nonce: IntegerSelector): BigInt

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Transaction Sender"""
  txSender(txSender: AddressSelector): Address

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

input HarmonySmartContractCallsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

enum HarmonySmartContractCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

enum HarmonySmartContractCallsUniq {
  """Unique callers count"""
  tx_to

  """Unique transaction senders"""
  tx_from

  """Unique transactions count"""
  txs

  """Unique smart contracts count"""
  smart_contracts

  """Unique smart contract methods count"""
  smart_contract_methods

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

"""Smart Contract Events"""
type HarmonySmartContractEvents {
  any(of: HarmonyEventsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractEventsUniq): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractEventsUniq): BigInt

  """Calendar date"""
  date: Date

  """Transaction hash where transfer happened"""
  epoch(epoch: IntegerSelector): BigInt
  maximum(of: HarmonyEventsMeasureable!, get: HarmonyEventsMeasureable): String
  minimum(of: HarmonyEventsMeasureable!, get: HarmonyEventsMeasureable): String

  """The number of transactions made by the sender prior to this one."""
  nonce(nonce: IntegerSelector): BigInt

  """Contract method invoked"""
  smartContractEvent(smartContractEvent: EventSelector): Event

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

input HarmonySmartContractEventsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

"""StakingTransactions in Harmony blockchain"""
type HarmonyStakingTransactions {
  any(of: HarmonyStakingTransactionsMeasureable!): String
  count(uniq: HarmonyStakingTransactionsUniq): Int
  countBigInt(uniq: HarmonyStakingTransactionsUniq): BigInt

  """Data"""
  data: String

  """The date this transaction was created"""
  date: Date

  """Delegator Address"""
  delegatorAddress(delegatorAddress: HashSelector): String

  """Epoch"""
  epoch: BigInt

  """Gas provided by the sender"""
  gas: BigInt

  """Gas price provided by the sender"""
  gasPrice: String

  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyStakingTransactionsMeasureable!, get: HarmonyStakingTransactionsMeasureable): String
  minimum(of: HarmonyStakingTransactionsMeasureable!, get: HarmonyStakingTransactionsMeasureable): String

  """The number of transactions made by the sender prior to this one"""
  nonce: BigInt

  """ShardID"""
  shardId: BigInt

  """Status"""
  status(status: Boolean): Boolean

  """Successful of not"""
  success(success: Boolean): Boolean

  """The time this transaction was created"""
  time: DateTime

  """Transaction hash"""
  transactionHash(transactionHash: HashSelector): String

  """Transaction type"""
  transactionType(transactionType: StakingTransactionsTypeSelector): String

  """Validator Address"""
  validatorAddress(validatorAddress: HashSelector): String

  """Value transferred in ATTO"""
  value: String
}

input HarmonyStakingTransactionsFilter {
  date: DateSelector
  transactionHash: HashSelector
  ledger: BlockSelector
  transactionType: StakingTransactionsTypeSelector
  validatorAddress: HashSelector
  delegatorAddress: HashSelector
  success: Boolean
  status: Boolean
}

enum HarmonyStakingTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Gas price provided by the sender"""
  gas_price

  """Validator Address"""
  validator_address

  """Deligator Address"""
  deligator_address

  """Value transferred in ATTO"""
  value

  """Gas price provided by the sender"""
  gasPrice

  """Gas provided by the sender"""
  gas
}

enum HarmonyStakingTransactionsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique block"""
  ledger

  """Unique address validator"""
  validator_address

  """Unique delegator validator"""
  delegator_address
}

"""Transactions in Harmony blockchain"""
type HarmonyTransactions {
  any(of: HarmonyTransactionsMeasureable!): String

  """Hash of the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyTransactionsUniq): Int
  countBigInt(uniq: HarmonyTransactionsUniq): BigInt

  """Transaction creates"""
  creates(creates: HashSelector): String

  """Data"""
  data: String

  """The date this transaction was created"""
  date: Date

  """Epoch"""
  epoch: BigInt

  """Gas provided by the sender"""
  gas: BigInt

  """Gas price provided by the sender"""
  gasPrice: String

  """Gas value provided by the sender"""
  gasValue: String

  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyTransactionsMeasureable!, get: HarmonyTransactionsMeasureable): String
  minimum(of: HarmonyTransactionsMeasureable!, get: HarmonyTransactionsMeasureable): String

  """The number of transactions made by the sender prior to this one"""
  nonce: BigInt

  """Address of the reciever"""
  reciever(reciever: HashSelector): String

  """Address of the sender"""
  sender(sender: HashSelector): String

  """ShardID"""
  shardId: BigInt

  """Status"""
  status(status: Boolean): Boolean

  """Successful of not"""
  success(success: Boolean): Boolean

  """The time this transaction was created"""
  time: DateTime

  """
  Integer of the transactions index position in the block. null when its pending.
  """
  transactionHash(transactionHash: HashSelector): String

  """Index of the transaction"""
  transactionIndex(transactionIndex: HashSelector): Int

  """Value transferred in ATTO"""
  value: String
}

input HarmonyTransactionsFilter {
  date: DateSelector
  transactionHash: HashSelector
  ledger: BlockSelector
  sender: HashSelector
  reciever: HashSelector
  success: Boolean
  status: Boolean
}

enum HarmonyTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Gas price provided by the sender"""
  gas_price

  """Validator Address"""
  sender

  """Deligator Address"""
  reciever

  """Value transferred in ATTO"""
  value

  """Gas price provided by the sender"""
  gasPrice

  """Gas value provided by the sender"""
  gasValue

  """Gas provided by the sender"""
  gas
}

enum HarmonyTransactionsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique block"""
  ledger

  """Unique sender"""
  sender

  """Unique reciever"""
  reciever
}

"""Transfers in Harmony blockchain"""
type HarmonyTransfers {
  any(of: HarmonyTransfersMeasureable!): String

  """Hash of the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyTransfersUniq): Int
  countBigInt(uniq: HarmonyTransfersUniq): BigInt

  """Currency of transfer"""
  currency: Currency

  """Data"""
  data: String

  """The date this transaction was created"""
  date: Date

  """Epoch"""
  epoch: BigInt

  """External"""
  external(external: Boolean): Boolean

  """Gas provided by the sender"""
  gas: BigInt

  """Gas price provided by the sender"""
  gasPrice: String

  """Gas value provided by the sender"""
  gasValue: String

  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyTransfersMeasureable!, get: HarmonyTransfersMeasureable): String
  minimum(of: HarmonyTransfersMeasureable!, get: HarmonyTransfersMeasureable): String

  """The number of transactions made by the sender prior to this one"""
  nonce: BigInt

  """Address of the sender"""
  sender(sender: HashSelector): String

  """ShardID"""
  shardId: BigInt

  """Status"""
  status(status: Boolean): Boolean

  """Successful of not"""
  success(success: Boolean): Boolean

  """The time this transaction was created"""
  time: DateTime

  """
  Integer of the transactions index position in the block. null when its pending.
  """
  transactionHash(transactionHash: HashSelector): String

  """Index of the transaction"""
  transactionIndex(transactionIndex: HashSelector): Int

  """Address of the payer"""
  transferFrom(transferFrom: HashSelector): String

  """Address of the receiver"""
  transferTo(transferTo: HashSelector): String

  """Value transferred in ATTO"""
  value: String
}

input HarmonyTransfersFilter {
  date: DateSelector
  transactionHash: HashSelector
  ledger: BlockSelector
  sender: HashSelector
  success: Boolean
  status: Boolean
}

enum HarmonyTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Gas price provided by the sender"""
  gas_price

  """Validator Address"""
  sender

  """Value transferred in ATTO"""
  value

  """Gas price provided by the sender"""
  gasPrice

  """Gas value provided by the sender"""
  gasValue

  """Gas provided by the sender"""
  gas
}

enum HarmonyTransfersUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique block"""
  ledger

  """Unique sender"""
  sender

  """Unique transfer from"""
  transfer_from

  """Unique transfer to"""
  transfer_to
}

"""Select by hash"""
input HashSelector {
  """Hash is"""
  is: String

  """Hash not"""
  not: String

  """Hash in the list"""
  in: [String!]

  """Hash not in the list"""
  notIn: [String!]
}

"""Hedera Chain"""
type Hedera {
  """Blockchain Arguments"""
  arguments(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean, any: [HederaArgumentFilter!], options: QueryOptions): [HederaArgument!]

  """Blockhain Calls"""
  calls(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, callInput: HashSelector, callResult: HashSelector, success: Boolean, any: [HederaCallFilter!], options: QueryOptions): [HederaCall!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [HederaCoinpath!]

  """Blockhain Inputs"""
  inputs(date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!], any: [HederaInputFilter!], options: QueryOptions): [HederaInput!]

  """Blockhain Messages"""
  messages(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaMessageFilter!], options: QueryOptions): [HederaMessage!]

  """Blockchain Outputs"""
  outputs(date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaOutputFilter!], options: QueryOptions): [HederaOutput!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaTransactionFilter!], options: QueryOptions): [HederaTransaction!]
}

"""Arguments in Hedera blockchain"""
type HederaArgument {
  any(of: HederaArgumentsMeasureable!): String

  """Argument type"""
  argtype: String

  """Argument"""
  argument: String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaArgumentsUniq): Int
  countBigInt(uniq: HederaArgumentsUniq): BigInt

  """Calendar date"""
  date: Date

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maximum(of: HederaArgumentsMeasureable!, get: HederaArgumentsMeasureable): String
  memo: String
  minimum(of: HederaArgumentsMeasureable!, get: HederaArgumentsMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Smart contract"""
  smartContractEntity: Account

  """Success"""
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp

  """Value"""
  value: String
}

input HederaArgumentFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  success: Boolean
}

enum HederaArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaArgumentsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique node account"""
  smart_contract_entity

  """Unique initial balance"""
  initial_balance
}

"""Calls in Hedera blockchain"""
type HederaCall {
  any(of: HederaCallsMeasureable!): String

  """Call input"""
  callInput(callInput: HashSelector): String

  """Call input"""
  callResult(callResult: HashSelector): String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaCallsUniq): Int
  countBigInt(uniq: HederaCallsUniq): BigInt

  """Calendar date"""
  date: Date

  """Currency of transfer"""
  feeCurrency: Currency
  gas(calculate: AmountAggregateFunction, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, callInput: HashSelector, callResult: HashSelector, success: Boolean): Int
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maximum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String
  memo: String
  minimum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Smart contract"""
  smartContractEntity: Account

  """Success"""
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaCallFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  callInput: HashSelector
  callResult: HashSelector
  success: Boolean
}

enum HederaCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaCallsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique node account"""
  smart_contract_entity

  """Unique initial balance"""
  initial_balance
}

"""Coinpath"""
type HederaCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""Currency selector in Hedera blockchain."""
input HederaCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Inputs in Hedera blockchain"""
type HederaInput {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  any(of: HederaInputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaInputsUniq): Int
  countBigInt(uniq: HederaInputsUniq): BigInt

  """Currency of transfer"""
  currency(currency: HederaCurrencySelector): Currency

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String
  memo: String
  minimum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar time"""
  time: DateTime
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int

  """Transfer Account"""
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaInputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
  amount: [AmountSelector!]
}

enum HederaInputMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee

  """Amount"""
  amount
}

enum HederaInputsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

"""Messages in Hedera blockchain"""
type HederaMessage {
  any(of: HederaMessageMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaMessagesUniq): Int
  countBigInt(uniq: HederaMessagesUniq): BigInt

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String
  memo: String
  message: String
  minimum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar date time"""
  time: DateTime

  """Transaction running hash"""
  topicRunningHash(topicRunningHash: StringSelector): String

  """Transaction running hash"""
  topicSequenceNumber(topicSequenceNumber: HashSelector): String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaMessageFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  transactionRunningHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaMessageMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaMessagesUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

enum HederaNetwork {
  """The Hedera mainnet"""
  hedera

  """The Hedera testnets"""
  hedera_testnets
}

"""Outputs in Hedera blockchain"""
type HederaOutput {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  any(of: HederaOutputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaOutputUniq): Int
  countBigInt(uniq: HederaOutputUniq): BigInt

  """Currency of transfer"""
  currency(currency: HederaCurrencySelector): Currency

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String
  memo: String
  minimum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar time"""
  time: DateTime
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int

  """Transfer Account"""
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaOutputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaOutputMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee

  """Amount"""
  amount
}

enum HederaOutputUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique Transfer entity"""
  transfer_entity

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

"""Transactions in Hedera blockchain"""
type HederaTransaction {
  any(of: HederaTransactionMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaTransactionsUniq): Int
  countBigInt(uniq: HederaTransactionsUniq): BigInt

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaTransactionMeasureable!, get: HederaTransactionMeasureable): String
  memo: String
  minimum(of: HederaTransactionMeasureable!, get: HederaTransactionMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar time"""
  time: DateTime
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String

  """Transaction Type"""
  transactionType: String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaTransactionFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaTransactionMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaTransactionsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique transaction type"""
  transaction_type

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

"""An ISO 8601-encoded date"""
scalar ISO8601Date

"""An ISO 8601-encoded datetime"""
scalar ISO8601DateTime

"""Input Script Type of UTXO transaction input"""
type InputScript {
  """Script annotation"""
  annotation: String

  """Long script pattern"""
  pattern: String!

  """Short script pattern"""
  shortPattern: String!

  """Simple script pattern"""
  simplePattern: String!

  """Script type"""
  type: BitcoinInputScriptType
}

"""Solana Instruction"""
type Instruction {
  action: Action
  callPath: String
  external: Boolean
  program: Program
}

"""Solana Instruction"""
type InstructionWithExternals {
  action: Action
  callPath: String
  external: Boolean
  externalAction: Action
  externalProgram: Program
  program: Program
}

"""Select by ID"""
input IntIdSelector {
  """ID is"""
  is: Int

  """ID not"""
  not: Int

  """ID in the list"""
  in: [Int!]

  """ID not in the list"""
  notIn: [Int!]

  """ID greater than"""
  gt: Int

  """ID less than"""
  lt: Int

  """ID less or equal than"""
  lteq: Int

  """ID greater or equal than"""
  gteq: Int

  """ID in range"""
  between: [Int!]
}

"""Select limited upper number"""
input IntegerLimitedSelector {
  """is"""
  is: Int

  """in the list"""
  in: [Int!]

  """less than"""
  lt: Int

  """less or equal than"""
  lteq: Int

  """in range"""
  between: [Int!]
}

"""Select by number"""
input IntegerSelector {
  """is"""
  is: Int

  """not"""
  not: Int

  """in the list"""
  in: [Int!]

  """not in the list"""
  notIn: [Int!]

  """greater than"""
  gt: Int

  """less than"""
  lt: Int

  """less or equal than"""
  lteq: Int

  """greater or equal than"""
  gteq: Int

  """in range"""
  between: [Int!]
}

"""Libra"""
type Libra {
  """Libra Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector, any: [LibraBlockFilter!], options: QueryOptions): [LibraBlock!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [LibraCoinpath!]

  """Libra Network Currency Minting"""
  mints(date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!], any: [LibraMintFilter!], options: QueryOptions): [LibraMints!]

  """Libra Network Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector, any: [LibraTransactionFilter!], options: QueryOptions): [LibraTransactions!]

  """Libra Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector, any: [LibraTransferFilter!], options: QueryOptions): [LibraTransfers!]
}

"""Block"""
type LibraBlock {
  any(of: LibraBlocksMeasureable!): String
  count(uniq: LibraBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): Int
  countBigInt(uniq: LibraBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): BigInt

  """Calendar date"""
  date: Date
  gasUsed(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): Float

  """Block round in blockchain"""
  height(height: BlockSelector): Int!

  """Key"""
  key: String
  maximum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  """Metadata"""
  metadata(metadata: StringSelector): String
  minimum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  """Proposer"""
  proposer(proposer: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Status Name"""
  statusName: String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Version of transaction for this block"""
  version(version: IntegerSelector): Int!

  """Version hash of transaction for this block"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

input LibraBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  proposer: [AddressSelector!]
  metadata: StringSelector
}

enum LibraBlockUniq {
  """Proposer"""
  proposer

  """Unique date count"""
  dates
}

enum LibraBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block round"""
  block

  """Version"""
  version

  """Proposer"""
  proposer

  """Gas Used"""
  gas_used
}

"""Coinpath"""
type LibraCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: LibraCoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String
  minimum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: LibraTransactionValue
}

enum LibraCoinpathMeasureable {
  """Time"""
  time

  """Block"""
  block

  """Version"""
  version

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Depth"""
  depth
}

"""
Currency selector in Libra blockchain.
Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
Use name of currency for selection
"""
input LibraCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

input LibraMintFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  version: IntegerSelector
  minter: AddressSelector
  currency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
}

"""Mints in Libra blockchain"""
type LibraMints {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): Float
  any(of: LibraMintsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraMintsUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): Int
  countBigInt(uniq: LibraMintsUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): BigInt

  """Currency of transfer"""
  currency(currency: [LibraCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  maximum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String
  minimum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String

  """Minter"""
  minter(sender: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Status Name"""
  statusName: String

  """Success"""
  success(success: Boolean): Boolean

  """Mint timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!

  """Version hash of blockchain for this transaction"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

enum LibraMintsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Version"""
  version

  """Mint version hash"""
  version_hash

  """Amount"""
  amount

  """Minter"""
  minter

  """Currency symbol"""
  currency_symbol
}

enum LibraMintsUniq {
  """Unique blocks"""
  blocks

  """Unique versions"""
  versions

  """Unique date count"""
  dates

  """Unique minters"""
  minters

  """Unique currencies"""
  currencies
}

input LibraTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  scriptType: ScriptTypeSelectorSelector
  success: Boolean
  gasCurrency: [LibraCurrencySelector!]
  scriptHash: StringSelector
}

"""Blockchain transaction with value"""
type LibraTransactionValue {
  """Transaction value"""
  value: Float!

  """Transaction version"""
  version: Int!
}

"""Transactions in Libra blockchain"""
type LibraTransactions {
  any(of: LibraTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Int
  countBigInt(uniq: LibraTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): BigInt

  """Calendar date"""
  date: Date

  """Expiration Time"""
  expirationTime: DateTime
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Int

  """Currency of gas"""
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  """Gas unit price"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float

  """Max gas amount"""
  maxGasAmount: Int
  maximum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String
  minimum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String

  """Public key"""
  publicKey: String

  """Script Hash"""
  scriptHash(scriptHash: StringSelector): String

  """Script Type"""
  scriptType: ScriptTypeSelectorSelector

  """Transaction sender"""
  sender(txSender: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Signature"""
  signature: String

  """Signature scheme"""
  signatureScheme: String

  """Status Name"""
  statusName: String

  """Success"""
  success(success: Boolean): Boolean

  """Transaction timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!

  """Version hash of blockchain for this transaction"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

enum LibraTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Version"""
  version

  """Transaction Sender"""
  tx_sender

  """Script Hash"""
  script_hash

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

enum LibraTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique versions"""
  versions

  """Unique date count"""
  dates

  """Unique transaction senders"""
  senders

  """Unique transaction script hashes"""
  scripts
}

input LibraTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: [LibraCurrencySelector!]
  gasCurrency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
  scriptType: ScriptTypeSelectorSelector
  scriptHash: StringSelector
}

"""Transfers in Libra blockchain"""
type LibraTransfers {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float
  any(of: LibraTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): BigInt

  """Currency of transfer"""
  currency(currency: [LibraCurrencySelector!]): Currency

  """Calendar date"""
  date: Date

  """Expiration Time"""
  expirationTime: DateTime
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Int

  """Currency of gas"""
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  """Gas price"""
  gasPrice: Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float

  """Max gas amount"""
  maxGasAmount: Int
  maximum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String
  minimum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String

  """Public key"""
  publicKey: String

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Script Hash"""
  scriptHash(scriptHash: StringSelector): String

  """Script Type"""
  scriptType: ScriptTypeSelectorSelector

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Signature"""
  signature: String

  """Signature scheme"""
  signatureScheme: String

  """Status Name"""
  statusName: String

  """Success"""
  success(success: Boolean): Boolean

  """Transfer timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Transaction sender"""
  txSender(txSender: AddressSelector): Address

  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!

  """Version hash of blockchain for this transaction"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

enum LibraTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  height

  """Version"""
  version

  """Version hash"""
  version_hash

  """Amount"""
  amount

  """Transfer Sender"""
  tx_sender

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Script Hash"""
  script_hash

  """Currency symbol"""
  currency_symbol

  """Gas value"""
  gas_value

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

"""Limit by definition"""
input LimitByOption {
  """Take limit for each combination of the field"""
  each: String!

  """Limit number of results"""
  limit: Int

  """Offset of results, starting from 0"""
  offset: Int
}

"""Solana Log"""
type Log {
  consumed: BigInt!
  instruction: String!
  logs: String!
  result: String!
  totalGas: BigInt!
}

"""Smart contract method"""
type Method {
  """Name"""
  name: String

  """Signature"""
  signature: String

  """Signature Hash"""
  signatureHash: String!
}

"""
Smart contract method. In selector you can use the name, signature or hex hash
"""
input MethodSelector {
  """Method signature is"""
  is: String

  """Method signature not"""
  not: String

  """Method signature in the list"""
  in: [String!]

  """Method signature not in the list"""
  notIn: [String!]
}

"""Information about miniblock"""
type MiniblockElrond {
  """Miniblock hash"""
  hash(miniblockHash: HashSelector): String

  """Hash of the receiver block"""
  receiverBlockHash(miniblockReceiverBlockHash: HashSelector): String

  """Number of the receiver shard"""
  receiverShard(miniblockReceiverShard: IntIdSelector): String

  """Miniblock type"""
  type(type: StringSelector): String
}

"""Name with an identifier"""
type NameWithId {
  """ID"""
  id: Int

  """Name"""
  name: String
}

enum Network {
  """Ethereum Mainnet"""
  ethereum

  """Ethereum Classic"""
  ethclassic

  """Ethereum Classic ( no reorg from block 10904146)"""
  ethclassic_reorg

  """Binance DEX"""
  binance

  """Celo Alfajores Testnet"""
  celo_alfajores

  """Celo Baklava Testnet"""
  celo_baklava

  """Celo RC1"""
  celo_rc1

  """Bitcoin ( BTC )"""
  bitcoin

  """Bitcoin Cash ( BCH )"""
  bitcash

  """Bitcoin SV ( BSV )"""
  bitcoinsv

  """Litecoin ( LTC )"""
  litecoin

  """Dash ( DASH )"""
  dash

  """Dogecoin ( DOGE )"""
  dogecoin

  """Cardano ( ADA )"""
  cardano

  """Zcash ( ZEC )"""
  zcash

  """Algorand Mainnet (ALGO)"""
  algorand

  """Algorand Testnet"""
  algorand_testnet

  """Algorand Betanet"""
  algorand_betanet

  """Conflux Oceanus"""
  conflux_oceanus

  """Conflux Tethys"""
  conflux_tethys

  """Libra Testnet"""
  libra_testnet

  """Diem Testnet"""
  diem_testnet

  """EOS Mainnet"""
  eos

  """TRON Mainnet"""
  tron

  """Binance Smart Chain Mainnet"""
  bsc

  """Binance Smart Chain Testnet"""
  bsc_testnet

  """Goerli Ethereum Testnet"""
  goerli

  """Beacon Chain Ethereum 2.0"""
  eth2

  """Medalla Ethereum 2.0 Beacon Testnet"""
  medalla

  """Filecoin Mainnet"""
  filecoin

  """Hedera Hashgraph"""
  hedera

  """Solana Mainnet"""
  solana

  """Matic (Polygon) Mainnet"""
  matic

  """Velas Mainnet"""
  velas

  """Velas Testnet"""
  velas_testnet

  """Klaytn Mainnet"""
  klaytn

  """Elrond Mainnet"""
  elrond
}

"""Offchain Data"""
type Offchain {
  """Historical COVID data"""
  covid: CovidHistory
}

"""Select order by ID"""
input OrderIdSelector {
  """Order ID is"""
  is: String

  """Order ID not"""
  not: String

  """Order ID in the list"""
  in: [String!]

  """Order ID not in the list"""
  notIn: [String!]
}

"""Select by order side"""
input OrderSideSelector {
  """Order Side is"""
  is: BinanceOrderSide

  """Order Side not"""
  not: BinanceOrderSide

  """Order Side in the list"""
  in: [BinanceOrderSide!]

  """Order Side not in the list"""
  notIn: [BinanceOrderSide!]
}

"""Select by order status"""
input OrderStatusSelector {
  """Order Status is"""
  is: BinanceOrderStatus

  """Order Status not"""
  not: BinanceOrderStatus

  """Order Status in the list"""
  in: [BinanceOrderStatus!]

  """Order Status not in the list"""
  notIn: [BinanceOrderStatus!]
}

"""Select by order time in force"""
input OrderTimeInForceSelector {
  """Order TimeInForce is"""
  is: BinanceOrderTimeInForce

  """Order TimeInForce not"""
  not: BinanceOrderTimeInForce

  """Order TimeInForce in the list"""
  in: [BinanceOrderTimeInForce!]

  """Order TimeInForce not in the list"""
  notIn: [BinanceOrderTimeInForce!]
}

"""Select by order type"""
input OrderTypeSelector {
  """Order Type is"""
  is: BinanceOrderType

  """Order Type not"""
  not: BinanceOrderType

  """Order Type in the list"""
  in: [BinanceOrderType!]

  """Order Type not in the list"""
  notIn: [BinanceOrderType!]
}

"""Select by output index ( o based )"""
input OutputIndexSelector {
  """Output index is"""
  is: Int

  """Output index not"""
  not: Int

  """Output index in the list"""
  in: [Int!]

  """Output index not in the list"""
  notIn: [Int!]

  """Output index greater than"""
  gt: Int

  """Output index less than"""
  lt: Int

  """Output index less or equal than"""
  lteq: Int

  """Output index greater or equal than"""
  gteq: Int

  """Output index in range"""
  between: [Int!]
}

"""Output Script Type of UTXO transaction output"""
type OutputScript {
  """Script annotation"""
  annotation: String

  """Long script pattern"""
  pattern: String!

  """Short script pattern"""
  short: String!

  """Simple script pattern"""
  simplePattern: String!

  """Script type"""
  type: BitcoinOutputScriptType
}

enum PriceAggregateFunction {
  """Maximum"""
  maximum

  """Minimum"""
  minimum

  """Aggregated over interval"""
  sum

  """Average"""
  average

  """Median"""
  median

  """Any value"""
  any

  """Last value"""
  anyLast
}

"""Solana Program"""
type Program {
  id: String!
  name: String!
  parsed: Boolean!
  parsedName: String!
}

enum Protocol {
  """Ethereum"""
  ethereum

  """Binance DEX"""
  binance

  """Bitcoin"""
  bitcoin

  """Algorand"""
  algorand

  """Libra"""
  libra

  """EOS"""
  eos

  """Tron"""
  tron

  """Filecoin"""
  filecoin

  """Hedera Hashgraph"""
  hedera

  """Solana"""
  solana

  """Cardano"""
  cardano

  """Elrond"""
  elrond
}

"""Blockchain Unified GraphQL API"""
type Query {
  """Algorand Chains Dataset"""
  algorand(network: AlgorandNetwork): Algorand

  """Binance DEX Chain Dataset"""
  binance: Binance

  """Bitcoin and other UTXO Chains Dataset"""
  bitcoin(network: BitcoinNetwork): Bitcoin

  """Cardano Chain Dataset"""
  cardano(network: CardanoNetwork): Cardano

  """Conflux Chains Dataset"""
  conflux(network: ConfluxNetwork): Conflux

  """Diem ( former Libra ) Testnet Dataset"""
  diem(network: DiemNetwork): Libra

  """Elrond Dataset"""
  elrond(network: ElrondNetwork): Elrond

  """EOS Mainnet Dataset"""
  eos(network: EosNetwork): Eos

  """Ethereum Mainnet / Classic Chain Datasets"""
  ethereum(network: EthereumNetwork): Ethereum

  """Ethereum v2.0 Beacon Chain Datasets"""
  ethereum2(network: Ethereum2Network): Ethereum2

  """Filecoin Dataset"""
  filecoin(network: FilecoinNetwork): Filecoin

  """Harmony Dataset"""
  harmony(network: HarmonyNetwork): Harmony

  """Hedera Dataset"""
  hedera(network: HederaNetwork): Hedera

  """Offchain data"""
  offchain: Offchain

  """Ripple Dataset"""
  ripple(network: RippleNetwork): Ripple

  """Search by query string"""
  search(string: String!, limit: Int, offset: Int, network: Network): [Result!]

  """Solana Dataset"""
  solana(network: SolanaNetwork): Solana

  """Stellar Dataset"""
  stellar(network: StellarNetwork): Stellar

  """Tron Mainnet Dataset"""
  tron(network: TronNetwork): Tron
}

"""Limits, Ordering, Constraints"""
input QueryOptions {
  """Limit number of results"""
  limit: Int

  """Limit number of results by specific field"""
  limitBy: LimitByOption

  """Offset of results, starting from 0"""
  offset: Int

  """Ordering field(s) for ascending"""
  asc: [String!]

  """Ordering field(s) for descending"""
  desc: [String!]
}

"""Solana Receiver"""
type Receiver {
  address: String!
  mintAccount: String!
  type: String!
}

"""Search result item"""
type Result {
  """Blockchain where result is found"""
  network: BlockchainNetwork!

  """Subject in blockchain"""
  subject: Subject!
}

"""Select by reward type"""
input RewardTypeSelector {
  """Type is"""
  is: SolanaRewardType

  """Type not"""
  not: SolanaRewardType

  """Type in the list"""
  in: [SolanaRewardType!]

  """Type not in the list"""
  notIn: [SolanaRewardType!]
}

"""Ripple Chain"""
type Ripple {
  """
  The Escrow object type represents a held payment of XRP waiting to be executed or canceled
  """
  accountRoots(date: DateSelector, blockHeight: BlockSelector, account: HashSelector, transactionType: TypeSelector, operation: HashSelector, prevBalance: IntegerSelector, balance: IntegerSelector, domain: StringSelector, ownerCount: IntegerSelector, transferRate: IntegerSelector, sequence: IntegerSelector, previousTxnId: HashSelector, previousTxnLedgerSeq: IntegerSelector, flags: IntegerSelector, any: [RippleAccountRootsFilter!], options: QueryOptions): [RippleAccountRoots!]

  """Ripple Balances"""
  balances(date: DateSelector, transactionHash: HashSelector, ledger: BlockSelector, transactionSender: HashSelector, account: HashSelector, issuer: HashSelector, prevBalance: HashSelector, prevLedgerSeq: HashSelector, flags: HashSelector, any: [RippleBalancesFilter!], options: QueryOptions): [RippleBalances!]

  """Ripple Blocks"""
  blocks(date: DateSelector, transactionHash: HashSelector, ledgerHash: HashSelector, ledger: BlockSelector, accountHash: HashSelector, any: [RippleBlocksFilter!], options: QueryOptions): [RippleBlocks!]

  """A check that can be redeemed for money by its destination."""
  checks(date: DateSelector, blockHeight: BlockSelector, sender: HashSelector, transactionType: HashSelector, operation: StringSelector, destination: HashSelector, sendMax: IntegerSelector, expiration: IntegerSelector, invoiceId: IntegerSelector, sourceTag: IntegerSelector, destinationTag: IntegerSelector, sequence: IntegerSelector, previousTxnId: IntegerSelector, previousTxnLedgerSeq: IntegerSelector, flags: IntegerSelector, any: [RippleChecksFilter!], options: QueryOptions): [RippleChecks!]

  """
  The Escrow object type represents a held payment of XRP waiting to be executed or canceled
  """
  escrows(date: DateSelector, blockHeight: BlockSelector, sender: HashSelector, transactionType: TypeSelector, operation: HashSelector, destination: HashSelector, amount: IntegerSelector, condition: HashSelector, cancelAfter: IntegerSelector, finishedAfter: IntegerSelector, sourceTag: IntegerSelector, destinationTag: IntegerSelector, previousTxnId: IntegerSelector, previousTxnLedgerSeq: IntegerSelector, flags: IntegerSelector, any: [RippleEscrowsFilter!], options: QueryOptions): [RippleEscrows!]

  """An order to make a currency trade."""
  offers(date: DateSelector, ledger: BlockSelector, transactionHash: HashSelector, transactionSender: HashSelector, transactionType: HashSelector, sequence: HashSelector, bookDirectory: HashSelector, account: HashSelector, any: [RippleOffersFilter!], options: QueryOptions): [RippleOffers!]

  """Ripple Payments"""
  payments(date: DateSelector, ledger: BlockSelector, transferTo: HashSelector, transferFrom: HashSelector, amountIssuer: HashSelector, deliverIssuer: HashSelector, sendMaxIssuer: HashSelector, deliverMinIssuer: HashSelector, tag: HashSelector, transactionHash: HashSelector, any: [RipplePaymentsFilter!], options: QueryOptions): [RipplePayments!]

  """The RippleState object type connects two accounts in a single currency"""
  rippleStates(date: DateSelector, blockHeight: BlockSelector, sender: HashSelector, transactionType: HashSelector, operation: StringSelector, lowAccount: HashSelector, highAccount: HashSelector, balance: IntegerSelector, preBalance: IntegerSelector, previousTxnId: IntegerSelector, previousTxnLedgerSeq: IntegerSelector, flags: IntegerSelector, any: [RippleStatesFilter!], options: QueryOptions): [RippleRippleStates!]

  """Ripple Transactions"""
  transactions(date: DateSelector, transactionHash: HashSelector, transactionType: TransactionTypeSelector, transactionFee: TransactionTypeSelector, ledger: BlockSelector, sender: HashSelector, sequence: HashSelector, result: HashSelector, lastLedgerSequence: HashSelector, status: Boolean, any: [RippleTransactionsFilter!], options: QueryOptions): [RippleTransactions!]

  """Ripple Transfers"""
  transfers(date: DateSelector, blockHeight: BlockSelector, sender: HashSelector, transactionType: StringSelector, transactionHash: HashSelector, transferFrom: HashSelector, transferTo: HashSelector, any: [RippleTransfersFilter!], options: QueryOptions): [RippleTransfers!]
}

"""
The AccountRoot object type describes a single account, its settings, and XRP balance.
"""
type RippleAccountRoots {
  """The identifying (classic) address of this account."""
  account(account: HashSelector): String
  any(of: RippleccountRootsMeasureable!): String

  """The account`s current XRP balance in drops, represented as a string."""
  balance(balance: IntegerSelector): BigInt

  """Number of block in the blockchains"""
  blockHeight(blockHeight: BlockSelector): BigInt
  count(uniq: RippleAccountRootsUniq): Int
  countBigInt(uniq: RippleAccountRootsUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """
  domain associated with this account. In JSON, this is the hexadecimal for the ASCII representation of the domain
  """
  domain(domain: StringSelector): String

  """	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
  """
  flags(flags: IntegerSelector): String
  maximum(of: RippleccountRootsMeasureable!, get: RippleccountRootsMeasureable): String
  minimum(of: RippleccountRootsMeasureable!, get: RippleccountRootsMeasureable): String

  """Operation"""
  operation(operation: HashSelector): String

  """
  The number of objects this account owns in the ledger, which contributes to its owner reserve.
  """
  ownerCount(ownerCount: IntegerSelector): Int

  """Previous Balance"""
  prevBalance(prevBalance: IntegerSelector): BigInt

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnId(previousTxnId: HashSelector): String

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnLedgerSeq(previousTxnLedgerSeq: IntegerSelector): BigInt

  """
  The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.)
  """
  sequence(sequence: IntegerSelector): BigInt

  """The time this transaction was created"""
  time: DateTime

  """Type of transaction"""
  transactionType(transactionType: TypeSelector): String

  """
  A transfer fee  to charge other users for sending currency issued by this account to each other.
  """
  transferRate(transferRate: IntegerSelector): BigInt
}

input RippleAccountRootsFilter {
  date: DateSelector
  blockHeight: BlockSelector
  account: HashSelector
  transactionType: TypeSelector
  operation: HashSelector
  prevBalance: IntegerSelector
  balance: IntegerSelector
  domain: StringSelector
  ownerCount: IntegerSelector
  transferRate: IntegerSelector
  sequence: IntegerSelector
  previousTxnId: HashSelector
  previousTxnLedgerSeq: IntegerSelector
  flags: IntegerSelector
}

enum RippleAccountRootsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  block_height

  """Unique currencies"""
  currencies

  """Unique sender"""
  sender
}

"""Balances in Ripple blockchain"""
type RippleBalances {
  """Account"""
  account(account: HashSelector): String
  any(of: RippleBalancesMeasureable!): String
  balance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transactionHash: HashSelector, ledger: BlockSelector, transactionSender: HashSelector, account: HashSelector, issuer: HashSelector, prevBalance: HashSelector, prevLedgerSeq: HashSelector, flags: HashSelector): Float
  count(uniq: RippleBalancesUniq): Int
  countBigInt(uniq: RippleBalancesUniq): BigInt

  """Currency"""
  currency: Currency

  """The date this transaction was created"""
  date: Date

  """Previous Ledge Seq"""
  flags(flags: HashSelector): BigInt

  """Issuer"""
  issuer(issuer: HashSelector): String

  """Block number"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: RippleBalancesMeasureable!, get: RippleBalancesMeasureable): String
  minimum(of: RippleBalancesMeasureable!, get: RippleBalancesMeasureable): String

  """Previous Balance"""
  prevBalance(prevBalance: HashSelector): Float

  """Previous Ledger Seq"""
  prevLedgerSeq(prevLedgerSeq: HashSelector): BigInt

  """The time this transaction was created"""
  time: DateTime

  """Transaction hash"""
  transactionHash(transactionHash: HashSelector): String

  """Transaction Sender"""
  transactionSender(transactionSender: HashSelector): String

  """Transaction type"""
  transactionType(transactionType: TransactionTypeSelector): String
}

input RippleBalancesFilter {
  date: DateSelector
  transactionHash: HashSelector
  ledger: BlockSelector
  transactionSender: HashSelector
  account: HashSelector
  issuer: HashSelector
  prevBalance: HashSelector
  prevLedgerSeq: HashSelector
  flags: HashSelector
}

enum RippleBalancesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Transaction Sender"""
  transaction_sender

  """Account"""
  account

  """Balance"""
  balance
}

enum RippleBalancesUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique ledger count"""
  ledger

  """Unique transaction hash count"""
  transactionHash

  """Unique transaction sender count"""
  transactionSender

  """Unique account count"""
  account

  """Unique issuer count"""
  issuer
}

"""Blocks in Ripple blockchain"""
type RippleBlocks {
  """Hash of this ledger`s state tree information."""
  accountHash(accountHash: HashSelector): String
  any(of: RippleBlocksMeasureable!): String
  count(uniq: RippleBlocksUniq): Int
  countBigInt(uniq: RippleBlocksUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Block number"""
  ledger(ledger: BlockSelector): BigInt

  """
  This serves as a unique identifier for this ledger and all its contents.
  """
  ledgerHash(ledgerHash: HashSelector): String
  maximum(of: RippleBlocksMeasureable!, get: RippleBlocksMeasureable): String
  minimum(of: RippleBlocksMeasureable!, get: RippleBlocksMeasureable): String

  """The time this transaction was created"""
  time: DateTime

  """The total number of drops of XRP owned by accounts in the ledger."""
  totalCoins: BigInt

  """Transaction hash"""
  transactionHash(transactionHash: HashSelector): String
}

input RippleBlocksFilter {
  date: DateSelector
  transactionHash: HashSelector
  ledgerHash: HashSelector
  ledger: BlockSelector
  accountHash: HashSelector
}

enum RippleBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block number"""
  ledger

  """
  This serves as a unique identifier for this ledger and all its contents
  """
  ledger_hash

  """The total number of drops of XRP owned by accounts in the ledger"""
  total_coins

  """Hash of this ledger`s state tree information"""
  account_hash
}

enum RippleBlocksUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique blocks"""
  ledger
}

"""Checks in Ripple blockchain"""
type RippleChecks {
  any(of: RippleChecksMeasureable!): String

  """Number of block in the blockchains"""
  blockHeight(blockHeight: BlockSelector): BigInt
  count(uniq: RippleChecksUniq): Int
  countBigInt(uniq: RippleChecksUniq): BigInt

  """Currency of transfer"""
  currency: Currency

  """The date this transaction was created"""
  date: Date

  """
  The destination address where the XRP is paid if the held payment is successful.
  """
  destination(destination: HashSelector): String

  """
  An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address.
  """
  destinationTag(destinationTag: IntegerSelector): BigInt

  """Indicates the time after which this Check is considered expired."""
  expiration(expiration: IntegerSelector): BigInt

  """
  A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
  """
  flags(flags: IntegerSelector): BigInt

  """The time after which this held payment can be finished"""
  invoiceId(invoiceId: IntegerSelector): String
  maximum(of: RippleChecksMeasureable!, get: RippleChecksMeasureable): String
  minimum(of: RippleChecksMeasureable!, get: RippleChecksMeasureable): String

  """Operation"""
  operation(operation: StringSelector): String

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnId(previousTxnId: HashSelector): String

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnLedgerSeq(previousTxnLedgerSeq: IntegerSelector): BigInt

  """The maximum amount of currency this Check can debit the sender. """
  sendMax(sendMax: IntegerSelector): BigInt

  """
  The sender of the Check. Cashing the Check debits this address`s balance.
  """
  sender(sender: HashSelector): String

  """
  The sequence number of the CheckCreate transaction that created this check.
  """
  sequence(sequence: IntegerSelector): BigInt

  """
  An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address.
  """
  sourceTag(sourceTag: IntegerSelector): BigInt

  """The time this transaction was created"""
  time: DateTime

  """Type of transaction"""
  transactionType(transactionType: TypeSelector): String
}

input RippleChecksFilter {
  date: DateSelector
  blockHeight: BlockSelector
  sender: HashSelector
  transactionType: HashSelector
  operation: StringSelector
  destination: HashSelector
  sendMax: IntegerSelector
  expiration: IntegerSelector
  invoiceId: IntegerSelector
  sourceTag: IntegerSelector
  destinationTag: IntegerSelector
  sequence: IntegerSelector
  previousTxnId: IntegerSelector
  previousTxnLedgerSeq: IntegerSelector
  flags: IntegerSelector
}

enum RippleChecksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Number of block in the blockhains"""
  block_height

  """Currency Symbol"""
  currency_symbol

  """Currency Address"""
  currency_address

  """
  The sender of the Check. Cashing the Check debits this address`s balance.
  """
  sender
}

enum RippleChecksUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  block_height

  """Unique currencies"""
  currencies

  """Unique sender"""
  sender

  """Unique destination"""
  destination
}

"""Escrows in Ripple blockchain"""
type RippleEscrows {
  """The amount of XRP, in drops, to be delivered by the held payment."""
  amount(amount: IntegerSelector): BigInt
  any(of: RippleEscrowsMeasureable!): String

  """Number of block in the blockchains"""
  blockHeight(blockHeight: BlockSelector): BigInt

  """
  The held payment can be canceled if and only if this field is present and the time it specifies has passed
  """
  cancelAfter(cancelAfter: IntegerSelector): BigInt

  """
  Crypto condition as hexadecimal. If present, the EscrowFinish transaction must contain a fulfillment that satisfies this condition.
  """
  condition(condition: HashSelector): String
  count(uniq: RippleEscrowsUniq): Int
  countBigInt(uniq: RippleEscrowsUniq): BigInt

  """Currency of transfer"""
  currency: Currency

  """The date this transaction was created"""
  date: Date

  """
  The destination address where the XRP is paid if the held payment is successful.
  """
  destination(destination: HashSelector): String

  """
  An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address.
  """
  destinationTag(destinationTag: IntegerSelector): BigInt

  """The time after which this held payment can be finished"""
  finishedAfter(finishedAfter: IntegerSelector): BigInt

  """	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
  """
  flags(flags: IntegerSelector): String
  maximum(of: RippleEscrowsMeasureable!, get: RippleEscrowsMeasureable): String
  minimum(of: RippleEscrowsMeasureable!, get: RippleEscrowsMeasureable): String

  """Operation"""
  operation(operation: HashSelector): String

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnId(previousTxnId: IntegerSelector): String

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnLedgerSeq(previousTxnLedgerSeq: IntegerSelector): BigInt

  """The address of the owner (sender) of this held payment"""
  sender(sender: HashSelector): String

  """
  An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address.
  """
  sourceTag(sourceTag: IntegerSelector): BigInt

  """The time this transaction was created"""
  time: DateTime

  """Type of transaction"""
  transactionType(transactionType: TypeSelector): String
}

input RippleEscrowsFilter {
  date: DateSelector
  blockHeight: BlockSelector
  sender: HashSelector
  transactionType: TypeSelector
  operation: HashSelector
  destination: HashSelector
  amount: IntegerSelector
  condition: HashSelector
  cancelAfter: IntegerSelector
  finishedAfter: IntegerSelector
  sourceTag: IntegerSelector
  destinationTag: IntegerSelector
  previousTxnId: IntegerSelector
  previousTxnLedgerSeq: IntegerSelector
  flags: IntegerSelector
}

enum RippleEscrowsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Number of block in the blockhains"""
  block_height

  """Currency Symbol"""
  currency_symbol

  """Currency Address"""
  currency_address

  """The address of the owner (sender) of this held payment"""
  sender
}

enum RippleEscrowsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  block_height

  """Unique sender"""
  sender

  """Unique destination"""
  destination
}

enum RippleNetwork {
  """Ripple XRP Ledger"""
  ripple
}

"""Offers in Ripple blockchain"""
type RippleOffers {
  any(of: RippleOffersMeasureable!): String

  """Book Directory"""
  bookDirectory(bookDirectory: HashSelector): String
  count(uniq: RippleOffersUniq): Int
  countBigInt(uniq: RippleOffersUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Expiration"""
  expiration: BigInt

  """Flags"""
  flags: BigInt

  """Block number"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: RippleOffersMeasureable!, get: RippleOffersMeasureable): String
  minimum(of: RippleOffersMeasureable!, get: RippleOffersMeasureable): String

  """Operation"""
  operation: String

  """Sequence"""
  sequence(sequence: HashSelector): Float
  takerGets(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, ledger: BlockSelector, transactionHash: HashSelector, transactionSender: HashSelector, transactionType: HashSelector, sequence: HashSelector, bookDirectory: HashSelector, account: HashSelector): BigInt

  """Taker Gets Currency"""
  takerGetsCurrency: Currency
  takerPays(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, ledger: BlockSelector, transactionHash: HashSelector, transactionSender: HashSelector, transactionType: HashSelector, sequence: HashSelector, bookDirectory: HashSelector, account: HashSelector): BigInt

  """Taker Pays Currency"""
  takerPaysCurrency: Currency

  """The time this transaction was created"""
  time: DateTime

  """Transaction hash"""
  transactionHash(transactionHash: HashSelector): String

  """Transaction Sender"""
  transactionSender(transactionSender: HashSelector): String

  """Transaction type"""
  transactionType(transactionType: TransactionTypeSelector): String
}

input RippleOffersFilter {
  date: DateSelector
  ledger: BlockSelector
  transactionHash: HashSelector
  transactionSender: HashSelector
  transactionType: HashSelector
  sequence: HashSelector
  bookDirectory: HashSelector
  account: HashSelector
}

enum RippleOffersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Transaction Sender"""
  transaction_sender

  """Transaction Type"""
  transaction_type

  """Taker Gets Currency Symbol"""
  taker_gets_currency_symbol

  """Taker Gets Currency Address"""
  taker_gets_currency_address

  """Taker Pays Currency Symbol"""
  taker_pays_currency_symbol

  """Taker Pays Currency Address"""
  taker_pays_currency_address
}

enum RippleOffersUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Uniq transaction hash"""
  transaction_hash

  """Uniq transaction sender"""
  transaction_sender
}

"""Payments in Ripple blockchain"""
type RipplePayments {
  """Amount Currency"""
  amountCurrency: Currency

  """Amount Issuer"""
  amountIssuer(amountIssuer: HashSelector): String
  amountValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, ledger: BlockSelector, transferTo: HashSelector, transferFrom: HashSelector, amountIssuer: HashSelector, deliverIssuer: HashSelector, sendMaxIssuer: HashSelector, deliverMinIssuer: HashSelector, tag: HashSelector, transactionHash: HashSelector): Float
  any(of: RipplePaymentsMeasureable!): String
  count(uniq: RipplePaymentsUniq): Int
  countBigInt(uniq: RipplePaymentsUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Delivered min currency"""
  deliverMinCurrency: Currency

  """Delivered Min Issuer"""
  deliverMinIssuer(deliverMinIssuer: HashSelector): String
  deliverMinValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, ledger: BlockSelector, transferTo: HashSelector, transferFrom: HashSelector, amountIssuer: HashSelector, deliverIssuer: HashSelector, sendMaxIssuer: HashSelector, deliverMinIssuer: HashSelector, tag: HashSelector, transactionHash: HashSelector): Float

  """Currency of the money sender's transfer"""
  deliveredCurrency: Currency

  """Delivered Value"""
  deliveredIssuer(deliveredIssuer: HashSelector): String
  deliveredValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, ledger: BlockSelector, transferTo: HashSelector, transferFrom: HashSelector, amountIssuer: HashSelector, deliverIssuer: HashSelector, sendMaxIssuer: HashSelector, deliverMinIssuer: HashSelector, tag: HashSelector, transactionHash: HashSelector): Float

  """Flags"""
  flags: BigInt

  """Invoice"""
  invoice: String

  """Block number"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: RipplePaymentsMeasureable!, get: RipplePaymentsMeasureable): String
  minimum(of: RipplePaymentsMeasureable!, get: RipplePaymentsMeasureable): String

  """Partial"""
  partial: BigInt

  """Currency of the money sender's transfer"""
  sendMaxCurrency: Currency

  """Send Max Issuer"""
  sendMaxIssuer(sendMaxIssuer: HashSelector): String
  sendMaxValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, ledger: BlockSelector, transferTo: HashSelector, transferFrom: HashSelector, amountIssuer: HashSelector, deliverIssuer: HashSelector, sendMaxIssuer: HashSelector, deliverMinIssuer: HashSelector, tag: HashSelector, transactionHash: HashSelector): Float

  """Tag"""
  tag(tag: HashSelector): BigInt

  """The time this transaction was created"""
  time: DateTime

  """Transaction hash"""
  transactionHash(transactionHash: HashSelector): String

  """Transfer from"""
  transferFrom(transferFrom: HashSelector): String

  """Transfer to"""
  transferTo(transferTo: HashSelector): String
}

input RipplePaymentsFilter {
  date: DateSelector
  ledger: BlockSelector
  transferTo: HashSelector
  transferFrom: HashSelector
  amountIssuer: HashSelector
  deliverIssuer: HashSelector
  sendMaxIssuer: HashSelector
  deliverMinIssuer: HashSelector
  tag: HashSelector
  transactionHash: HashSelector
}

enum RipplePaymentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Transfer From"""
  transfer_from

  """Transfer To"""
  transfer_to

  """Amount Value"""
  amount_value

  """Amount Currency Symbol"""
  amount_currency_symbol

  """Amount Currency Address"""
  amount_currency_address

  """Delivered Currency Symbol"""
  delivered_currency_symbol

  """Delivered Currency Address"""
  delivered_currency_address

  """Send max Currency Symbol"""
  send_max_currency_symbol

  """Send max Currency Address"""
  send_max_currency_address

  """Delivered Min Currency Symbol"""
  deliver_min_currency_symbol

  """Delivered Min Currency Address"""
  deliver_min_currency_address
}

enum RipplePaymentsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique blocks"""
  ledger

  """Unique transfer from"""
  transfer_from

  """Unique transfer to"""
  transfer_to
}

"""The RippleState object type connects two accounts in a single currency"""
type RippleRippleStates {
  any(of: RippleRippleStatesMeasureable!): String
  balance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHeight: BlockSelector, sender: HashSelector, transactionType: HashSelector, operation: StringSelector, lowAccount: HashSelector, highAccount: HashSelector, balance: IntegerSelector, preBalance: IntegerSelector, previousTxnId: IntegerSelector, previousTxnLedgerSeq: IntegerSelector, flags: IntegerSelector): Float

  """Number of block in the blockchains"""
  blockHeight(blockHeight: BlockSelector): BigInt
  count(uniq: RippleRippleStatesUniq): Int
  countBigInt(uniq: RippleRippleStatesUniq): BigInt

  """Currency of transfer"""
  currency: Currency

  """The date this transaction was created"""
  date: Date

  """	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
  """
  flags(flags: IntegerSelector): String

  """High Account"""
  highAccount(highAccount: HashSelector): String

  """Low Account"""
  lowAccount(lowAccount: HashSelector): String
  maximum(of: RippleRippleStatesMeasureable!, get: RippleRippleStatesMeasureable): String
  minimum(of: RippleRippleStatesMeasureable!, get: RippleRippleStatesMeasureable): String

  """Operation"""
  operation(operation: StringSelector): String

  """Previous Balance"""
  preBalance(preBalance: HashSelector): BigInt

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnId(previousTxnId: IntegerSelector): String

  """
  The identifying hash of the transaction that most recently modified this object.
  """
  previousTxnLedgerSeq(previousTxnLedgerSeq: IntegerSelector): BigInt

  """The address of the owner (sender) of this held payment"""
  sender(sender: HashSelector): String

  """The time this transaction was created"""
  time: DateTime

  """Type of transaction"""
  transactionType(transactionType: TypeSelector): String
}

enum RippleRippleStatesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Number of block in the blockhains"""
  block_height

  """Currency Symbol"""
  currency_symbol

  """Currency Address"""
  currency_address

  """The address of the owner (sender) of this held payment"""
  sender

  """Low Account"""
  low_account

  """High Account"""
  high_account
}

enum RippleRippleStatesUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  block_height

  """Unique currencies"""
  currencies

  """Unique sender"""
  sender

  """Unique Lower Account"""
  lower_account

  """Unique High Account"""
  high_account
}

input RippleStatesFilter {
  date: DateSelector
  blockHeight: BlockSelector
  sender: HashSelector
  transactionType: HashSelector
  operation: StringSelector
  lowAccount: HashSelector
  highAccount: HashSelector
  balance: IntegerSelector
  preBalance: IntegerSelector
  previousTxnId: IntegerSelector
  previousTxnLedgerSeq: IntegerSelector
  flags: IntegerSelector
}

"""Transactions in Ripple blockchain"""
type RippleTransactions {
  any(of: RippleTransactionsMeasureable!): String
  count(uniq: RippleTransactionsUniq): Int
  countBigInt(uniq: RippleTransactionsUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """
  A transactions Flags field can contain flags that apply at different levels or contexts.
  """
  flags: BigInt

  """Index in ledger"""
  indexInLedger: BigInt

  """Highest ledger index this transaction can appear in."""
  lastLedgerSequence(lastLedgerSequence: HashSelector): Float

  """Block number"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: RippleTransactionsMeasureable!, get: RippleTransactionsMeasureable): String

  """Additional arbitrary information used to identify this transaction."""
  memos: String
  minimum(of: RippleTransactionsMeasureable!, get: RippleTransactionsMeasureable): String

  """Result"""
  result(result: HashSelector): String

  """Transaction Sender"""
  sender(sender: HashSelector): String

  """The sequence number of the account sending the transaction."""
  sequence(sequence: HashSelector): Float

  """Successful of not"""
  status(status: Boolean): Boolean

  """The time this transaction was created"""
  time: DateTime

  """Transaction fee"""
  transactionFee(transactionFee: HashSelector): Float

  """Transaction hash"""
  transactionHash(transactionHash: HashSelector): String

  """Transaction type"""
  transactionType(transactionType: TransactionTypeSelector): String
}

input RippleTransactionsFilter {
  date: DateSelector
  transactionHash: HashSelector
  transactionType: TransactionTypeSelector
  transactionFee: TransactionTypeSelector
  ledger: BlockSelector
  sender: HashSelector
  sequence: HashSelector
  result: HashSelector
  lastLedgerSequence: HashSelector
  status: Boolean
}

enum RippleTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Transaction Fee"""
  transaction_fee

  """Transaction sender"""
  sender
}

enum RippleTransactionsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique sender count"""
  sender

  """Unique ledger count"""
  ledger
}

"""Transfers in Ripple blockchain"""
type RippleTransfers {
  any(of: RippleTransfersMeasureable!): String

  """Number of block in the blockchains"""
  blockHeight(blockHeight: BlockSelector): BigInt
  count(uniq: RippleTransfersUniq): Int
  countBigInt(uniq: RippleTransfersUniq): BigInt

  """Currency of the money sender's transfer"""
  currencyFrom: Currency

  """Currency of the money receiver's transfer"""
  currencyTo: Currency

  """The date this transaction was created"""
  date: Date
  maximum(of: RippleTransfersMeasureable!, get: RippleTransfersMeasureable): String
  minimum(of: RippleTransfersMeasureable!, get: RippleTransfersMeasureable): String

  """
  The sender of the Check. Cashing the Check debits this address`s balance.
  """
  sender(sender: HashSelector): String

  """The time this transaction was created"""
  time: DateTime

  """Transaction Hash"""
  transactionHash(transactionHash: HashSelector): String

  """Transfer From"""
  transferFrom(transferFrom: HashSelector): String

  """Transfer To"""
  transferTo(transferTo: HashSelector): String
  valueFrom(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHeight: BlockSelector, sender: HashSelector, transactionType: StringSelector, transactionHash: HashSelector, transferFrom: HashSelector, transferTo: HashSelector): Float
  valueTo(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHeight: BlockSelector, sender: HashSelector, transactionType: StringSelector, transactionHash: HashSelector, transferFrom: HashSelector, transferTo: HashSelector): Float
}

input RippleTransfersFilter {
  date: DateSelector
  blockHeight: BlockSelector
  sender: HashSelector
  transactionType: StringSelector
  transactionHash: HashSelector
  transferFrom: HashSelector
  transferTo: HashSelector
}

enum RippleTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Number of block in the blockhains"""
  block_height

  """Currency Symbol of the money sender`s transfer"""
  currency_from_symbol

  """Currency Address of the money sender`s transfer"""
  currency_from_address

  """Currency Symbol of the money receiver`s transfer"""
  currency_to_symbol

  """Currency Address of the money receiver`s trasfer"""
  currency_to_address

  """The sender of the payment"""
  sender

  """Transfer From"""
  transfer_from

  """Transfer To"""
  transfer_to

  """Value From"""
  value_from

  """Value To"""
  value_to
}

enum RippleTransfersUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  block_height

  """Unique currencies"""
  currencies

  """Unique sender"""
  sender

  """Unique destination"""
  destination
}

enum RippleccountRootsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Number of block in the blockhains"""
  block_height

  """The identifying (classic) address of this account."""
  account
}

enum ScriptTypeSelectorSelector {
  """Unknown Transaction"""
  unknown_transaction

  """Peer-to-peer"""
  peer_to_peer_transaction
}

"""Solana Sender"""
type Sender {
  address: String!
  mintAccount: String!
  type: String!
}

"""Smart contract method or event"""
union Signature = Event | Method

enum SignatureTypeSelector {
  """Smart contract method"""
  Function

  """Smart contract event"""
  Event
}

"""Blockchain smart contract"""
type SmartContract {
  """String address representation"""
  address: String

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract Type"""
  contractType: SmartContractType!

  """Smart Contract Protocol Type"""
  protocol: String
}

enum SmartContractArgumentsUniq {
  """Unique signatures count"""
  signatures

  """Unique values"""
  values

  """Calls or events"""
  calls

  """Unique transactions count"""
  txs

  """Unique transaction senders"""
  senders

  """Unique callers count"""
  callers

  """Unique smart contracts count"""
  smart_contracts

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

enum SmartContractCallsUniq {
  """Calls"""
  calls

  """Unique transactions count"""
  txs

  """Unique transaction senders"""
  senders

  """Unique callers count"""
  callers

  """Unique smart contracts count"""
  smart_contracts

  """Unique smart contract methods count"""
  smart_contract_methods

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

enum SmartContractEventsUniq {
  """Unique callers count"""
  tx_to

  """Unique transaction senders"""
  tx_from

  """Unique transactions count"""
  txs

  """Unique smart contracts count"""
  smart_contracts

  """Unique smart contract methods count"""
  smart_contract_methods

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

type SmartContractReadonlyAttribute {
  """Value as address if applicable"""
  address: EthereumAddressInfo

  """Method name"""
  name: String!

  """Method return type"""
  type: String!

  """Method return value"""
  value: String!
}

enum SmartContractType {
  """Not A Smart contract"""
  None

  """General Purpose Smart contract"""
  Generic

  """Smart contract for token derivatives"""
  MarginPositionToken

  """Multi signature wallet"""
  Multisig

  """Token"""
  Token

  """Token Sale"""
  TokenSale

  """Decentralized exchange"""
  DEX

  """Transaction Execution Approval Language"""
  TEAL
}

"""Selector of smart contract type"""
input SmartContractTypeSelector {
  """Smart Contract type is"""
  is: SmartContractType

  """Smart Contract type not"""
  not: SmartContractType

  """Smart Contract type in the list"""
  in: [SmartContractType!]

  """Smart Contract type not in the list"""
  notIn: [SmartContractType!]
}

"""Solana Chain"""
type Solana {
  """BlockRewards of Smart Contract Calls and Events"""
  blockRewards(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector, postBalance: AmountSelector, account: StringSelector, rewardType: RewardTypeSelector, any: [SolanaBlockRewardFilter!], options: QueryOptions): [SolanaBlockReward!]

  """Solana Blocks"""
  blocks(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, parentSlot: IntegerSelector, transactionCount: IntegerSelector, rewards: AmountSelector, any: [SolanaBlockFilter!], options: QueryOptions): [SolanaBlock!]

  """
  Each instruction specifies a single program, a subset of the transaction`s accounts
          that should be passed to the program.
  """
  instructionAccounts(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: StringSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, parsed: IntegerSelector, parsedActionName: StringSelector, parsedType: StringSelector, external: IntegerSelector, callPath: StringSelector, fee: IntegerSelector, account: StringSelector, accountType: StringSelector, accountOwner: StringSelector, accountIndex: IntegerSelector, any: [SolanaInstructionAccountFilter!], options: QueryOptions): [SolanaInstructionAccount!]

  """
  Each instruction specifies a single program, a subset of the transaction`s accounts
          that should be passed to the program.
  """
  instructions(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: StringSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: IntegerSelector, callPath: StringSelector, fee: IntegerSelector, any: [SolanaInstructionFilter!], options: QueryOptions): [SolanaInstruction!]

  """Solana Transaction"""
  transactions(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, parentSlot: BlockSelector, instructionsCount: IntegerSelector, innerInstructionsCount: IntegerSelector, accountsCount: IntegerSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, fee: IntegerSelector, signer: HashSelector, transactionFee: AmountSelector, any: [SolanaTransactionFilter!], options: QueryOptions): [SolanaTransaction!]

  """Currency transfers from/to addresses in crypto currencies"""
  transfers(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, currency: [SolanaCurrencySelector!], any: [SolanaTransferFilter!], options: QueryOptions): [SolanaTransfer!]
}

"""Solana Account"""
type SolanaAccount {
  index: Int!
  name: String!
  owner: String!
  type: String!
}

"""Block in Solana  blockchain"""
type SolanaBlock {
  any(of: SolanaBlockMeasureable!): String

  """Hash of the the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: SolanaBlockUniq): Int
  countBigInt(uniq: SolanaBlockUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Number of block in the blockchains"""
  height(height: BlockSelector): BigInt
  maximum(of: SolanaBlockMeasureable!, get: SolanaBlockMeasureable): String
  minimum(of: SolanaBlockMeasureable!, get: SolanaBlockMeasureable): String

  """The slot index of this block`s parent"""
  parentSlot(parentSlot: IntegerSelector): BigInt

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String
  rewards(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, parentSlot: IntegerSelector, transactionCount: IntegerSelector, rewards: AmountSelector): Float

  """The time this transaction was created"""
  time: DateTime

  """Count of transactions in this block"""
  transactionCount(transactionCount: IntegerSelector): Int
}

input SolanaBlockFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  parentSlot: IntegerSelector
  transactionCount: IntegerSelector
  rewards: AmountSelector
}

"""Solana Block Info"""
type SolanaBlockInfo {
  """Hash hex representation"""
  hash: String!

  """Block number (height) in blockchain"""
  height: Int!
  parentSlot: BigInt
  previousBlockHash: String

  """Block timestamp"""
  timestamp: DateTime
}

enum SolanaBlockMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Number of reward lamports credited or debited by the account"""
  rewards

  """The slot index of this block`s parent"""
  parent_slot

  """Count of transactions in this block"""
  transaction_count
}

"""BlockReward in Solana  blockchain"""
type SolanaBlockReward {
  """Account"""
  account(account: BlockSelector): String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector, postBalance: AmountSelector, account: StringSelector, rewardType: RewardTypeSelector): Float
  any(of: SolanaBlockRewardMeasureable!): String

  """Block where  transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  count(uniq: SolanaBlockRewardUniq): Int
  countBigInt(uniq: SolanaBlockRewardUniq): BigInt

  """Currency of transfer"""
  currency: Currency

  """The date this transaction was created"""
  date: Date
  maximum(of: SolanaBlockRewardMeasureable!, get: SolanaBlockRewardMeasureable): String
  minimum(of: SolanaBlockRewardMeasureable!, get: SolanaBlockRewardMeasureable): String
  postBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector, postBalance: AmountSelector, account: StringSelector, rewardType: RewardTypeSelector): Float

  """Type of reward"""
  rewardType(rewardType: RewardTypeSelector): String
}

input SolanaBlockRewardFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  reward: AmountSelector
  parentSlot: IntegerSelector
  postBalance: AmountSelector
  account: StringSelector
  rewardType: RewardTypeSelector
}

enum SolanaBlockRewardMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Number of reward lamports credited or debited by the account"""
  amount

  """The slot index of this block`s parent"""
  parent_slot

  """Account balances after the transaction was processed"""
  post_balance

  """Account"""
  account
}

enum SolanaBlockRewardUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique hash of the the block"""
  block_hash

  """Unique accounts"""
  account

  """Unique currencies"""
  currencies
}

enum SolanaBlockUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height
}

"""
Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol
"""
input SolanaCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Instruction in Solana  blockchain"""
type SolanaInstruction {
  """Accounts count"""
  accountsCount: Int

  """Action"""
  action(parsedActionName: StringSelector, parsedType: StringSelector): Action
  any(of: SolanaInstructionMeasureable!): String

  """Block where  transaction is included"""
  block(height: BlockSelector, blockHash: HashSelector, time: DateTimeSelector): SolanaBlockInfo

  """Call Path"""
  callPath(callPath: StringSelector): String
  count(uniq: SolanaInstructionUniq): Int
  countBigInt(uniq: SolanaInstructionUniq): BigInt

  """Instruction Data"""
  data(dataBase58: StringSelector, dataHex: StringSelector): Data

  """The date this transaction was created"""
  date: Date

  """External"""
  external(external: BooleanSelector): Boolean

  """External Action"""
  externalAction(externalParsedActionName: StringSelector, externalParsedType: StringSelector): Action

  """External Program"""
  externalProgram(externalProgramId: StringSelector, externalProgramName: StringSelector, externalParsedProgramName: StringSelector): Program
  log: Log
  maximum(of: SolanaInstructionMeasureable!, get: SolanaInstructionMeasureable): String
  minimum(of: SolanaInstructionMeasureable!, get: SolanaInstructionMeasureable): String

  """Program"""
  program(programId: StringSelector, programName: StringSelector, parsedProgramName: StringSelector): Program

  """Transaction where instruction is included"""
  transaction(signature: HashSelector): SolanaTransactionInfo
}

"""InstructionAccount in Solana  blockchain"""
type SolanaInstructionAccount {
  """Information about account"""
  account(accountName: StringSelector, accountOwner: StringSelector, accountType: StringSelector, accountIndex: IntegerSelector): SolanaAccount
  any(of: SolanaInstructionAccountMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, blockHash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  count(uniq: SolanaInstructionAccountUniq): Int
  countBigInt(uniq: SolanaInstructionAccountUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Instruction"""
  instruction: Instruction
  maximum(of: SolanaInstructionAccountMeasureable!, get: SolanaInstructionAccountMeasureable): String
  minimum(of: SolanaInstructionAccountMeasureable!, get: SolanaInstructionAccountMeasureable): String

  """Transaction"""
  transaction(transactionIndex: IntegerSelector, signature: HashSelector): SolanaTransactionInfo
}

input SolanaInstructionAccountFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: StringSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  parsed: IntegerSelector
  parsedActionName: StringSelector
  parsedType: StringSelector
  external: IntegerSelector
  callPath: StringSelector
  fee: IntegerSelector
  account: StringSelector
  accountType: StringSelector
  accountOwner: StringSelector
  accountIndex: IntegerSelector
}

enum SolanaInstructionAccountMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Transaction Hash"""
  signature
}

enum SolanaInstructionAccountUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Number of block in the blockchains"""
  height

  """Transaction Hash"""
  signature

  """Account name"""
  account_name
}

input SolanaInstructionFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: StringSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  parsed: IntegerSelector
  externalParsed: IntegerSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  externalParsedType: StringSelector
  external: IntegerSelector
  callPath: StringSelector
  fee: IntegerSelector
}

enum SolanaInstructionMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Transaction Hash"""
  signature

  """Transaction Fee"""
  fee
}

enum SolanaInstructionUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Number of block in the blockchains"""
  height

  """Transaction Hash"""
  signature
}

enum SolanaNetwork {
  """Solana Mainnat"""
  solana
}

enum SolanaRewardType {
  """fee type"""
  Fee

  """rent type"""
  Rent

  """voing type"""
  Voting

  """staking type"""
  Staking
}

"""Transaction in Solana  blockchain"""
type SolanaTransaction {
  """Count of inner instructions"""
  accountsCount(accountsCount: IntegerSelector): Int
  any(of: SolanaTransactionMeasureable!): String

  """Block where  transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  count(uniq: SolanaTransactionUniq): Int
  countBigInt(uniq: SolanaTransactionUniq): BigInt

  """The date this transaction was created"""
  date: Date

  """Error"""
  error(error: StringSelector): String

  """Fee Payer"""
  feePayer(feePayer: HashSelector): String

  """Count of inner instructions"""
  innerInstructionsCount(innerInstructionsCount: IntegerSelector): Int

  """Count of instructions"""
  instructionsCount(instructionsCount: IntegerSelector): Int
  maximum(of: SolanaTransactionMeasureable!, get: SolanaTransactionMeasureable): String
  minimum(of: SolanaTransactionMeasureable!, get: SolanaTransactionMeasureable): String

  """
  Recent blockhash prevents duplication and to give transactions lifetimes
  """
  recentBlockHash(recentBlockHash: HashSelector): String

  """Transaction Hash"""
  signature(signature: HashSelector): String

  """Accounts` public keys"""
  signer(signer: HashSelector): String

  """Successed or failed"""
  success(success: BooleanSelector): Boolean
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, parentSlot: BlockSelector, instructionsCount: IntegerSelector, innerInstructionsCount: IntegerSelector, accountsCount: IntegerSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, fee: IntegerSelector, signer: HashSelector, transactionFee: AmountSelector): Float

  """Transaction Index"""
  transactionIndex(transactionIndex: IntegerSelector): Int
}

input SolanaTransactionFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  parentSlot: BlockSelector
  instructionsCount: IntegerSelector
  innerInstructionsCount: IntegerSelector
  accountsCount: IntegerSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  success: BooleanSelector
  fee: IntegerSelector
  signer: HashSelector
  transactionFee: AmountSelector
}

"""Solana Transaction Info"""
type SolanaTransactionInfo {
  feePayer: String
  signature: String
  success: Boolean
  transactionIndex: BigInt
}

"""Solana Transaction Info Extended"""
type SolanaTransactionInfoExt {
  accountsCount: Int
  error: String
  fee: Float
  feePayer: String
  innerInstructionsCount: Int
  instructionsCount: Int
  recentBlockHash: String
  signature: String
  signer: String
  success: Boolean
  transactionIndex: BigInt
}

enum SolanaTransactionMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """The slot index of this block`s parent"""
  parent_slot

  """Transaction Hash"""
  signature

  """Transaction Fee"""
  fee

  """Transaction Fee"""
  transaction_fee
}

enum SolanaTransactionUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Number of block in the blockchains"""
  height

  """Transaction Hash"""
  signature

  """Accounts` public key"""
  signer
}

"""Currency transfers from/to addresses in crypto currencies"""
type SolanaTransfer {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, currency: [SolanaCurrencySelector!]): Float
  any(of: SolanaTransferMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  count(uniq: SolanaTransferUniq): Int
  countBigInt(uniq: SolanaTransferUniq): BigInt

  """Currency of transfer"""
  currency: Currency

  """The date this transaction was created"""
  date: Date

  """Instruction where transfer is included"""
  instruction: InstructionWithExternals
  maximum(of: SolanaTransferMeasureable!, get: SolanaTransferMeasureable): String
  minimum(of: SolanaTransferMeasureable!, get: SolanaTransferMeasureable): String

  """Receiver"""
  receiver: Receiver

  """Sender"""
  sender: Sender

  """Transaction where transfer is included"""
  transaction(signature: HashSelector): SolanaTransactionInfoExt

  """Transfer Type"""
  transferType(transferType: SolanaTransferTypeSelector): String
}

input SolanaTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsed: IntegerSelector
  externalParsed: IntegerSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  externalParsedType: StringSelector
  external: StringSelector
  callPath: StringSelector
  senderAddress: StringSelector
  senderType: StringSelector
  receiverAddress: StringSelector
  receiverType: StringSelector
  transferType: SolanaTransferTypeSelector
  currency: [SolanaCurrencySelector!]
}

enum SolanaTransferMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Transaction Hash"""
  signature

  """Transaction Fee"""
  fee_payer

  """Transfer Type"""
  transfer_type

  """Amount Transfer"""
  amount
}

enum SolanaTransferType {
  """Transfer"""
  transfer

  """Self"""
  self

  """Mint"""
  mint

  """Create Account"""
  create_account

  """Close Account"""
  close_account

  """Rent Exemption"""
  rent_exemption

  """Stake"""
  stake

  """Stake Withdraw"""
  stake_withdraw

  """Trade Unknown"""
  trade_unknown

  """Burn"""
  burn

  """Vote"""
  vote

  """Nonce Withdraw"""
  nonce_withdraw
}

"""Select by transfer type"""
input SolanaTransferTypeSelector {
  """Type is"""
  is: SolanaTransferType

  """Type not"""
  not: SolanaTransferType

  """Type in the list"""
  in: [SolanaTransferType!]

  """Type not in the list"""
  notIn: [SolanaTransferType!]
}

enum SolanaTransferUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Number of block in the blockchains"""
  height

  """Transaction Hash"""
  signature

  """Transfer From"""
  sender_address

  """Transfer To"""
  receiver_address
}

enum StakingTransactionsTypeEnum {
  """"""
  CreateValidator

  """"""
  EditValidator

  """"""
  CollectRewards

  """"""
  Undelegate

  """"""
  Delegate
}

"""Indicates what type of operation the transaction is supposed to do."""
input StakingTransactionsTypeSelector {
  """Type is"""
  is: StakingTransactionsTypeEnum

  """Type not"""
  not: StakingTransactionsTypeEnum

  """Type in the list"""
  in: [StakingTransactionsTypeEnum!]

  """Type not in the list"""
  notIn: [StakingTransactionsTypeEnum!]
}

"""Stellar Chain"""
type Stellar {
  """Stellar Transfers"""
  transfers(date: DateSelector, transactionHash: HashSelector, receiver: HashSelector, sender: HashSelector, direction: HashSelector, any: [StellarTransfersFilter!], options: QueryOptions): [StellarTransfers!]
}

enum StellarNetwork {
  """The Stellar Ledger"""
  stellar
}

"""Transfers in Stellar blockchain"""
type StellarTransfers {
  amountFrom(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transactionHash: HashSelector, receiver: HashSelector, sender: HashSelector, direction: HashSelector): Float
  amountTo(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transactionHash: HashSelector, receiver: HashSelector, sender: HashSelector, direction: HashSelector): Float
  any(of: StellarTransfersMeasureable!): String
  count(uniq: StellarTransfersUniq): Int
  countBigInt(uniq: StellarTransfersUniq): BigInt

  """Currency from of transfer"""
  currencyFrom: Currency

  """Currency to of transfer"""
  currencyTo: Currency

  """The date this transaction was created"""
  date: Date

  """Direction"""
  direction(direction: StringSelector): String

  """
  The sequence number of the ledger that this transaction was included in
  """
  ledger: BigInt
  maximum(of: StellarTransfersMeasureable!, get: StellarTransfersMeasureable): String
  minimum(of: StellarTransfersMeasureable!, get: StellarTransfersMeasureable): String

  """Operation"""
  operation: String

  """The number of operations contained within this transaction"""
  operationCount: BigInt

  """The account this transaction is been sent to"""
  receiver(receiver: HashSelector): String

  """Sender"""
  sender(sender: HashSelector): String

  """The time this transaction was created"""
  time: DateTime

  """Hash of this transaction"""
  transactionHash(transactionHash: HashSelector): String
}

input StellarTransfersFilter {
  date: DateSelector
  transactionHash: HashSelector
  receiver: HashSelector
  sender: HashSelector
  direction: HashSelector
}

enum StellarTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Transaction Hash"""
  transaction_hash

  """Transfer Receiver"""
  receiver

  """Transfer Sender"""
  sender
}

enum StellarTransfersUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique date count"""
  transaction_hash

  """Transfer Receiver"""
  receiver

  """Transfer sender"""
  sender
}

"""Select by ID"""
input StringIdSelector {
  """ID is"""
  is: String

  """ID not"""
  not: String

  """ID in the list"""
  in: [String!]

  """ID not in the list"""
  notIn: [String!]
}

"""Select by string"""
input StringSelector {
  """String is"""
  is: String

  """String not"""
  not: String

  """String in the list"""
  in: [String!]

  """String not in the list"""
  notIn: [String!]
}

"""Search result subject"""
union Subject = Address | Currency | SmartContract | TransactionHash

"""Blockchain Unified GraphQL Subscription API"""
type Subscription {
  """Ethereum Mainnet / Classic Chain Datasets"""
  ethereum(network: EthereumNetwork): Ethereum
}

"""Time Interval"""
type TimeInterval {
  day(count: Int, format: String): String!
  hour(count: Int, format: String): String!
  minute(count: Int, format: String): String!
  month(count: Int, format: String): String!
  second(count: Int, format: String): String!
  year(count: Int, format: String): String!
}

"""Timestamp"""
type Timestamp {
  """Nanoseconds"""
  nanoseconds: BigInt!
  time: ISO8601Date!
}

"""Select trade by ID"""
input TradeIdSelector {
  """Trade ID is"""
  is: String

  """Trade ID not"""
  not: String

  """Trade ID in the list"""
  in: [String!]

  """Trade ID not in the list"""
  notIn: [String!]
}

enum TradeSide {
  """Buy side"""
  BUY

  """Sell side"""
  SELL
}

"""Information about transaction"""
type TransactionElrond {
  """Shard number of sender"""
  data(data: StringSelector): String

  """Shard number of sender"""
  dataOperation(dataOperation: StringSelector): String
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Transaction hash"""
  hash(txHash: HashSelector): String

  """Transaction index"""
  index(index: IntegerSelector): Int

  """Transaction nonce"""
  nonce(nonce: IntegerSelector): Int

  """Hash of the receiver"""
  receiver(txReceiver: HashSelector): Address

  """Shard number of receiver"""
  receiverShard(txReceiverShard: IntIdSelector): BigInt

  """Hash of the sender"""
  sender(txSender: HashSelector): Address

  """Shard number of sender"""
  senderShard(txSenderShard: IntIdSelector): BigInt

  """Shard number of sender"""
  signature(signature: HashSelector): String

  """Shard number of sender"""
  status(status: StringSelector): String
}

"""Blockchain transaction"""
type TransactionHash {
  """Hash hex representation"""
  hash: String!
}

"""Blockchain transaction"""
type TransactionHashIndex {
  """Block of the Output Transaction for this input"""
  block: Int

  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0-based"""
  index: String!
}

"""Blockchain transaction with value"""
type TransactionHashValue {
  """Hash hex representation"""
  hash: String!

  """Transaction value"""
  value: Float!
}

"""Transaction result"""
type TransactionResult {
  """Result ID"""
  id: Int!

  """Result name"""
  name: String!
}

"""Identification of transaction source as client application"""
type TransactionSource {
  """ID numeric"""
  code: Int!

  """Name"""
  name: String!
}

enum TransactionTypeEnum {
  """Set options on an account"""
  AccountSet

  """Delete an account"""
  AccountDelete

  """Cancel a check"""
  CheckCancel

  """Redeem a check"""
  CheckCash

  """Create a check"""
  CheckCreate

  """Preauthorizes an account to send payments to this one"""
  DepositPreauth

  """Reclaim escrowed XRP"""
  EscrowCancel

  """Create an ascrowed XRP payment"""
  EscrowCreate

  """Deliver escrowed XRP recipient"""
  EscrowFinish

  """Withdraw a currency-exchange order"""
  OfferCancel

  """Sibmit an order to exchange currency"""
  OfferCreate

  """Send funds from one account to another"""
  Payment

  """Claim money from a payment channel"""
  PaymentChannelClaim

  """Open a new payment channel"""
  PaymentChannelCreate

  """Add more XRP to a payment channel"""
  PaymentChannelFund

  """Add, remove or modify an accounts regular key pair"""
  SetRegularKey

  """Add, remove, or modify an accounts multi-signing list"""
  SignerListSet

  """Setaside one or more sequence numbers as Tickets"""
  TicketCreate

  """Add or modify a trust line"""
  TrustSet
}

"""Indicates what type of operation the transaction is supposed to do."""
input TransactionTypeSelector {
  """Type is"""
  is: TransactionTypeEnum

  """Type not"""
  not: TransactionTypeEnum

  """Type in the list"""
  in: [TransactionTypeEnum!]

  """Type not in the list"""
  notIn: [TransactionTypeEnum!]
}

enum TransferReasonEnum {
  """Transaction"""
  transaction

  """Smart Contract Call"""
  call_result

  """ESDT Transfer"""
  esdt_transfer

  """NFT Transfer"""
  nft_transfer
}

"""Select by transfer reason"""
input TransferReasonSelector {
  """Reason is"""
  is: TransferReasonEnum

  """Reason not"""
  not: TransferReasonEnum

  """Reason in the list"""
  in: [TransferReasonEnum!]

  """Reason not in the list"""
  notIn: [TransferReasonEnum!]
}

"""Select by type of transfer"""
input TransferTypeSelector {
  """Transfer Type is"""
  is: FilecoinTransferType

  """Transfer Type not"""
  not: FilecoinTransferType

  """Transfer Type in the list"""
  in: [FilecoinTransferType!]

  """Transfer Type not in the list"""
  notIn: [FilecoinTransferType!]
}

enum TransfersUniq {
  """Transfers"""
  transfers

  """Unique transactions count"""
  txs

  """Unique senders count"""
  senders

  """Unique receivers count"""
  receivers

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique currencies"""
  currencies
}

"""Tron Chain"""
type Tron {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [TronAddressInfo!]!

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!], any: [TronBlockFilter!], options: QueryOptions): [TronBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [TronCoinpath!]

  """Blockchain Embedded Contracts"""
  contracts(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean, any: [TronContractFilter!], options: QueryOptions): [TronSmartContracts!]

  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [TronDexTradeFilter!], options: QueryOptions): [TronDexTrades!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, any: [TronSmartContractCallFilter!], options: QueryOptions): [TronSmartContractCalls!]

  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, any: [TronSmartContractEventFilter!], options: QueryOptions): [TronSmartContractEvents!]

  """Blockchain Embedded Contracts"""
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean, any: [TronTradeFilter!], options: QueryOptions): [TronTrades!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector, any: [TronTransactionFilter!], options: QueryOptions): [TronTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [TronTransferFilter!], options: QueryOptions): [TronTransfers!]
}

"""Address detailed information for Tron network"""
type TronAddressInfo {
  """Address"""
  address: String

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract if exists on the address"""
  smartContract: TronSmartContractInfo
}

input TronBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  witness: AddressSelector
  version: IntegerSelector
  parentBlockHash: [HashSelector!]
}

"""Blocks in Tron blockchain"""
type TronBlocks {
  any(of: TronBlocksMeasureable!): String
  count(uniq: TronBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!]): Int
  countBigInt(uniq: TronBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String
  minimum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String

  """Parent block hash"""
  parentBlockHash(parentBlockHash: [HashSelector!]): String!

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """TX Trie Root Hash"""
  txTrieRoot: String!

  """Block version"""
  version(version: IntegerSelector): Int

  """Block witness"""
  witness(witness: AddressSelector): Address

  """Witness signature"""
  witnessSignature: String!
}

enum TronBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Witness address"""
  witness

  """Block Version"""
  version
}

enum TronBlocksUniq {
  """Unique witness count"""
  witnesses

  """Unique date count"""
  dates
}

enum TronCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

"""Coinpath"""
type TronCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Count of transfers"""
  countBigInt: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: TronAddressInfo

  """Sender address"""
  sender: TronAddressInfo

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

input TronContractFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txOwner: AddressSelector
  contractType: TronContractTypeSelector
  currency: TronCurrencySelector
  success: Boolean
}

enum TronContractType {
  """Account Create"""
  AccountCreate

  """Account Permission Update"""
  AccountPermissionUpdate

  """Account Update"""
  AccountUpdate

  """Asset Issue"""
  AssetIssue

  """Clear ABI"""
  ClearABI

  """Create Smart"""
  CreateSmart

  """Exchange Create"""
  ExchangeCreate

  """Exchange Inject"""
  ExchangeInject

  """Exchange Transaction"""
  ExchangeTransaction

  """Exchange Withdraw"""
  ExchangeWithdraw

  """Freeze Balance"""
  FreezeBalance

  """Participate Asset Issue"""
  ParticipateAssetIssue

  """Proposal Approve"""
  ProposalApprove

  """Proposal Create"""
  ProposalCreate

  """Proposal Delete"""
  ProposalDelete

  """Set Account Id"""
  SetAccountId

  """Transfer"""
  Transfer

  """Transfer Asset"""
  TransferAsset

  """Trigger Smart"""
  TriggerSmart

  """Unfreeze Asset"""
  UnfreezeAsset

  """Unfreeze Balance"""
  UnfreezeBalance

  """Update Asset"""
  UpdateAsset

  """Update Brokerage"""
  UpdateBrokerage

  """Update Energy Limit"""
  UpdateEnergyLimit

  """Update Setting"""
  UpdateSetting

  """Vote Witness"""
  VoteWitness

  """Withdraw Balance"""
  WithdrawBalance

  """Witness Create"""
  WitnessCreate

  """Witness Update"""
  WitnessUpdate
}

"""Select contract type(s)"""
input TronContractTypeSelector {
  """Contract type is"""
  is: TronContractType

  """Contract type not"""
  not: TronContractType

  """Contract type in the list"""
  in: [TronContractType!]

  """Contract type not in the list"""
  notIn: [TronContractType!]
}

enum TronContractsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction owner"""
  tx_owner

  """Contract"""
  contract_type
}

"""
Currency selector in Tron blockchain.
Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
"""
input TronCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Tron DEX attributes"""
type TronDex {
  """Address for DEX exchange identification"""
  address: Address!

  """Full name ( name for known, Protocol for unknown )"""
  fullName: String!

  """Full name ( name for known, Protocol / address for unknown )"""
  fullNameWithId: String!

  """Name for known exchanges"""
  name: String
}

input TronDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  protocol: [StringSelector!]
  smartContractAddress: [AddressSelector!]
  exchangeAddress: [AddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [TronCurrencySelector!]
  buyCurrency: [TronCurrencySelector!]
  baseCurrency: [TronCurrencySelector!]
  quoteCurrency: [TronCurrencySelector!]
  maker: [AddressSelector!]
  taker: [AddressSelector!]
  makerOrTaker: [AddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

"""Trades on DEX smart contracts"""
type TronDexTrades {
  """Trader (maker or taker)"""
  address(makerOrTaker: [AddressSelector!]): TronAddressInfo
  any(of: TronDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Base currency"""
  baseCurrency(baseCurrency: [TronCurrencySelector!]): Currency

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Maker buys this currency"""
  buyCurrency(buyCurrency: [TronCurrencySelector!]): Currency
  count(uniq: TronDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  countBigInt(uniq: TronDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt

  """Calendar date"""
  date: Date
  energyFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  """
  Identification of admin / manager / factory of smart contract, executing trades
  """
  exchange(exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!]): TronDex
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  internalTransactionsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  internalTransactionsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt
  logsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  logsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt

  """Trade 'maker' side"""
  maker(maker: [AddressSelector!]): TronAddressInfo
  maximum(of: TronDexTradesMeasureable!, get: TronDexTradesMeasureable): String
  minimum(of: TronDexTradesMeasureable!, get: TronDexTradesMeasureable): String
  netFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  price(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  """Protocol name of the smart contract"""
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Quote currency"""
  quoteCurrency(quoteCurrency: [TronCurrencySelector!]): Currency
  quotePrice(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Maker sells this currency"""
  sellCurrency(sellCurrency: [TronCurrencySelector!]): Currency

  """Side of trade ( SELL / BUY )"""
  side: TradeSide

  """Smart contract being called"""
  smartContract(smartContractAddress: [AddressSelector!]): TronSmartContract

  """Trade 'taker' side"""
  taker(taker: [AddressSelector!]): TronAddressInfo

  """Time interval"""
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float

  """Index of trade in transaction, used to separate trades in transaction"""
  tradeIndex(tradeIndex: [StringSelector!]): String

  """Transaction of DexTrade"""
  transaction(txHash: [HashSelector!]): TronTransactionInfoExtended
}

enum TronDexTradesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Buy Amount"""
  buy_amount

  """Sell Amount"""
  sell_amount

  """Price"""
  price

  """Quote Price"""
  quote_price

  """Maker"""
  maker

  """Taker"""
  taker

  """Buy Currency symbol"""
  buy_currency_symbol

  """Buy Token address"""
  buy_currency_address

  """Sell Currency symbol"""
  sell_currency_symbol

  """Sell Token address"""
  sell_currency_address
}

enum TronDexTradesUniq {
  """Unique makers count"""
  makers

  """Unique makers count"""
  takers

  """Unique makers & takers count"""
  address

  """Buy currencies count"""
  buy_currency

  """Sell currencies count"""
  sell_currency

  """Base currencies count"""
  base_currency

  """Quote currencies count"""
  quote_currency

  """Unique blocks"""
  blocks

  """Unique transactions count"""
  txs

  """Unique date count"""
  dates

  """Unique smart contract count"""
  smart_contracts

  """Unique protocols count"""
  protocols
}

enum TronEventsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash
}

enum TronNetwork {
  """TRON mainnet"""
  tron
}

"""Tron smart contract"""
type TronSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input TronSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

"""Smart Contract Calls"""
type TronSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  any(of: TronCallsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): BigInt

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float

  """
  External call executed explicitly by caller. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  maximum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  minimum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float

  """Smart contract being called"""
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

input TronSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

"""Smart Contract Events"""
type TronSmartContractEvents {
  any(of: TronEventsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector): BigInt

  """Calendar date"""
  date: Date
  maximum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String
  minimum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String

  """Smart contract being Evented"""
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  """Contract method invoked"""
  smartContractEvent(smartContractEvent: EventSelector): Event

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

"""Blockchain smart contract"""
type TronSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

"""Contracts"""
type TronSmartContracts {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  any(of: TronContractsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Contract type"""
  contractType(contractType: TronContractTypeSelector): TronContractType

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Int

  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): BigInt

  """Currency of transfer"""
  currency(currency: TronCurrencySelector): Currency

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  maximum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  minimum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Transactio owner from address"""
  txOwner(txOwner: AddressSelector): Address
}

input TronTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: AddressSelector
  seller: AddressSelector
  buyCurrency: TronCurrencySelector
  sellCurrency: TronCurrencySelector
  contractType: TronContractTypeSelector
  amountSell: [AmountSelector!]
  amountBuy: [AmountSelector!]
  exchangeId: IntIdSelector
  success: Boolean
}

"""Currency Trades from/to addresses in crypto currencies"""
type TronTrades {
  amountBuy(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  amountSell(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  any(of: TronTradesMeasureable!): String

  """Block where Trade transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Buy Currency of Trade"""
  buyCurrency(buyCurrency: TronCurrencySelector): Currency

  """Trade buyer"""
  buyer(buyer: AddressSelector): Address

  """Contract type"""
  contractType(contractType: TronContractTypeSelector): TronContractType
  count(uniq: TronTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Int
  countBigInt(uniq: TronTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): BigInt

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float

  """exchange_id"""
  exchangeId(exchangeId: IntIdSelector): Int
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  maximum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  minimum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float

  """Sell Currency of Trade"""
  sellCurrency(sellCurrency: TronCurrencySelector): Currency

  """Trade seller"""
  seller(seller: AddressSelector): Address

  """Transfer succeeded"""
  success(success: Boolean): Boolean

  """Transaction hash where Trade happened"""
  txHash(txHash: HashSelector): String
}

enum TronTradesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount Sell"""
  amount_sell

  """Amount Sell"""
  amount_buy

  """Buyer"""
  buyer

  """Seller"""
  seller

  """Buy Currency symbol"""
  buy_currency_symbol

  """Buy Currency name"""
  buy_currency_name

  """Buy Token address"""
  buy_currency_address

  """Buy Token address"""
  buy_token_id

  """Buy Token type"""
  buy_token_type

  """Buy Currency symbol"""
  sell_currency_symbol

  """Buy Currency name"""
  sell_currency_name

  """Buy Token address"""
  sell_currency_address

  """Buy Token address"""
  sell_token_id

  """Buy Token type"""
  sell_token_type

  """Exchange ID"""
  exchange_id

  """Contract Type"""
  contract_type
}

enum TronTradesUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Sellers count"""
  sellers

  """Buyers count"""
  buyers

  """Buy currencies"""
  buy_currencies

  """Sell currencies"""
  sell_currencies

  """Exchange IDs"""
  exchanges
}

input TronTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  refBlockHash: [HashSelector!]
  contractAddress: AddressSelector
}

"""Blockchain Transaction Extended info"""
type TronTransactionInfoExtended {
  """Contract Address"""
  contractAddress: Address

  """Expiration"""
  expiration: Int!

  """Fee Limit"""
  feeLimit: Int!

  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0 based"""
  index: Int

  """Ref block Hash hex representation"""
  refBlockHash: String!

  """Result message"""
  result: String

  """Signatures"""
  signatures: String!

  """Success"""
  success: Boolean
}

"""Transactions in Tron blockchain"""
type TronTransactions {
  any(of: TronTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Contract Address"""
  contractAddress(contractAddress: AddressSelector): Address
  count(uniq: TronTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  countBigInt(uniq: TronTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): BigInt

  """Calendar date"""
  date: Date
  energyFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  """Expiration"""
  expiration: Int!
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  """Fee Limit"""
  feeLimit: Int!

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  internalTransactionsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  internalTransactionsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): BigInt
  logsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  logsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): BigInt
  maximum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  minimum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  netFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  """Ref block Hash hex representation"""
  refBlockHash(refBlockHash: [HashSelector!]): String!

  """Result message"""
  result: String

  """Signatures"""
  signatures: String!

  """Success"""
  success(success: Boolean): Boolean
}

enum TronTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Fee"""
  fee

  """Fee Limit"""
  fee_limit

  """Energy Fee"""
  energy_fee

  """Net usage"""
  net_usage

  """Internal transactions count"""
  internal_transactions_count
}

enum TronTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input TronTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: TronCurrencySelector
  contractType: TronContractTypeSelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type TronTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: TronTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Contract type"""
  contractType(contractType: TronContractTypeSelector): TronContractType
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt

  """Currency of transfer"""
  currency(currency: TronCurrencySelector): Currency

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float

  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  minimum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Transfer succeeded"""
  success(success: Boolean): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

enum TronTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Token address"""
  currency_address

  """Token ID"""
  token_id

  """Token type"""
  token_type
}

"""Selector of index of transaction in block"""
input TxIndexSelector {
  """Tx index is"""
  is: Int

  """Tx index not"""
  not: Int

  """Tx index in the list"""
  in: [Int!]

  """Tx index not in the list"""
  notIn: [Int!]
}

"""Select transactions by subtype"""
input TxSubtypeSelector {
  """Transaction SubType is"""
  is: AlgorandTxSubType

  """Transaction SubType not"""
  not: AlgorandTxSubType

  """Transaction SubType in the list"""
  in: [AlgorandTxSubType!]

  """Transaction SubType not in the list"""
  notIn: [AlgorandTxSubType!]
}

"""Select transactions by type"""
input TxTypeSelector {
  """Transaction Type is"""
  is: AlgorandTxType

  """Transaction Type not"""
  not: AlgorandTxType

  """Transaction Type in the list"""
  in: [AlgorandTxType!]

  """Transaction Type not in the list"""
  notIn: [AlgorandTxType!]
}

"""Select by type"""
input TypeSelector {
  """Type is"""
  is: String

  """Type not"""
  not: String

  """Type in the list"""
  in: [String!]

  """Type not in the list"""
  notIn: [String!]
}

